/*
File timeconstraint.cpp
*/

/***************************************************************************
                          timeconstraint.cpp  -  description
                             -------------------
    begin                : 2002
    copyright            : (C) 2002 by Liviu Lalescu
    email                : Please see https://lalescu.ro/liviu/ for details about contacting Liviu Lalescu (in particular, you can find there the email address)
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software: you can redistribute it and/or modify  *
 *   it under the terms of the GNU Affero General Public License as        *
 *   published by the Free Software Foundation, version 3 of the License.  *
 *                                                                         *
 ***************************************************************************/

#include "timetable_defs.h"
#include "timeconstraint.h"
#include "rules.h"
#include "solution.h"
#include "activity.h"
#include "teacher.h"
#include "subject.h"
#include "activitytag.h"
#include "studentsset.h"

#include "matrix.h"

#include <QString>

#include "messageboxes.h"

#include <QSet>

#include <QDataStream>

//for min max functions
//2025-04-03: also for std::stable_sort
#include <algorithm>
//using namespace std;

//1
QDataStream& operator<<(QDataStream& stream, const ConstraintBasicCompulsoryTime& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	return stream;
}

//2
QDataStream& operator<<(QDataStream& stream, const ConstraintBreakTimes& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.days<<tc.hours;

	return stream;
}

//3
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherNotAvailableTimes& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.days<<tc.hours<<tc.teacher;

	return stream;
}

//4
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily;

	return stream;
}

//5
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.teacherName;

	return stream;
}

//6
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxGapsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//7
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxGapsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.teacherName;

	return stream;
}

//8
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.teacherName;

	return stream;
}

//9
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursContinuously;

	return stream;
}

//10
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursContinuously<<tc.teacherName;

	return stream;
}

//11
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyDays<<tc.minHoursDaily;

	return stream;
}

//12
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyDays<<tc.minHoursDaily<<tc.teacherName;

	return stream;
}

//13
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxGapsPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//14
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxGapsPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.teacherName;

	return stream;
}

//15
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour;

	return stream;
}

//16
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour<<tc.students;

	return stream;
}

//17
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetNotAvailableTimes& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.days<<tc.hours<<tc.students;

	return stream;
}

//18
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxGapsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//19
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxGapsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.students;

	return stream;
}

//20
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily;

	return stream;
}

//21
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.students;

	return stream;
}

//22
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursContinuously;

	return stream;
}

//23
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursContinuously<<tc.students;

	return stream;
}

//24
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyDays<<tc.minHoursDaily;

	return stream;
}

//25
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyDays<<tc.minHoursDaily<<tc.students;

	return stream;
}

//26
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityEndsStudentsDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId;

	return stream;
}

//27
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityPreferredStartingTime& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId<<tc.day<<tc.hour<<tc.permanentlyLocked;

	return stream;
}

//28
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesSameStartingTime& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities;

	return stream;
}

//29
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesNotOverlapping& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities;

	return stream;
}

//30
QDataStream& operator<<(QDataStream& stream, const ConstraintMinDaysBetweenActivities& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.consecutiveIfSameDay<<tc.minDays;

	return stream;
}

//31
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityPreferredTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.p_activityId<<tc.p_days_L<<tc.p_hours_L<<tc.p_nPreferredTimeSlots_L;

	return stream;
}

//32
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesPreferredTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.duration<<tc.p_days_L<<tc.p_hours_L<<tc.p_nPreferredTimeSlots_L
		 <<tc.p_activityTagName<<tc.p_studentsName<<tc.p_subjectName<<tc.p_teacherName;

	return stream;
}

//33
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityPreferredStartingTimes& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId<<tc.days_L<<tc.hours_L<<tc.nPreferredStartingTimes_L;

	return stream;
}

//34
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesPreferredStartingTimes& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.duration<<tc.days_L<<tc.hours_L<<tc.nPreferredStartingTimes_L
		 <<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName;

	return stream;
}

//35
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesSameStartingHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities;

	return stream;
}

//36
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesSameStartingDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities;

	return stream;
}

//37
QDataStream& operator<<(QDataStream& stream, const ConstraintTwoActivitiesConsecutive& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityId<<tc.secondActivityId;

	return stream;
}

//38
QDataStream& operator<<(QDataStream& stream, const ConstraintTwoActivitiesOrdered& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityId<<tc.secondActivityId;

	return stream;
}

//39
QDataStream& operator<<(QDataStream& stream, const ConstraintMinGapsBetweenActivities& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.minGaps;

	return stream;
}

//40
QDataStream& operator<<(QDataStream& stream, const ConstraintSubactivitiesPreferredTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.duration<<tc.p_days_L<<tc.p_hours_L<<tc.p_nPreferredTimeSlots_L
		 <<tc.p_activityTagName<<tc.p_studentsName<<tc.p_subjectName<<tc.p_teacherName<<tc.componentNumber;

	return stream;
}

//41
QDataStream& operator<<(QDataStream& stream, const ConstraintSubactivitiesPreferredStartingTimes& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.duration<<tc.days_L<<tc.hours_L<<tc.nPreferredStartingTimes_L
		 <<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName<<tc.componentNumber;

	return stream;
}

//42
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.startHour<<tc.endHour<<tc.maxDaysPerWeek<<tc.teacherName;

	return stream;
}

//43
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.startHour<<tc.endHour<<tc.maxDaysPerWeek;

	return stream;
}

//44
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.startHour<<tc.endHour<<tc.maxDaysPerWeek<<tc.students;

	return stream;
}

//45
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.startHour<<tc.endHour<<tc.maxDaysPerWeek;

	return stream;
}

//46
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesEndStudentsDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName;

	return stream;
}

//47
QDataStream& operator<<(QDataStream& stream, const ConstraintTwoActivitiesGrouped& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityId<<tc.secondActivityId;

	return stream;
}

//48
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersActivityTagMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursContinuously;

	return stream;
}

//49
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherActivityTagMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursContinuously<<tc.teacherName;

	return stream;
}

//50
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsActivityTagMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursContinuously;

	return stream;
}

//51
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetActivityTagMaxHoursContinuously& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursContinuously<<tc.students;

	return stream;
}

//52
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek;

	return stream;
}

//53
QDataStream& operator<<(QDataStream& stream, const ConstraintThreeActivitiesGrouped& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityId<<tc.secondActivityId<<tc.thirdActivityId;

	return stream;
}

//54
QDataStream& operator<<(QDataStream& stream, const ConstraintMaxDaysBetweenActivities& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.maxDays;

	return stream;
}

//55
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minDaysPerWeek;

	return stream;
}

//56
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minDaysPerWeek<<tc.teacherName;

	return stream;
}

//57
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersActivityTagMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily;

	return stream;
}

//58
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherActivityTagMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily<<tc.teacherName;

	return stream;
}

//59
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsActivityTagMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily;

	return stream;
}

//60
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetActivityTagMaxHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily<<tc.students;

	return stream;
}

//61
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxGapsPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//62
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxGapsPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.students;

	return stream;
}

//63
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesOccupyMaxTimeSlotsFromSelection& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.maxOccupiedTimeSlots<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//64
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.maxSimultaneous<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//65
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.students;

	return stream;
}

//66
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek;

	return stream;
}

//67
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxSpanPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowOneDayExceptionPlusOne<<tc.maxSpanPerDay<<tc.teacherName;

	return stream;
}

//68
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxSpanPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowOneDayExceptionPlusOne<<tc.maxSpanPerDay;

	return stream;
}

//69
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinRestingHours& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.circular<<tc.minRestingHours<<tc.teacherName;

	return stream;
}

//70
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinRestingHours& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.circular<<tc.minRestingHours;

	return stream;
}

//71
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxSpanPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxSpanPerDay<<tc.students;

	return stream;
}

//72
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxSpanPerDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxSpanPerDay;

	return stream;
}

//73
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinRestingHours& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.circular<<tc.minRestingHours<<tc.students;

	return stream;
}

//74
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinRestingHours& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.circular<<tc.minRestingHours;

	return stream;
}

//75
QDataStream& operator<<(QDataStream& stream, const ConstraintTwoActivitiesOrderedIfSameDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityId<<tc.secondActivityId;

	return stream;
}

//76
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps<<tc.students;

	return stream;
}

//77
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps;

	return stream;
}

//78
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps<<tc.teacher;

	return stream;
}

//79
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps;

	return stream;
}

//80
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityTagsNotOverlapping& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagsNames;

	return stream;
}

//81
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesOccupyMinTimeSlotsFromSelection& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.minOccupiedTimeSlots<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//82
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesMinSimultaneousInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.allowEmptySlots<<tc.minSimultaneous<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//83
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersActivityTagMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.minHoursDaily<<tc.minDaysWithTag;

	return stream;
}

//84
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherActivityTagMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.minHoursDaily<<tc.minDaysWithTag<<tc.teacherName;

	return stream;
}

//85
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsActivityTagMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.minHoursDaily<<tc.minDaysWithTag;

	return stream;
}

//86
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetActivityTagMinHoursDaily& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.minHoursDaily<<tc.minDaysWithTag<<tc.students;

	return stream;
}

//87
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityEndsTeachersDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId;

	return stream;
}

//88
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesEndTeachersDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName;

	return stream;
}

//89
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily;

	return stream;
}

//90
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxRealDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.teacherName;

	return stream;
}

//91
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.teacherName;

	return stream;
}

//92
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily;

	return stream;
}

//93
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.students;

	return stream;
}

//94
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxRealDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek;

	return stream;
}

//95
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinRealDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minDaysPerWeek;

	return stream;
}

//96
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinRealDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minDaysPerWeek<<tc.teacherName;

	return stream;
}

//97
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersActivityTagMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily;

	return stream;
}

//98
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherActivityTagMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily<<tc.teacherName;

	return stream;
}

//99
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsActivityTagMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily;

	return stream;
}

//100
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetActivityTagMaxHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.maxHoursDaily<<tc.students;

	return stream;
}

//101
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxAfternoonsPerWeek<<tc.teacherName;

	return stream;
}

//102
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxAfternoonsPerWeek;

	return stream;
}

//103
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxMorningsPerWeek<<tc.teacherName;

	return stream;
}

//104
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxMorningsPerWeek;

	return stream;
}

//105
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxActivityTagsPerDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName<<tc.maxTags<<tc.tagsList;

	return stream;
}

//106
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxActivityTagsPerDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;
	
	stream<<tc.maxTags<<tc.tagsList;

	return stream;
}

//107
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minMorningsPerWeek;

	return stream;
}

//108
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minMorningsPerWeek<<tc.teacherName;

	return stream;
}

//109
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minAfternoonsPerWeek;

	return stream;
}

//110
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minAfternoonsPerWeek<<tc.teacherName;

	return stream;
}

//111
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxTwoConsecutiveMornings& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName;

	return stream;
}

//112
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxTwoConsecutiveMornings& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	return stream;
}

//113
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxTwoConsecutiveAfternoons& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName;

	return stream;
}

//114
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxTwoConsecutiveAfternoons& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	return stream;
}

//115
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxGapsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowOneDayExceptionPlusOne<<tc.maxGaps;

	return stream;
}

//116
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxGapsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowOneDayExceptionPlusOne<<tc.maxGaps<<tc.teacherName;

	return stream;
}

//117
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxGapsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//118
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxGapsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.students;

	return stream;
}

//119
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyDays<<tc.minHoursDaily;

	return stream;
}

//120
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinHoursDailyRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyDays<<tc.minHoursDaily<<tc.teacherName;

	return stream;
}

//121
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour;

	return stream;
}

//122
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour<<tc.teacherName;

	return stream;
}

//123
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinHoursPerMorning& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyMornings<<tc.minHoursPerMorning;

	return stream;
}

//124
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinHoursPerMorning& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyMornings<<tc.minHoursPerMorning<<tc.teacherName;

	return stream;
}

//125
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxSpanPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowOneDayExceptionPlusOne<<tc.maxSpanPerDay<<tc.teacherName;

	return stream;
}

//126
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxSpanPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowOneDayExceptionPlusOne<<tc.maxSpanPerDay;

	return stream;
}

//127
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxSpanPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxSpanPerDay<<tc.students;

	return stream;
}

//128
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxSpanPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxSpanPerDay;

	return stream;
}

//129
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMorningIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour<<tc.teacherName;

	return stream;
}

//130
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMorningIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour;

	return stream;
}

//131
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour<<tc.teacherName;

	return stream;
}

//132
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour;

	return stream;
}

//133
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinHoursPerMorning& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyMornings<<tc.minHoursPerMorning;

	return stream;
}

//134
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinHoursPerMorning& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyMornings<<tc.minHoursPerMorning<<tc.students;

	return stream;
}

//135
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxZeroGapsPerAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName;

	return stream;
}

//136
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxZeroGapsPerAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	return stream;
}

//137
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxAfternoonsPerWeek<<tc.students;

	return stream;
}

//138
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxAfternoonsPerWeek;

	return stream;
}

//139
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxMorningsPerWeek<<tc.students;

	return stream;
}

//140
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxMorningsPerWeek;

	return stream;
}

//141
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minMorningsPerWeek;

	return stream;
}

//142
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinMorningsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minMorningsPerWeek<<tc.students;

	return stream;
}

//143
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minAfternoonsPerWeek;

	return stream;
}

//144
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinAfternoonsPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minAfternoonsPerWeek<<tc.students;

	return stream;
}

//145
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMorningIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour<<tc.students;

	return stream;
}

//146
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMorningIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour;

	return stream;
}

//147
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour<<tc.students;

	return stream;
}

//148
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.startHour<<tc.endHour;

	return stream;
}

//149
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxHoursPerAllAfternoons& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursPerAllAfternoons<<tc.teacherName;

	return stream;
}

//150
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxHoursPerAllAfternoons& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursPerAllAfternoons;

	return stream;
}

//151
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxHoursPerAllAfternoons& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursPerAllAfternoons<<tc.students;

	return stream;
}

//152
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxHoursPerAllAfternoons& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursPerAllAfternoons;

	return stream;
}

//153
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minRestingHours<<tc.teacherName;

	return stream;
}

//154
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minRestingHours;

	return stream;
}

//155
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minRestingHours<<tc.students;

	return stream;
}

//156
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.minRestingHours;

	return stream;
}

//157
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour<<tc.students;

	return stream;
}

//158
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour;

	return stream;
}

//159
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxGapsPerWeekForRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//160
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxGapsPerWeekForRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.teacherName;

	return stream;
}

//161
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxGapsPerWeekForRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//162
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxGapsPerWeekForRealDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.students;

	return stream;
}

//163
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxRealDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek<<tc.students;

	return stream;
}

//164
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxRealDaysPerWeek& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxDaysPerWeek;

	return stream;
}

//165
QDataStream& operator<<(QDataStream& stream, const ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.maxActivities<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//166
QDataStream& operator<<(QDataStream& stream, const ConstraintMaxGapsBetweenActivities& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.maxGaps;

	return stream;
}

//167
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesMaxInATerm& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.maxActivitiesInATerm;

	return stream;
}

//168
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesOccupyMaxTerms& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.maxOccupiedTerms;

	return stream;
}

//169
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxGapsPerMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps;

	return stream;
}

//170
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxGapsPerMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxGaps<<tc.teacherName;

	return stream;
}

//171
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour;

	return stream;
}

//172
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour<<tc.teacherName;

	return stream;
}

//173
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour<<tc.students;

	return stream;
}

//174
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxBeginningsAtSecondHour;

	return stream;
}

//175
QDataStream& operator<<(QDataStream& stream, const ConstraintTwoSetsOfActivitiesOrdered& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivitiesIdsList<<tc.secondActivitiesIdsList;

	return stream;
}

//176
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxThreeConsecutiveDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowAMAMException;

	return stream;
}

//177
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxThreeConsecutiveDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowAMAMException<<tc.teacherName;

	return stream;
}

//178
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinGapsBetweenActivityTag& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps<<tc.students;

	return stream;
}

//179
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinGapsBetweenActivityTag& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps;

	return stream;
}

//180
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinGapsBetweenActivityTag& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps<<tc.teacher;

	return stream;
}

//181
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinGapsBetweenActivityTag& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps;

	return stream;
}

//182
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxThreeConsecutiveDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowAMAMException;

	return stream;
}

//183
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxThreeConsecutiveDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowAMAMException<<tc.students;

	return stream;
}

//184
QDataStream& operator<<(QDataStream& stream, const ConstraintMinHalfDaysBetweenActivities& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.consecutiveIfSameDay<<tc.minDays;

	return stream;
}

//185
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityPreferredDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId<<tc.day;

	return stream;
}

//186
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesMinInATerm& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.minActivitiesInATerm<<tc.allowEmptyTerms;

	return stream;
}

//187
QDataStream& operator<<(QDataStream& stream, const ConstraintMaxTermsBetweenActivities& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.maxTerms;

	return stream;
}

//188
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxActivityTagsPerDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.students<<tc.maxTags<<tc.tagsList;

	return stream;
}

//189
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxActivityTagsPerDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;
	
	stream<<tc.maxTags<<tc.tagsList;

	return stream;
}

//190
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName<<tc.maxTags<<tc.tagsList;

	return stream;
}

//191
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxTags<<tc.tagsList;

	return stream;
}

//192
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.students<<tc.maxTags<<tc.tagsList;

	return stream;
}

//193
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;
	
	stream<<tc.maxTags<<tc.tagsList;

	return stream;
}

//194
QDataStream& operator<<(QDataStream& stream, const ConstraintMaxHalfDaysBetweenActivities& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.maxDays;

	return stream;
}

//195
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityBeginsStudentsDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId;

	return stream;
}

//196
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesBeginStudentsDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName;

	return stream;
}

//197
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityBeginsTeachersDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId;

	return stream;
}

//198
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesBeginTeachersDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName;

	return stream;
}

//199
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinHoursPerAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyAfternoons<<tc.minHoursPerAfternoon;

	return stream;
}

//200
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinHoursPerAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyAfternoons<<tc.minHoursPerAfternoon<<tc.teacherName;

	return stream;
}

//201
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinHoursPerAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyAfternoons<<tc.minHoursPerAfternoon;

	return stream;
}

//202
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinHoursPerAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.allowEmptyAfternoons<<tc.minHoursPerAfternoon<<tc.students;

	return stream;
}

//203
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesMaxHourlySpan& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.n_activities<<tc.maxHourlySpan;

	return stream;
}

//204
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxHoursDailyInInterval& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.teacherName<<tc.startHour<<tc.endHour;

	return stream;
}

//205
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxHoursDailyInInterval& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.startHour<<tc.endHour;

	return stream;
}

//206
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxHoursDailyInInterval& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.students<<tc.startHour<<tc.endHour;

	return stream;
}

//207
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxHoursDailyInInterval& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursDaily<<tc.startHour<<tc.endHour;

	return stream;
}

//208
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps<<tc.students;

	return stream;
}

//209
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps;

	return stream;
}

//210
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps<<tc.teacher;

	return stream;
}

//211
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps;

	return stream;
}

//212
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps<<tc.students;

	return stream;
}

//213
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps;

	return stream;
}

//214
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps<<tc.teacher;

	return stream;
}

//215
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps;

	return stream;
}

//216
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps<<tc.students;

	return stream;
}

//217
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps;

	return stream;
}

//218
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps<<tc.teacher;

	return stream;
}

//219
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.firstActivityTag<<tc.secondActivityTag<<tc.minGaps;

	return stream;
}

//220
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps<<tc.students;

	return stream;
}

//221
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps;

	return stream;
}

//222
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps<<tc.teacher;

	return stream;
}

//223
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTag<<tc.minGaps;

	return stream;
}

//224
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersNoTwoConsecutiveDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	return stream;
}

//225
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherNoTwoConsecutiveDays& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName;

	return stream;
}

//226
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName<<tc.day1<<tc.hour1<<tc.day2<<tc.hour2;

	return stream;
}

//227
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.day1<<tc.hour1<<tc.day2<<tc.hour2;

	return stream;
}

//228
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.students<<tc.day1<<tc.hour1<<tc.day2<<tc.hour2;

	return stream;
}

//229
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.day1<<tc.hour1<<tc.day2<<tc.hour2;

	return stream;
}

//230
QDataStream& operator<<(QDataStream& stream, const ConstraintTwoSetsOfActivitiesSameSections& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesAIds<<tc.activitiesBIds<<tc.oDays<<tc.oHours;

	return stream;
}

//231
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxSingleGaps<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//232
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.students<<tc.maxSingleGaps<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//233
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxSingleGaps<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//234
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacher<<tc.maxSingleGaps<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//235
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherMaxHoursPerTerm& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursPerTerm<<tc.teacherName;

	return stream;
}

//236
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersMaxHoursPerTerm& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxHoursPerTerm;

	return stream;
}

//237
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName<<tc.selectedDays1<<tc.selectedHours1<<tc.selectedDays2<<tc.selectedHours2;

	return stream;
}

//238
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.selectedDays1<<tc.selectedHours1<<tc.selectedDays2<<tc.selectedHours2;

	return stream;
}

//239
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.students<<tc.selectedDays1<<tc.selectedHours1<<tc.selectedDays2<<tc.selectedHours2;

	return stream;
}

//240
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.selectedDays1<<tc.selectedHours1<<tc.selectedDays2<<tc.selectedHours2;

	return stream;
}

//241
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.selectedDays1<<tc.selectedHours1<<tc.selectedDays2<<tc.selectedHours2;

	return stream;
}

//242
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.day1<<tc.hour1<<tc.day2<<tc.hour2;

	return stream;
}

//243
QDataStream& operator<<(QDataStream& stream, const ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.teacherName<<tc.maxOccupiedSets<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//244
QDataStream& operator<<(QDataStream& stream, const ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxOccupiedSets<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//245
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.students<<tc.maxOccupiedSets<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//246
QDataStream& operator<<(QDataStream& stream, const ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.maxOccupiedSets<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//247
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesOverlapCompletelyOrDoNotOverlap& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds;

	return stream;
}

//248
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.maxOccupiedSets<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//249
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityBeginsOrEndsStudentsDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId;

	return stream;
}

//250
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesBeginOrEndStudentsDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName;

	return stream;
}

//251
QDataStream& operator<<(QDataStream& stream, const ConstraintActivityBeginsOrEndsTeachersDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityId;

	return stream;
}

//252
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesBeginOrEndTeachersDay& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activityTagName<<tc.studentsName<<tc.subjectName<<tc.teacherName;

	return stream;
}

//253
QDataStream& operator<<(QDataStream& stream, const ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots& tc)
{
	//stream<<tc.type;
	stream<<tc.weightPercentage;
	stream<<tc.active;
	stream<<tc.comments;

	stream<<tc.activitiesIds<<tc.maxNumberOfStudents<<tc.selectedDays<<tc.selectedHours;

	return stream;
}

//1
QDataStream& operator>>(QDataStream& stream, ConstraintBasicCompulsoryTime& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	return stream;
}

//2
QDataStream& operator>>(QDataStream& stream, ConstraintBreakTimes& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.days>>tc.hours;

	return stream;
}

//3
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherNotAvailableTimes& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.days>>tc.hours>>tc.teacher;

	return stream;
}

//4
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily;

	return stream;
}

//5
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.teacherName;

	return stream;
}

//6
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxGapsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//7
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxGapsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.teacherName;

	return stream;
}

//8
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.teacherName;

	return stream;
}

//9
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursContinuously;

	return stream;
}

//10
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursContinuously>>tc.teacherName;

	return stream;
}

//11
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyDays>>tc.minHoursDaily;

	return stream;
}

//12
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyDays>>tc.minHoursDaily>>tc.teacherName;

	return stream;
}

//13
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxGapsPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//14
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxGapsPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.teacherName;

	return stream;
}

//15
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour;

	return stream;
}

//16
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour>>tc.students;

	return stream;
}

//17
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetNotAvailableTimes& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.days>>tc.hours>>tc.students;

	return stream;
}

//18
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxGapsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//19
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxGapsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.students;

	return stream;
}

//20
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily;

	return stream;
}

//21
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.students;

	return stream;
}

//22
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursContinuously;

	return stream;
}

//23
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursContinuously>>tc.students;

	return stream;
}

//24
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyDays>>tc.minHoursDaily;

	return stream;
}

//25
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyDays>>tc.minHoursDaily>>tc.students;

	return stream;
}

//26
QDataStream& operator>>(QDataStream& stream, ConstraintActivityEndsStudentsDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId;

	return stream;
}

//27
QDataStream& operator>>(QDataStream& stream, ConstraintActivityPreferredStartingTime& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId>>tc.day>>tc.hour>>tc.permanentlyLocked;

	return stream;
}

//28
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesSameStartingTime& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities;

	return stream;
}

//29
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesNotOverlapping& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities;

	return stream;
}

//30
QDataStream& operator>>(QDataStream& stream, ConstraintMinDaysBetweenActivities& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.consecutiveIfSameDay>>tc.minDays;

	return stream;
}

//31
QDataStream& operator>>(QDataStream& stream, ConstraintActivityPreferredTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.p_activityId>>tc.p_days_L>>tc.p_hours_L>>tc.p_nPreferredTimeSlots_L;

	return stream;
}

//32
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesPreferredTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.duration>>tc.p_days_L>>tc.p_hours_L>>tc.p_nPreferredTimeSlots_L
		 >>tc.p_activityTagName>>tc.p_studentsName>>tc.p_subjectName>>tc.p_teacherName;

	return stream;
}

//33
QDataStream& operator>>(QDataStream& stream, ConstraintActivityPreferredStartingTimes& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId>>tc.days_L>>tc.hours_L>>tc.nPreferredStartingTimes_L;

	return stream;
}

//34
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesPreferredStartingTimes& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.duration>>tc.days_L>>tc.hours_L>>tc.nPreferredStartingTimes_L
		 >>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName;

	return stream;
}

//35
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesSameStartingHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities;

	return stream;
}

//36
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesSameStartingDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities;

	return stream;
}

//37
QDataStream& operator>>(QDataStream& stream, ConstraintTwoActivitiesConsecutive& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityId>>tc.secondActivityId;

	return stream;
}

//38
QDataStream& operator>>(QDataStream& stream, ConstraintTwoActivitiesOrdered& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityId>>tc.secondActivityId;

	return stream;
}

//39
QDataStream& operator>>(QDataStream& stream, ConstraintMinGapsBetweenActivities& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.minGaps;

	return stream;
}

//40
QDataStream& operator>>(QDataStream& stream, ConstraintSubactivitiesPreferredTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.duration>>tc.p_days_L>>tc.p_hours_L>>tc.p_nPreferredTimeSlots_L
		 >>tc.p_activityTagName>>tc.p_studentsName>>tc.p_subjectName>>tc.p_teacherName>>tc.componentNumber;

	return stream;
}

//41
QDataStream& operator>>(QDataStream& stream, ConstraintSubactivitiesPreferredStartingTimes& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.duration>>tc.days_L>>tc.hours_L>>tc.nPreferredStartingTimes_L
		 >>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName>>tc.componentNumber;

	return stream;
}

//42
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.startHour>>tc.endHour>>tc.maxDaysPerWeek>>tc.teacherName;

	return stream;
}

//43
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.startHour>>tc.endHour>>tc.maxDaysPerWeek;

	return stream;
}

//44
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.startHour>>tc.endHour>>tc.maxDaysPerWeek>>tc.students;

	return stream;
}

//45
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.startHour>>tc.endHour>>tc.maxDaysPerWeek;

	return stream;
}

//46
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesEndStudentsDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName;

	return stream;
}

//47
QDataStream& operator>>(QDataStream& stream, ConstraintTwoActivitiesGrouped& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityId>>tc.secondActivityId;

	return stream;
}

//48
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersActivityTagMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursContinuously;

	return stream;
}

//49
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherActivityTagMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursContinuously>>tc.teacherName;

	return stream;
}

//50
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsActivityTagMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursContinuously;

	return stream;
}

//51
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetActivityTagMaxHoursContinuously& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursContinuously>>tc.students;

	return stream;
}

//52
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek;

	return stream;
}

//53
QDataStream& operator>>(QDataStream& stream, ConstraintThreeActivitiesGrouped& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityId>>tc.secondActivityId>>tc.thirdActivityId;

	return stream;
}

//54
QDataStream& operator>>(QDataStream& stream, ConstraintMaxDaysBetweenActivities& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.maxDays;

	return stream;
}

//55
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minDaysPerWeek;

	return stream;
}

//56
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minDaysPerWeek>>tc.teacherName;

	return stream;
}

//57
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersActivityTagMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily;

	return stream;
}

//58
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherActivityTagMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily>>tc.teacherName;

	return stream;
}

//59
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsActivityTagMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily;

	return stream;
}

//60
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetActivityTagMaxHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily>>tc.students;

	return stream;
}

//61
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxGapsPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//62
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxGapsPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.students;

	return stream;
}

//63
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesOccupyMaxTimeSlotsFromSelection& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.maxOccupiedTimeSlots>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//64
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.maxSimultaneous>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//65
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.students;

	return stream;
}

//66
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek;

	return stream;
}

//67
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxSpanPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowOneDayExceptionPlusOne>>tc.maxSpanPerDay>>tc.teacherName;

	return stream;
}

//68
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxSpanPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowOneDayExceptionPlusOne>>tc.maxSpanPerDay;

	return stream;
}

//69
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinRestingHours& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.circular>>tc.minRestingHours>>tc.teacherName;

	return stream;
}

//70
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinRestingHours& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.circular>>tc.minRestingHours;

	return stream;
}

//71
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxSpanPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxSpanPerDay>>tc.students;

	return stream;
}

//72
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxSpanPerDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxSpanPerDay;

	return stream;
}

//73
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinRestingHours& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.circular>>tc.minRestingHours>>tc.students;

	return stream;
}

//74
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinRestingHours& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.circular>>tc.minRestingHours;

	return stream;
}

//75
QDataStream& operator>>(QDataStream& stream, ConstraintTwoActivitiesOrderedIfSameDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityId>>tc.secondActivityId;

	return stream;
}

//76
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps>>tc.students;

	return stream;
}

//77
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps;

	return stream;
}

//78
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps>>tc.teacher;

	return stream;
}

//79
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps;

	return stream;
}

//80
QDataStream& operator>>(QDataStream& stream, ConstraintActivityTagsNotOverlapping& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagsNames;

	return stream;
}

//81
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesOccupyMinTimeSlotsFromSelection& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.minOccupiedTimeSlots>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//82
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesMinSimultaneousInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.allowEmptySlots>>tc.minSimultaneous>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//83
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersActivityTagMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.minHoursDaily>>tc.minDaysWithTag;

	return stream;
}

//84
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherActivityTagMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.minHoursDaily>>tc.minDaysWithTag>>tc.teacherName;

	return stream;
}

//85
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsActivityTagMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.minHoursDaily>>tc.minDaysWithTag;

	return stream;
}

//86
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetActivityTagMinHoursDaily& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.minHoursDaily>>tc.minDaysWithTag>>tc.students;

	return stream;
}

//87
QDataStream& operator>>(QDataStream& stream, ConstraintActivityEndsTeachersDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId;

	return stream;
}

//88
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesEndTeachersDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName;

	return stream;
}

//89
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily;

	return stream;
}

//90
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxRealDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.teacherName;

	return stream;
}

//91
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.teacherName;

	return stream;
}

//92
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily;

	return stream;
}

//93
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.students;

	return stream;
}

//94
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxRealDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek;

	return stream;
}

//95
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinRealDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minDaysPerWeek;

	return stream;
}

//96
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinRealDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minDaysPerWeek>>tc.teacherName;

	return stream;
}

//97
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersActivityTagMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily;

	return stream;
}

//98
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherActivityTagMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily>>tc.teacherName;

	return stream;
}

//99
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsActivityTagMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily;

	return stream;
}

//100
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetActivityTagMaxHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.maxHoursDaily>>tc.students;

	return stream;
}

//101
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxAfternoonsPerWeek>>tc.teacherName;

	return stream;
}

//102
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxAfternoonsPerWeek;

	return stream;
}

//103
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxMorningsPerWeek>>tc.teacherName;

	return stream;
}

//104
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxMorningsPerWeek;

	return stream;
}

//105
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxActivityTagsPerDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName>>tc.maxTags>>tc.tagsList;

	return stream;
}

//106
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxActivityTagsPerDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;
	
	stream>>tc.maxTags>>tc.tagsList;

	return stream;
}

//107
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minMorningsPerWeek;

	return stream;
}

//108
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minMorningsPerWeek>>tc.teacherName;

	return stream;
}

//109
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minAfternoonsPerWeek;

	return stream;
}

//110
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minAfternoonsPerWeek>>tc.teacherName;

	return stream;
}

//111
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxTwoConsecutiveMornings& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName;

	return stream;
}

//112
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxTwoConsecutiveMornings& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	return stream;
}

//113
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxTwoConsecutiveAfternoons& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName;

	return stream;
}

//114
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxTwoConsecutiveAfternoons& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	return stream;
}

//115
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxGapsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowOneDayExceptionPlusOne>>tc.maxGaps;

	return stream;
}

//116
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxGapsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowOneDayExceptionPlusOne>>tc.maxGaps>>tc.teacherName;

	return stream;
}

//117
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxGapsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//118
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxGapsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.students;

	return stream;
}

//119
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyDays>>tc.minHoursDaily;

	return stream;
}

//120
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinHoursDailyRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyDays>>tc.minHoursDaily>>tc.teacherName;

	return stream;
}

//121
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour;

	return stream;
}

//122
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour>>tc.teacherName;

	return stream;
}

//123
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinHoursPerMorning& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyMornings>>tc.minHoursPerMorning;

	return stream;
}

//124
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinHoursPerMorning& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyMornings>>tc.minHoursPerMorning>>tc.teacherName;

	return stream;
}

//125
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxSpanPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowOneDayExceptionPlusOne>>tc.maxSpanPerDay>>tc.teacherName;

	return stream;
}

//126
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxSpanPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowOneDayExceptionPlusOne>>tc.maxSpanPerDay;

	return stream;
}

//127
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxSpanPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxSpanPerDay>>tc.students;

	return stream;
}

//128
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxSpanPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxSpanPerDay;

	return stream;
}

//129
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMorningIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour>>tc.teacherName;

	return stream;
}

//130
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMorningIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour;

	return stream;
}

//131
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour>>tc.teacherName;

	return stream;
}

//132
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour;

	return stream;
}

//133
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinHoursPerMorning& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyMornings>>tc.minHoursPerMorning;

	return stream;
}

//134
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinHoursPerMorning& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyMornings>>tc.minHoursPerMorning>>tc.students;

	return stream;
}

//135
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxZeroGapsPerAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName;

	return stream;
}

//136
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxZeroGapsPerAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	return stream;
}

//137
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxAfternoonsPerWeek>>tc.students;

	return stream;
}

//138
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxAfternoonsPerWeek;

	return stream;
}

//139
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxMorningsPerWeek>>tc.students;

	return stream;
}

//140
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxMorningsPerWeek;

	return stream;
}

//141
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minMorningsPerWeek;

	return stream;
}

//142
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinMorningsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minMorningsPerWeek>>tc.students;

	return stream;
}

//143
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minAfternoonsPerWeek;

	return stream;
}

//144
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinAfternoonsPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minAfternoonsPerWeek>>tc.students;

	return stream;
}

//145
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMorningIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour>>tc.students;

	return stream;
}

//146
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMorningIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour;

	return stream;
}

//147
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour>>tc.students;

	return stream;
}

//148
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsAfternoonIntervalMaxDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.startHour>>tc.endHour;

	return stream;
}

//149
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxHoursPerAllAfternoons& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursPerAllAfternoons>>tc.teacherName;

	return stream;
}

//150
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxHoursPerAllAfternoons& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursPerAllAfternoons;

	return stream;
}

//151
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxHoursPerAllAfternoons& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursPerAllAfternoons>>tc.students;

	return stream;
}

//152
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxHoursPerAllAfternoons& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursPerAllAfternoons;

	return stream;
}

//153
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minRestingHours>>tc.teacherName;

	return stream;
}

//154
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minRestingHours;

	return stream;
}

//155
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minRestingHours>>tc.students;

	return stream;
}

//156
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.minRestingHours;

	return stream;
}

//157
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour>>tc.students;

	return stream;
}

//158
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour;

	return stream;
}

//159
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxGapsPerWeekForRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//160
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxGapsPerWeekForRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.teacherName;

	return stream;
}

//161
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxGapsPerWeekForRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//162
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxGapsPerWeekForRealDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.students;

	return stream;
}

//163
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxRealDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek>>tc.students;

	return stream;
}

//164
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxRealDaysPerWeek& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxDaysPerWeek;

	return stream;
}

//165
QDataStream& operator>>(QDataStream& stream, ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.maxActivities>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//166
QDataStream& operator>>(QDataStream& stream, ConstraintMaxGapsBetweenActivities& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.maxGaps;

	return stream;
}

//167
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesMaxInATerm& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.maxActivitiesInATerm;

	return stream;
}

//168
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesOccupyMaxTerms& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.maxOccupiedTerms;

	return stream;
}

//169
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxGapsPerMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps;

	return stream;
}

//170
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxGapsPerMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxGaps>>tc.teacherName;

	return stream;
}

//171
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour;

	return stream;
}

//172
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour>>tc.teacherName;

	return stream;
}

//173
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour>>tc.students;

	return stream;
}

//174
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxBeginningsAtSecondHour;

	return stream;
}

//175
QDataStream& operator>>(QDataStream& stream, ConstraintTwoSetsOfActivitiesOrdered& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivitiesIdsList>>tc.secondActivitiesIdsList;

	return stream;
}

//176
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxThreeConsecutiveDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowAMAMException;

	return stream;
}

//177
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxThreeConsecutiveDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowAMAMException>>tc.teacherName;

	return stream;
}

//178
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinGapsBetweenActivityTag& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps>>tc.students;

	return stream;
}

//179
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinGapsBetweenActivityTag& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps;

	return stream;
}

//180
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinGapsBetweenActivityTag& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps>>tc.teacher;

	return stream;
}

//181
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinGapsBetweenActivityTag& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps;

	return stream;
}

//182
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxThreeConsecutiveDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowAMAMException;

	return stream;
}

//183
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxThreeConsecutiveDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowAMAMException>>tc.students;

	return stream;
}

//184
QDataStream& operator>>(QDataStream& stream, ConstraintMinHalfDaysBetweenActivities& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.consecutiveIfSameDay>>tc.minDays;

	return stream;
}

//185
QDataStream& operator>>(QDataStream& stream, ConstraintActivityPreferredDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId>>tc.day;

	return stream;
}

//186
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesMinInATerm& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.minActivitiesInATerm>>tc.allowEmptyTerms;

	return stream;
}

//187
QDataStream& operator>>(QDataStream& stream, ConstraintMaxTermsBetweenActivities& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.maxTerms;

	return stream;
}

//188
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxActivityTagsPerDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.students>>tc.maxTags>>tc.tagsList;

	return stream;
}

//189
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxActivityTagsPerDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;
	
	stream>>tc.maxTags>>tc.tagsList;

	return stream;
}

//190
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName>>tc.maxTags>>tc.tagsList;

	return stream;
}

//191
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;
	
	stream>>tc.maxTags>>tc.tagsList;

	return stream;
}

//192
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.students>>tc.maxTags>>tc.tagsList;

	return stream;
}

//193
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxActivityTagsPerRealDayFromSet& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;
	
	stream>>tc.maxTags>>tc.tagsList;

	return stream;
}

//194
QDataStream& operator>>(QDataStream& stream, ConstraintMaxHalfDaysBetweenActivities& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.maxDays;

	return stream;
}

//195
QDataStream& operator>>(QDataStream& stream, ConstraintActivityBeginsStudentsDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId;

	return stream;
}

//196
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesBeginStudentsDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName;

	return stream;
}

//197
QDataStream& operator>>(QDataStream& stream, ConstraintActivityBeginsTeachersDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId;

	return stream;
}

//198
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesBeginTeachersDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName;

	return stream;
}

//199
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinHoursPerAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyAfternoons>>tc.minHoursPerAfternoon;

	return stream;
}

//200
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinHoursPerAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyAfternoons>>tc.minHoursPerAfternoon>>tc.teacherName;

	return stream;
}

//201
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinHoursPerAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyAfternoons>>tc.minHoursPerAfternoon;

	return stream;
}

//202
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinHoursPerAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.allowEmptyAfternoons>>tc.minHoursPerAfternoon>>tc.students;

	return stream;
}

//203
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesMaxHourlySpan& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.n_activities>>tc.maxHourlySpan;

	return stream;
}

//204
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxHoursDailyInInterval& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.teacherName>>tc.startHour>>tc.endHour;

	return stream;
}

//205
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxHoursDailyInInterval& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.startHour>>tc.endHour;

	return stream;
}

//206
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxHoursDailyInInterval& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.students>>tc.startHour>>tc.endHour;

	return stream;
}

//207
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxHoursDailyInInterval& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursDaily>>tc.startHour>>tc.endHour;

	return stream;
}

//208
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps>>tc.students;

	return stream;
}

//209
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps;

	return stream;
}

//210
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps>>tc.teacher;

	return stream;
}

//211
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps;

	return stream;
}

//212
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps>>tc.students;

	return stream;
}

//213
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps;

	return stream;
}

//214
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps>>tc.teacher;

	return stream;
}

//215
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinGapsBetweenActivityTagPerRealDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps;

	return stream;
}

//216
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps>>tc.students;

	return stream;
}

//217
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps;

	return stream;
}

//218
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps>>tc.teacher;

	return stream;
}

//219
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.firstActivityTag>>tc.secondActivityTag>>tc.minGaps;

	return stream;
}

//220
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps>>tc.students;

	return stream;
}

//221
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps;

	return stream;
}

//222
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps>>tc.teacher;

	return stream;
}

//223
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTag>>tc.minGaps;

	return stream;
}

//224
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersNoTwoConsecutiveDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	return stream;
}

//225
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherNoTwoConsecutiveDays& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName;

	return stream;
}

//226
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName>>tc.day1>>tc.hour1>>tc.day2>>tc.hour2;

	return stream;
}

//227
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.day1>>tc.hour1>>tc.day2>>tc.hour2;

	return stream;
}

//228
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.students>>tc.day1>>tc.hour1>>tc.day2>>tc.hour2;

	return stream;
}

//229
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.day1>>tc.hour1>>tc.day2>>tc.hour2;

	return stream;
}

//230
QDataStream& operator>>(QDataStream& stream, ConstraintTwoSetsOfActivitiesSameSections& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesAIds>>tc.activitiesBIds>>tc.oDays>>tc.oHours;

	return stream;
}

//231
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxSingleGaps>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//232
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.students>>tc.maxSingleGaps>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//233
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxSingleGaps>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//234
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxSingleGapsInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacher>>tc.maxSingleGaps>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//235
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherMaxHoursPerTerm& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursPerTerm>>tc.teacherName;

	return stream;
}

//236
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersMaxHoursPerTerm& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxHoursPerTerm;

	return stream;
}

//237
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName>>tc.selectedDays1>>tc.selectedHours1>>tc.selectedDays2>>tc.selectedHours2;

	return stream;
}

//238
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.selectedDays1>>tc.selectedHours1>>tc.selectedDays2>>tc.selectedHours2;

	return stream;
}

//239
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.students>>tc.selectedDays1>>tc.selectedHours1>>tc.selectedDays2>>tc.selectedHours2;

	return stream;
}

//240
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.selectedDays1>>tc.selectedHours1>>tc.selectedDays2>>tc.selectedHours2;

	return stream;
}

//241
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.selectedDays1>>tc.selectedHours1>>tc.selectedDays2>>tc.selectedHours2;

	return stream;
}

//242
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.day1>>tc.hour1>>tc.day2>>tc.hour2;

	return stream;
}

//243
QDataStream& operator>>(QDataStream& stream, ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.teacherName>>tc.maxOccupiedSets>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//244
QDataStream& operator>>(QDataStream& stream, ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxOccupiedSets>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//245
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.students>>tc.maxOccupiedSets>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//246
QDataStream& operator>>(QDataStream& stream, ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.maxOccupiedSets>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//247
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesOverlapCompletelyOrDoNotOverlap& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds;

	return stream;
}

//248
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.maxOccupiedSets>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

//249
QDataStream& operator>>(QDataStream& stream, ConstraintActivityBeginsOrEndsStudentsDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId;

	return stream;
}

//250
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesBeginOrEndStudentsDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName;

	return stream;
}

//251
QDataStream& operator>>(QDataStream& stream, ConstraintActivityBeginsOrEndsTeachersDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityId;

	return stream;
}

//252
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesBeginOrEndTeachersDay& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activityTagName>>tc.studentsName>>tc.subjectName>>tc.teacherName;

	return stream;
}

//253
QDataStream& operator>>(QDataStream& stream, ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots& tc)
{
	//stream>>tc.type;
	stream>>tc.weightPercentage;
	stream>>tc.active;
	stream>>tc.comments;

	stream>>tc.activitiesIds>>tc.maxNumberOfStudents>>tc.selectedDays>>tc.selectedHours;

	return stream;
}

static QString trueFalse(bool x){
	if(!x)
		return QString("false");
	else
		return QString("true");
}

static QString yesNoTranslated(bool x){
	if(!x)
		return QCoreApplication::translate("TimeConstraint", "no", "negative");
	else
		return QCoreApplication::translate("TimeConstraint", "yes", "affirmative");
}

//The following 2 matrices are kept to make the computation faster
//They are calculated only at the beginning of the computation of the fitness
//of the solution.
static Matrix3D<int> subgroupsMatrix;
static Matrix3D<int> teachersMatrix;

static int teachers_conflicts=-1;
static int subgroups_conflicts=-1;

extern Matrix2D<bool> breakDayHour;

extern Matrix3D<bool> teacherNotAvailableDayHour;

extern Matrix3D<bool> subgroupNotAvailableDayHour;

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

QString getActivityDescription(Rules& r, int id)
{
	QString s="";
	
	Activity* act=r.activitiesPointerHash.value(id, nullptr);
	if(act==nullptr){
		s+=translatedQuestionMark();
	}
	else{
		if(!act->active)
			s+="X-";
		s+=QString::number(id);
	}
	
	return s;
}

QString getActivityDetailedDescription(Rules& r, int id)
{
	QString s="";
	
	Activity* act=r.activitiesPointerHash.value(id, nullptr);
	if(act==nullptr){
		s+=QCoreApplication::translate("Activity", "Invalid (nonexistent) id for activity");
		return s;
	}

	/*if(act->activityTagsNames.count()>0){
		s+=QCoreApplication::translate("Activity", "T:%1, S:%2, AT:%3, St:%4", "This is an important translation for an activity's detailed description, please take care (it appears in many places in constraints)."
		 "The abbreviations are: Teachers, Subject, Activity tags, Students. This variant includes activity tags").arg(act->teachersNames.join(translatedComma())).arg(act->subjectName).arg(act->activityTagsNames.join(translatedComma())).arg(act->studentsNames.join(translatedComma()));
	}
	else{
		s+=QCoreApplication::translate("Activity", "T:%1, S:%2, St:%3", "This is an important translation for an activity's detailed description, please take care (it appears in many places in constraints)."
		 "The abbreviations are: Teachers, Subject, Students. There are no activity tags here").arg(act->teachersNames.join(translatedComma())).arg(act->subjectName).arg(act->studentsNames.join(translatedComma()));
	}
	return s;*/

	const int INDENT=4;

	bool _indent;
	if(act->isSplit() && act->id!=act->activityGroupId)
		_indent=true;
	else
		_indent=false;
		
	bool indentRepr;
	if(act->isSplit() && act->id==act->activityGroupId)
		indentRepr=true;
	else
		indentRepr=false;
		
	QString _teachers="";
	if(act->teachersNames.count()==0)
		_teachers=QCoreApplication::translate("Activity", "no teachers");
	else
		_teachers=act->teachersNames.join(translatedComma());

	QString _subject=act->subjectName;
	
	QString _activityTags=act->activityTagsNames.join(translatedComma());

	QString _students="";
	if(act->studentsNames.count()==0)
		_students=QCoreApplication::translate("Activity", "no students");
	else
		_students=act->studentsNames.join(translatedComma());

	/*QString _id;
	_id = CustomFETString::number(id);

	QString _agid="";
	if(act->isSplit())
		_agid = CustomFETString::number(act->activityGroupId);*/

	QString _duration=CustomFETString::number(act->duration);
	
	QString _totalDuration="";
	if(act->isSplit())
		_totalDuration = CustomFETString::number(act->totalDuration);

	QString _active;
	if(act->active==true)
		_active="";
	else
		_active="X";

	QString _nstudents="";
	if(act->computeNTotalStudents==false)
		_nstudents=CustomFETString::number(act->nTotalStudents);

	/////////
	//QString s="";
	if(_indent)
		s+=QString(INDENT, ' ');
		
	/*s+=_id;
	s+=" - ";*/

	if(_active!=""){
		s+=_active;
		s+=" - ";
	}
	
	s+=_duration;
	if(act->isSplit()){
		s+="/";
		s+=_totalDuration;
	}
	s+=" - ";
	
	if(indentRepr)
		s+=QString(INDENT, ' ');
	
	s+=_teachers;
	s+=" - ";
	s+=_subject;
	s+=" - ";
	if(_activityTags!=""){
		s+=_activityTags;
		s+=" - ";
	}
	s+=_students;

	if(_nstudents!=""){
		s+=" - ";
		s+=_nstudents;
	}
	
	if(!act->comments.isEmpty()){
		s+=" - ";
		s+=act->comments;
	}

	return s;
}

bool timeConstraintCanHaveAnyWeight(int type)
{
	assert(type!=CONSTRAINT_GENERIC_TIME);
	
	bool t;
	
	switch(type){
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_MIN_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_HOUR:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_CONSECUTIVE:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_MIN_GAPS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_THREE_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_MAX_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED_IF_SAME_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_TAGS_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_MAX_GAPS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_TWO_SETS_OF_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_MIN_HALF_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_MAX_TERMS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_MAX_HALF_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_HOURLY_SPAN:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_TEACHERS_DAY:
			t=true;
			break;
		
		default:
			t=false;
			break;
	}

	return t;
}

void populateInternalSubgroupsList(const Rules& r, const StudentsSet* ss, QList<int>& iSubgroupsList){
	iSubgroupsList.clear();
	
	QSet<int> tmpSet;
	
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!tmpSet.contains(tmp)){
			tmpSet.insert(tmp);
			iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!tmpSet.contains(tmp)){
				tmpSet.insert(tmp);
				iSubgroupsList.append(tmp);
			}
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!tmpSet.contains(tmp)){
					tmpSet.insert(tmp);
					iSubgroupsList.append(tmp);
				}
			}
		}
	}
	else
		assert(0);
}

TimeConstraint::TimeConstraint()
{
	type=CONSTRAINT_GENERIC_TIME;
	
	active=true;
	comments=QString("");
}

TimeConstraint::~TimeConstraint()
{
}

TimeConstraint::TimeConstraint(double wp)
{
	type=CONSTRAINT_GENERIC_TIME;

	weightPercentage=wp;
	assert(wp<=100 && wp>=0);

	active=true;
	comments=QString("");
}

bool TimeConstraint::canHaveAnyWeight()
{
	return timeConstraintCanHaveAnyWeight(type);
}

bool TimeConstraint::canBeUsedInOfficialMode()
{
	assert(type!=CONSTRAINT_GENERIC_TIME);
	
	bool t;
	
	switch(type){
		case CONSTRAINT_BASIC_COMPULSORY_TIME:
			[[fallthrough]];
		case CONSTRAINT_BREAK_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_MIN_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_HOUR:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_CONSECUTIVE:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_MIN_GAPS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_THREE_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_MAX_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		//2017-02-06
		case CONSTRAINT_TEACHER_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_RESTING_HOURS:
			[[fallthrough]];
		//2018-06-13
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED_IF_SAME_DAY:
			[[fallthrough]];
		//2019-06-08
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		//2021-12-15
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_TAGS_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MIN_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MIN_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_SETS_OF_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_HOURLY_SPAN:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OVERLAP_COMPLETELY_OR_DO_NOT_OVERLAP:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_TOTAL_NUMBER_OF_STUDENTS_IN_SELECTED_TIME_SLOTS:
			t=true;
			break;
			
		default:
			t=false;
			break;
	}

	return t;
}

bool TimeConstraint::canBeUsedInMorningsAfternoonsMode()
{
	assert(type!=CONSTRAINT_GENERIC_TIME);
	
	bool t;
	
	switch(type){
		case CONSTRAINT_BASIC_COMPULSORY_TIME:
			[[fallthrough]];
		case CONSTRAINT_BREAK_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_MIN_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_HOUR:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_CONSECUTIVE:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_MIN_GAPS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_THREE_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_MAX_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		//2017-02-06
		case CONSTRAINT_TEACHER_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		//2018-06-13
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED_IF_SAME_DAY:
			[[fallthrough]];
		//2019-06-08
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		//2021-12-15
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_TAGS_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MIN_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MIN_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_TEACHERS_DAY:
			[[fallthrough]];
		//mornings-afternoons
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_REAL_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_REAL_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_REAL_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_REAL_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_TWO_CONSECUTIVE_MORNINGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_TWO_CONSECUTIVE_MORNINGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_TWO_CONSECUTIVE_AFTERNOONS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_TWO_CONSECUTIVE_AFTERNOONS:
			[[fallthrough]];
		//Added in FET Algeria and Morocco on 2018-11-02
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_REAL_DAY:
			[[fallthrough]];
		//2019-07-03
		case CONSTRAINT_TEACHERS_MIN_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_HOURS_DAILY_REAL_DAYS:
			[[fallthrough]];
		//2019-08-18 - for Said213
		case CONSTRAINT_TEACHERS_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_HOURS_PER_MORNING:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_HOURS_PER_MORNING:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_SPAN_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SPAN_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SPAN_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MORNING_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MORNING_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_HOURS_PER_MORNING:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_HOURS_PER_MORNING:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_ZERO_GAPS_PER_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_ZERO_GAPS_PER_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_MORNINGS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_AFTERNOONS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MORNING_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MORNING_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_PER_ALL_AFTERNOONS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_PER_ALL_AFTERNOONS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_PER_ALL_AFTERNOONS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_PER_ALL_AFTERNOONS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		//2020-07-24 - for lakhdar bezzit
		case CONSTRAINT_STUDENTS_SET_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		//Added in FET Algeria and Morocco on 2020-07-29
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_REAL_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_REAL_DAYS_PER_WEEK:
			[[fallthrough]];
		//2021-08-12
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_TWO_SETS_OF_ACTIVITIES_ORDERED:
			[[fallthrough]];
		//2021-09-26
		case CONSTRAINT_TEACHERS_MAX_THREE_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_THREE_CONSECUTIVE_DAYS:
			[[fallthrough]];
		//2022-02-15
		case CONSTRAINT_STUDENTS_MAX_THREE_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_THREE_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_MIN_HALF_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_MAX_HALF_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_TEACHERS_DAY:
			[[fallthrough]];
 		case CONSTRAINT_TEACHERS_MIN_HOURS_PER_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_HOURS_PER_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_HOURS_PER_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_HOURS_PER_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_HOURLY_SPAN:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		//2024-03-15
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY:
			[[fallthrough]];
		//2024-05-18
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OVERLAP_COMPLETELY_OR_DO_NOT_OVERLAP:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_TOTAL_NUMBER_OF_STUDENTS_IN_SELECTED_TIME_SLOTS:
			t=true;
			break;
		
		default:
			t=false;
			break;
	}

	return t;
}

bool TimeConstraint::canBeUsedInBlockPlanningMode()
{
	assert(type!=CONSTRAINT_GENERIC_TIME);
	
	bool t;
	
	switch(type){
		case CONSTRAINT_BASIC_COMPULSORY_TIME:
			[[fallthrough]];
		case CONSTRAINT_BREAK_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_MIN_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_HOUR:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_CONSECUTIVE:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_MIN_GAPS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_THREE_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_MAX_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		//2017-02-06
		case CONSTRAINT_TEACHER_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_RESTING_HOURS:
			[[fallthrough]];
		//2018-06-13
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED_IF_SAME_DAY:
			[[fallthrough]];
		//2019-06-08
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		//2021-12-15
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_TAGS_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MIN_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MIN_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_TEACHERS_DAY:
			[[fallthrough]];
		//block-planning
		case CONSTRAINT_MAX_TOTAL_ACTIVITIES_FROM_SET_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_MAX_GAPS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_TWO_SETS_OF_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_HOURLY_SPAN:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TWO_SETS_OF_ACTIVITIES_SAME_SECTIONS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OVERLAP_COMPLETELY_OR_DO_NOT_OVERLAP:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_TOTAL_NUMBER_OF_STUDENTS_IN_SELECTED_TIME_SLOTS:
			t=true;
			break;
		
		default:
			t=false;
			break;
	}

	return t;
}

bool TimeConstraint::canBeUsedInTermsMode()
{
	assert(type!=CONSTRAINT_GENERIC_TIME);
	
	bool t;
	
	switch(type){
		case CONSTRAINT_BASIC_COMPULSORY_TIME:
			[[fallthrough]];
		case CONSTRAINT_BREAK_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_NOT_AVAILABLE_TIMES:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_TIME:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_MIN_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_HOUR:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_SAME_STARTING_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_CONSECUTIVE:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_MIN_GAPS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_SUBACTIVITIES_PREFERRED_STARTING_TIMES:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_INTERVAL_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_TWO_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_THREE_ACTIVITIES_GROUPED:
			[[fallthrough]];
		case CONSTRAINT_MAX_DAYS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_DAYS_PER_WEEK:
			[[fallthrough]];
		//2017-02-06
		case CONSTRAINT_TEACHER_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SPAN_PER_DAY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_RESTING_HOURS:
			[[fallthrough]];
		//2018-06-13
		case CONSTRAINT_TWO_ACTIVITIES_ORDERED_IF_SAME_DAY:
			[[fallthrough]];
		//2019-06-08
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS:
			[[fallthrough]];
		//2021-12-15
		case CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_TAGS_NOT_OVERLAPPING:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MIN_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MIN_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MIN_HOURS_DAILY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_END_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_IN_A_TERM:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TERMS:
			[[fallthrough]];
		case CONSTRAINT_TWO_SETS_OF_ACTIVITIES_ORDERED:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_PREFERRED_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MIN_IN_A_TERM:
			[[fallthrough]];
		case CONSTRAINT_MAX_TERMS_BETWEEN_ACTIVITIES:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_HOURLY_SPAN:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_IN_INTERVAL:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_NO_TWO_CONSECUTIVE_DAYS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_MAX_HOURS_PER_TERM:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_MAX_HOURS_PER_TERM:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS:
			[[fallthrough]];
		case CONSTRAINT_TEACHER_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_TEACHERS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_SET_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_STUDENTS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OVERLAP_COMPLETELY_OR_DO_NOT_OVERLAP:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_STUDENTS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_BEGIN_OR_END_TEACHERS_DAY:
			[[fallthrough]];
		case CONSTRAINT_ACTIVITIES_MAX_TOTAL_NUMBER_OF_STUDENTS_IN_SELECTED_TIME_SLOTS:
			t=true;
			break;
		
		default:
			t=false;
			break;
	}

	return t;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

ConstraintBasicCompulsoryTime::ConstraintBasicCompulsoryTime(): TimeConstraint()
{
	this->type=CONSTRAINT_BASIC_COMPULSORY_TIME;
	this->weightPercentage=100;
}

ConstraintBasicCompulsoryTime::ConstraintBasicCompulsoryTime(double wp): TimeConstraint(wp)
{
	this->type=CONSTRAINT_BASIC_COMPULSORY_TIME;
}

bool ConstraintBasicCompulsoryTime::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintBasicCompulsoryTime::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintBasicCompulsoryTime::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s = IL2+"<ConstraintBasicCompulsoryTime>\n";
	assert(this->weightPercentage==100.0);
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintBasicCompulsoryTime>\n";
	return s;
}

QString ConstraintBasicCompulsoryTime::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	return begin+tr("Basic compulsory constraints (time)") + translatedCommaSpace() + tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage))+end;
}

QString ConstraintBasicCompulsoryTime::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("These are the basic compulsory constraints (referring to time allocation) for any timetable");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("The basic time constraints try to avoid:");s+="\n";
	s+=QString("- ");s+=tr("teachers assigned to more than one activity simultaneously");s+="\n";
	s+=QString("- ");s+=tr("students assigned to more than one activity simultaneously");s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintBasicCompulsoryTime::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString){
	assert(r.internalStructureComputed);

	int teachersConflicts, subgroupsConflicts;
	
	assert(weightPercentage==100.0);

	//This constraint fitness calculation routine is called firstly,
	//so we can compute the teacher and subgroups conflicts faster this way.
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
	
		subgroups_conflicts = subgroupsConflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = teachersConflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	else{
		assert(subgroups_conflicts>=0);
		assert(teachers_conflicts>=0);
		subgroupsConflicts = subgroups_conflicts;
		teachersConflicts = teachers_conflicts;
	}

	int i,dd;

	qint64 unallocated; //unallocated activities
	int late; //late activities
	int nte; //number of teacher exhaustions
	int nse; //number of students exhaustions
	int ntma;

	//Part without logging..................................................................
	if(conflictsString==nullptr){
		//Unallocated or late activities
		unallocated=0;
		late=0;
		for(i=0; i<r.nInternalActivities; i++){
			if(c.times[i]==UNALLOCATED_TIME){
				//Firstly, we consider a big clash each unallocated activity.
				//Needs to be very a large constant, bigger than any other broken constraint.
				//Take care: MAX_ACTIVITIES*this_constant <= INT_MAX
				unallocated += /*r.internalActivitiesList[i].duration * r.internalActivitiesList[i].nSubgroups * */ 10000;
				//(an unallocated activity for a year is more important than an unallocated activity for a subgroup)
			}
			else{
				//Calculates the number of activities that are scheduled too late (in fact we
				//calculate a function that increases as the activity is getting late)
				int h=c.times[i]/r.nDaysPerWeek;
				dd=r.internalActivitiesList[i].duration;
				if(h+dd>r.nHoursPerDay){
					int tmp;
					tmp=1;
					late += (h+dd-r.nHoursPerDay) * tmp * r.internalActivitiesList[i].iSubgroupsList.count();
					//multiplied with the number
					//of subgroups implied, for seeing the importance of the
					//activity
				}
			}
		}
		
		assert(late==0);

		//Below, for teachers and students, please remember that 2 means a weekly activity
		//and 1 fortnightly one. So, if the matrix teachersMatrix[teacher][day][hour]==2, it is ok.

		//Calculates the number of teachers exhaustion (when he has to teach more than
		//one activity at the same time)
		/*nte=0;
		for(i=0; i<r.nInternalTeachers; i++)
			for(int j=0; j<r.nDaysPerWeek; j++)
				for(int k=0; k<r.nHoursPerDay; k++){
					int tmp=teachersMatrix[i][j][k]-2;
					if(tmp>0)
						nte+=tmp;
				}*/
		nte = teachersConflicts; //faster
		
		assert(nte==0);

		//Calculates the number of subgroups exhaustion (a subgroup cannot attend two
		//activities at the same time)
		/*nse=0;
		for(i=0; i<r.nInternalSubgroups; i++)
			for(int j=0; j<r.nDaysPerWeek; j++)
				for(int k=0; k<r.nHoursPerDay; k++){
					int tmp=subgroupsMatrix[i][j][k]-2;
					if(tmp>0)
						nse += tmp;
				}*/
		nse = subgroupsConflicts; //faster
		
		assert(nse==0);

		ntma=0;
		if(r.mode==MORNINGS_AFTERNOONS){
			Matrix1D<bool> tm;
			tm.resize(r.nDaysPerWeek);
			for(int t=0; t<r.nInternalTeachers; t++){
				Teacher* tch=r.internalTeachersList[t];
				for(int d=0; d<r.nDaysPerWeek; d++){
					tm[d]=false;
					for(int h=0; h<r.nHoursPerDay; h++)
						if(teachersMatrix[t][d][h]>0){
							tm[d]=true;
							break;
						}
				}
				int nExceptions=0;
				for(int d=0; d<r.nDaysPerWeek/2; d++)
					if(tm[2*d] && tm[2*d+1])
						nExceptions++;
				//int tmp=0;
				assert(tch->morningsAfternoonsBehavior!=TEACHER_MORNINGS_AFTERNOONS_BEHAVIOR_NOT_INITIALIZED);
				if(tch->morningsAfternoonsBehavior==TEACHER_MORNING_OR_EXCLUSIVELY_AFTERNOON && nExceptions>0){
					//tmp=nExceptions;
					ntma+=nExceptions;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_ONE_DAY_EXCEPTION && nExceptions>1){
					//tmp=nExceptions-1;
					ntma+=nExceptions-1;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_TWO_DAYS_EXCEPTION && nExceptions>2){
					//tmp=nExceptions-2;
					ntma+=nExceptions-2;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_THREE_DAYS_EXCEPTION && nExceptions>3){
					//tmp=nExceptions-3;
					ntma+=nExceptions-3;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_FOUR_DAYS_EXCEPTION && nExceptions>4){
					//tmp=nExceptions-4;
					ntma+=nExceptions-4;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_FIVE_DAYS_EXCEPTION && nExceptions>5){
					//tmp=nExceptions-5;
					ntma+=nExceptions-5;
				}
				else{
					assert(0);
				}
			}
		}
		
		assert(ntma==0);
	}
	//part with logging....................................................................
	else{
		//Unallocated or late activities
		unallocated=0;
		late=0;
		for(i=0; i<r.nInternalActivities; i++){
			if(c.times[i]==UNALLOCATED_TIME){
				//Firstly, we consider a big clash each unallocated activity.
				//Needs to be very a large constant, bigger than any other broken constraint.
				//Take care: MAX_ACTIVITIES*this_constant <= INT_MAX
				unallocated += /*r.internalActivitiesList[i].duration * r.internalActivitiesList[i].nSubgroups * */ 10000;
				//(an unallocated activity for a year is more important than an unallocated activity for a subgroup)
				if(conflictsString!=nullptr){
					QString s= tr("Time constraint basic compulsory broken: unallocated activity with id=%1 (%2)",
						"%2 is the detailed description of activity - teachers, subject, students")
						.arg(r.internalActivitiesList[i].id).arg(getActivityDetailedDescription(r, r.internalActivitiesList[i].id));
					s+=" - ";
					s += tr("this increases the conflicts total by %1")
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100 * 10000));
					//s += "\n";
					
					dl.append(s);
					cl.append(weightPercentage/100 * 10000);

					(*conflictsString) += s + "\n";
				}
			}
			else{
				//Calculates the number of activities that are scheduled too late (in fact we
				//calculate a function that increases as the activity is getting late)
				int h=c.times[i]/r.nDaysPerWeek;
				dd=r.internalActivitiesList[i].duration;
				if(h+dd>r.nHoursPerDay){
					assert(0);
				
					int tmp;
					tmp=1;
					late += (h+dd-r.nHoursPerDay) * tmp * r.internalActivitiesList[i].iSubgroupsList.count();
					//multiplied with the number
					//of subgroups implied, for seeing the importance of the
					//activity

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint basic compulsory");
						s+=": ";
						s+=tr("activity with id=%1 is late.")
						 .arg(r.internalActivitiesList[i].id);
						s+=" ";
						s+=tr("This increases the conflicts total by %1")
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision((h+dd-r.nHoursPerDay)*tmp*r.internalActivitiesList[i].iSubgroupsList.count()*weightPercentage/100));
						s+="\n";
						
						dl.append(s);
						cl.append((h+dd-r.nHoursPerDay)*tmp*r.internalActivitiesList[i].iSubgroupsList.count()*weightPercentage/100);

						(*conflictsString) += s+"\n";
					}
				}
			}
		}

		//Below, for teachers and students, please remember that 2 means a weekly activity
		//and 1 fortnightly one. So, if the matrix teachersMatrix[teacher][day][hour]==2,
		//that is ok.

		//Calculates the number of teachers exhaustion (when he has to teach more than
		//one activity at the same time)
		nte=0;
		for(i=0; i<r.nInternalTeachers; i++)
			for(int j=0; j<r.nDaysPerWeek; j++)
				for(int k=0; k<r.nHoursPerDay; k++){
					int tmp=teachersMatrix[i][j][k]-1;
					if(tmp>0){
						if(conflictsString!=nullptr){
							QString s=tr("Time constraint basic compulsory");
							s+=": ";
							s+=tr("teacher with name %1 has more than one allocated activity on day %2, hour %3")
							 .arg(r.internalTeachersList[i]->name)
							 .arg(r.daysOfTheWeek[j])
							 .arg(r.hoursOfTheDay[k]);
							s+=". ";
							s+=tr("This increases the conflicts total by %1")
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
						
							(*conflictsString)+= s+"\n";
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
						}
						nte+=tmp;
					}
				}

		assert(nte==0);
		
		//Calculates the number of subgroups exhaustion (a subgroup cannot attend two
		//activities at the same time)
		nse=0;
		for(i=0; i<r.nInternalSubgroups; i++)
			for(int j=0; j<r.nDaysPerWeek; j++)
				for(int k=0; k<r.nHoursPerDay; k++){
					int tmp=subgroupsMatrix[i][j][k]-1;
					if(tmp>0){
						if(conflictsString!=nullptr){
							QString s=tr("Time constraint basic compulsory");
							s+=": ";
							s+=tr("subgroup %1 has more than one allocated activity on day %2, hour %3")
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(r.daysOfTheWeek[j])
							 .arg(r.hoursOfTheDay[k]);
							s+=". ";
							s+=tr("This increases the conflicts total by %1")
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision((subgroupsMatrix[i][j][k]-1)*weightPercentage/100));
							
							dl.append(s);
							cl.append((subgroupsMatrix[i][j][k]-1)*weightPercentage/100);
						
							*conflictsString += s+"\n";
						}
						nse += tmp;
					}
				}
		
		assert(nse==0);
		
		ntma=0;
		if(r.mode==MORNINGS_AFTERNOONS){
			Matrix1D<bool> tm;
			tm.resize(r.nDaysPerWeek);
			for(int t=0; t<r.nInternalTeachers; t++){
				Teacher* tch=r.internalTeachersList[t];
				for(int d=0; d<r.nDaysPerWeek; d++){
					tm[d]=false;
					for(int h=0; h<r.nHoursPerDay; h++)
						if(teachersMatrix[t][d][h]>0){
							tm[d]=true;
							break;
						}
				}
				int nExceptions=0;
				for(int d=0; d<r.nDaysPerWeek/2; d++)
					if(tm[2*d] && tm[2*d+1])
						nExceptions++;
				int tmp=0;
				assert(tch->morningsAfternoonsBehavior!=TEACHER_MORNINGS_AFTERNOONS_BEHAVIOR_NOT_INITIALIZED);
				if(tch->morningsAfternoonsBehavior==TEACHER_MORNING_OR_EXCLUSIVELY_AFTERNOON && nExceptions>0){
					tmp=nExceptions;
					ntma+=nExceptions;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_ONE_DAY_EXCEPTION && nExceptions>1){
					tmp=nExceptions-1;
					ntma+=nExceptions-1;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_TWO_DAYS_EXCEPTION && nExceptions>2){
					tmp=nExceptions-2;
					ntma+=nExceptions-2;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_THREE_DAYS_EXCEPTION && nExceptions>3){
					tmp=nExceptions-3;
					ntma+=nExceptions-3;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_FOUR_DAYS_EXCEPTION && nExceptions>4){
					tmp=nExceptions-4;
					ntma+=nExceptions-4;
				}
				else if(tch->morningsAfternoonsBehavior==TEACHER_FIVE_DAYS_EXCEPTION && nExceptions>5){
					tmp=nExceptions-5;
					ntma+=nExceptions-5;
				}
				
				if(tmp>0 && conflictsString!=nullptr){
					QString s=tr("Time constraint basic compulsory");
					s+=": ";
					s+=tr("the teacher with name %1 does not respect mornings-afternoons behavior")
					 .arg(r.internalTeachersList[t]->name);
					s+=". ";
					s+=tr("This increases the conflicts total by %1")
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
				
					(*conflictsString)+= s+"\n";
					
					dl.append(s);
					cl.append(tmp*weightPercentage/100);
				}
			}
		}

		assert(ntma==0);
	}

	/*if(nte!=teachersConflicts){
		cout<<"nte=="<<nte<<", teachersConflicts=="<<teachersConflicts<<endl;
		cout<<c.getTeachersMatrix(r, teachersMatrix)<<endl;
	}
	if(nse!=subgroupsConflicts){
		cout<<"nse=="<<nse<<", subgroupsConflicts=="<<subgroupsConflicts<<endl;
		cout<<c.getSubgroupsMatrix(r, subgroupsMatrix)<<endl;
	}*/
	
	/*assert(nte==teachersConflicts); //just a check, works only on logged fitness calculation
	assert(nse==subgroupsConflicts);*/

	return weightPercentage/100 * (unallocated + qint64(late) + qint64(nte) + qint64(nse) + qint64(ntma)); //conflicts factor
}

bool ConstraintBasicCompulsoryTime::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(a);
	Q_UNUSED(r);

	return false;
}

bool ConstraintBasicCompulsoryTime::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintBasicCompulsoryTime::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintBasicCompulsoryTime::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintBasicCompulsoryTime::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintBasicCompulsoryTime::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintBasicCompulsoryTime::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintBasicCompulsoryTime::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherNotAvailableTimes::ConstraintTeacherNotAvailableTimes()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_NOT_AVAILABLE_TIMES;
}

ConstraintTeacherNotAvailableTimes::ConstraintTeacherNotAvailableTimes(double wp, const QString& tn, const QList<int>& d, const QList<int>& h)
	: TimeConstraint(wp)
{
	this->teacher=tn;
	assert(d.count()==h.count());
	this->days=d;
	this->hours=h;
	this->type=CONSTRAINT_TEACHER_NOT_AVAILABLE_TIMES;
}

QString ConstraintTeacherNotAvailableTimes::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintTeacherNotAvailableTimes>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";

	s+=IL3+"<Number_of_Not_Available_Times>"+QString::number(this->days.count())+"</Number_of_Not_Available_Times>\n";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		s+=IL3+"<Not_Available_Time>\n";
		if(this->days.at(i)>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->days.at(i)])+"</Day>\n";
		if(this->hours.at(i)>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hours.at(i)])+"</Hour>\n";
		s+=IL3+"</Not_Available_Time>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherNotAvailableTimes>\n";
	return s;
}

QString ConstraintTeacherNotAvailableTimes::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teacher not available");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();

	s+=tr("NA at:", "Not available at");
	s+=" ";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		if(this->days.at(i)>=0){
			s+=r.daysOfTheWeek[this->days.at(i)];
			s+=" ";
		}
		if(this->hours.at(i)>=0){
			s+=r.hoursOfTheDay[this->hours.at(i)];
		}
		if(i<days.count()-1)
			s+=translatedSemicolonSpace();
	}

	return begin+s+end;
}

QString ConstraintTeacherNotAvailableTimes::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher is not available");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";

	s+=tr("Not available at:", "It refers to a teacher");
	s+="\n";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		if(this->days.at(i)>=0){
			s+=r.daysOfTheWeek[this->days.at(i)];
			s+=" ";
		}
		if(this->hours.at(i)>=0){
			s+=r.hoursOfTheDay[this->hours.at(i)];
		}
		if(i<days.count()-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeacherNotAvailableTimes::computeInternalStructure(QWidget* parent, Rules& r){
	//this->teacher_ID=r.searchTeacher(this->teacher);
	teacher_ID=r.teachersHash.value(teacher, -1);

	if(this->teacher_ID<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher not available times is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(days.count()==hours.count());
	for(int k=0; k<days.count(); k++){
		if(this->days.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teacher not available times is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours.at(k) >= r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teacher not available times is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}

	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherNotAvailableTimes::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

double ConstraintTeacherNotAvailableTimes::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;

		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	//Calculates the number of hours when the teacher is supposed to be teaching, but he is not available
	//This function consideres all the hours, I mean if there are for example 5 weekly courses
	//scheduled on that hour (which is already a broken compulsory restriction - we only
	//are allowed 1 weekly course for a certain teacher at a certain hour) we calculate
	//5 broken restrictions for that function.
	//TODO: decide if it is better to consider only 2 or 10 as a return value in this particular case
	//(currently it is 10)
	int tch=this->teacher_ID;

	int nbroken;

	nbroken=0;

	assert(days.count()==hours.count());
	for(int k=0; k<days.count(); k++){
		int d=days.at(k);
		int h=hours.at(k);
		
		if(teachersMatrix[tch][d][h]>0){
			nbroken+=teachersMatrix[tch][d][h];
	
			if(conflictsString!=nullptr){
				QString s= tr("Time constraint teacher not available");
				s += " ";
				s += tr("broken for teacher: %1 on day %2, hour %3")
				 .arg(r.internalTeachersList[tch]->name)
				 .arg(r.daysOfTheWeek[d])
				 .arg(r.hoursOfTheDay[h]);
				s += ". ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(teachersMatrix[tch][d][h]*weightPercentage/100));
				
				dl.append(s);
				cl.append(teachersMatrix[tch][d][h]*weightPercentage/100);
			
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherNotAvailableTimes::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	
	return a->teachersNames.contains(this->teacher);
}

bool ConstraintTeacherNotAvailableTimes::isRelatedToTeacher(Teacher* t)
{
	if(this->teacher==t->name)
		return true;
	return false;
}

bool ConstraintTeacherNotAvailableTimes::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherNotAvailableTimes::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherNotAvailableTimes::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherNotAvailableTimes::hasWrongDayOrHour(Rules& r)
{
	assert(days.count()==hours.count());
	
	for(int i=0; i<days.count(); i++)
		if(days.at(i)<0 || days.at(i)>=r.nDaysPerWeek
		 || hours.at(i)<0 || hours.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintTeacherNotAvailableTimes::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherNotAvailableTimes::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(days.count()==hours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<days.count(); i++)
		if(days.at(i)>=0 && days.at(i)<r.nDaysPerWeek
		 && hours.at(i)>=0 && hours.at(i)<r.nHoursPerDay){
			newDays.append(days.at(i));
			newHours.append(hours.at(i));
		}
	
	days=newDays;
	hours=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetNotAvailableTimes::ConstraintStudentsSetNotAvailableTimes()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_NOT_AVAILABLE_TIMES;
}

ConstraintStudentsSetNotAvailableTimes::ConstraintStudentsSetNotAvailableTimes(double wp, const QString& sn, const QList<int>& d, const QList<int>& h)
	 : TimeConstraint(wp){
	this->students = sn;
	assert(d.count()==h.count());
	this->days=d;
	this->hours=h;
	this->type=CONSTRAINT_STUDENTS_SET_NOT_AVAILABLE_TIMES;
}

bool ConstraintStudentsSetNotAvailableTimes::computeInternalStructure(QWidget* parent, Rules& r){
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set not available is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	assert(days.count()==hours.count());
	for(int k=0; k<days.count(); k++){
		if(this->days.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students set not available times is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours.at(k) >= r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students set not available times is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	
	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
	return true;
}

bool ConstraintStudentsSetNotAvailableTimes::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetNotAvailableTimes::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintStudentsSetNotAvailableTimes>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<Number_of_Not_Available_Times>"+QString::number(this->days.count())+"</Number_of_Not_Available_Times>\n";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		s+=IL3+"<Not_Available_Time>\n";
		if(this->days.at(i)>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->days.at(i)])+"</Day>\n";
		if(this->hours.at(i)>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hours.at(i)])+"</Hour>\n";
		s+=IL3+"</Not_Available_Time>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetNotAvailableTimes>\n";
	return s;
}

QString ConstraintStudentsSetNotAvailableTimes::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s=tr("Students set not available");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();

	s+=tr("NA at:", "Not available at");
	s+=" ";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		if(this->days.at(i)>=0){
			s+=r.daysOfTheWeek[this->days.at(i)];
			s+=" ";
		}
		if(this->hours.at(i)>=0){
			s+=r.hoursOfTheDay[this->hours.at(i)];
		}
		if(i<days.count()-1)
			s+=translatedSemicolonSpace();
	}

	return begin+s+end;
}

QString ConstraintStudentsSetNotAvailableTimes::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set is not available");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Students=%1").arg(this->students);s+="\n";

	s+=tr("Not available at:", "It refers to a students set");s+="\n";
	
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		if(this->days.at(i)>=0){
			s+=r.daysOfTheWeek[this->days.at(i)];
			s+=" ";
		}
		if(this->hours.at(i)>=0){
			s+=r.hoursOfTheDay[this->hours.at(i)];
		}
		if(i<days.count()-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetNotAvailableTimes::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	for(int m=0; m<this->iSubgroupsList.count(); m++){
		int sbg=this->iSubgroupsList.at(m);
		
		assert(days.count()==hours.count());
		for(int k=0; k<days.count(); k++){
			int d=days.at(k);
			int h=hours.at(k);
			
			if(subgroupsMatrix[sbg][d][h]>0){
				nbroken+=subgroupsMatrix[sbg][d][h];

				if(conflictsString!=nullptr){
					QString s= tr("Time constraint students set not available");
					s += " ";
					s += tr("broken for subgroup: %1 on day %2, hour %3")
					 .arg(r.internalSubgroupsList[sbg]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(r.hoursOfTheDay[h]);
					s += ". ";
					s += tr("This increases the conflicts total by %1")
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(subgroupsMatrix[sbg][d][h]*weightPercentage/100));
					
					dl.append(s);
					cl.append(subgroupsMatrix[sbg][d][h]*weightPercentage/100);
				
					*conflictsString += s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetNotAvailableTimes::isRelatedToActivity(Rules& r, Activity* a)
{
	for(const QString& st : a->studentsNames)
		if(r.setsShareStudents(st, this->students))
			return true;

	return false;
}

bool ConstraintStudentsSetNotAvailableTimes::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetNotAvailableTimes::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetNotAvailableTimes::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetNotAvailableTimes::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetNotAvailableTimes::hasWrongDayOrHour(Rules& r)
{
	assert(days.count()==hours.count());
	
	for(int i=0; i<days.count(); i++)
		if(days.at(i)<0 || days.at(i)>=r.nDaysPerWeek
		 || hours.at(i)<0 || hours.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintStudentsSetNotAvailableTimes::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetNotAvailableTimes::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(days.count()==hours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<days.count(); i++)
		if(days.at(i)>=0 && days.at(i)<r.nDaysPerWeek
		 && hours.at(i)>=0 && hours.at(i)<r.nHoursPerDay){
			newDays.append(days.at(i));
			newHours.append(hours.at(i));
		}
	
	days=newDays;
	hours=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesSameStartingTime::ConstraintActivitiesSameStartingTime()
	: TimeConstraint()
{
	type=CONSTRAINT_ACTIVITIES_SAME_STARTING_TIME;
}

ConstraintActivitiesSameStartingTime::ConstraintActivitiesSameStartingTime(double wp, int nact, const QList<int>& act)
 : TimeConstraint(wp)
 {
	assert(nact>=2);
	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	this->type=CONSTRAINT_ACTIVITIES_SAME_STARTING_TIME;
}

bool ConstraintActivitiesSameStartingTime::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintActivitiesSameStartingTime::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintActivitiesSameStartingTime::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesSameStartingTime::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintActivitiesSameStartingTime::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesSameStartingTime>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesSameStartingTime>\n";
	return s;
}

QString ConstraintActivitiesSameStartingTime::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Activities same starting time");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));
		if(i<this->n_activities-1)
			s+=translatedCommaSpace();
	}

	return begin+s+end;
}

QString ConstraintActivitiesSameStartingTime::getDetailedDescription(Rules& r)
{
	QString s;
	
	s=tr("Time constraint");s+="\n";
	s+=tr("Activities must have the same starting time");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity").arg(this->activitiesIds[i]).arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesSameStartingTime::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//sum the differences in the scheduled time for all pairs of activities.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int tmp=0;

						tmp = abs(day1-day2) + abs(hour1-hour2);
							
						if(tmp>0)
							tmp=1;

						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int tmp=0;

						tmp = abs(day1-day2) + abs(hour1-hour2);
							
						if(tmp>0)
							tmp=1;

						nbroken+=tmp;

						if(tmp>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint activities same starting time broken, because activity with id=%1 (%2) is not at the same starting time with activity with id=%3 (%4)",
							"%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id));
							s+=". ";
							s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintActivitiesSameStartingTime::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	
	return activitiesIdsSet.contains(a->id);
	
	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintActivitiesSameStartingTime::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesSameStartingTime::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesSameStartingTime::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesSameStartingTime::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesSameStartingTime::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesSameStartingTime::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesSameStartingTime::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesNotOverlapping::ConstraintActivitiesNotOverlapping()
	: TimeConstraint()
{
	type=CONSTRAINT_ACTIVITIES_NOT_OVERLAPPING;
}

ConstraintActivitiesNotOverlapping::ConstraintActivitiesNotOverlapping(double wp, int nact, const QList<int>& act)
 : TimeConstraint(wp)
 {
  	assert(nact>=2);
  	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	this->type=CONSTRAINT_ACTIVITIES_NOT_OVERLAPPING;
}

bool ConstraintActivitiesNotOverlapping::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintActivitiesNotOverlapping::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintActivitiesNotOverlapping::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesNotOverlapping::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintActivitiesNotOverlapping::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesNotOverlapping>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesNotOverlapping>\n";
	return s;
}

QString ConstraintActivitiesNotOverlapping::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Activities not overlapping");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));
		if(i<this->n_activities-1)
			s+=translatedCommaSpace();
	}

	return begin+s+end;
}

QString ConstraintActivitiesNotOverlapping::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities must not overlap");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i]).arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesNotOverlapping::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//sum the overlapping hours for all pairs of activities.
	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;

						//the number of overlapping hours
						int tt=0;
						if(day1==day2){
							int start=std::max(hour1, hour2);
							int stop=std::min(hour1+duration1, hour2+duration2);
							if(stop>start)
								tt+=stop-start;
						}
						
						nbroken+=tt;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;
	
						//the number of overlapping hours
						int tt=0;
						if(day1==day2){
							int start=std::max(hour1, hour2);
							int stop=std::min(hour1+duration1, hour2+duration2);
							if(stop>start)
								tt+=stop-start;
						}

						//The overlapping hours
						int tmp=tt;

						nbroken+=tmp;

						if(tt>0 && conflictsString!=nullptr){

							QString s=tr("Time constraint activities not overlapping broken: activity with id=%1 (%2) overlaps with activity with id=%3 (%4) on a number of %5 periods",
							 "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
							 .arg(tt);
							s+=translatedCommaSpace();
							s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
						
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintActivitiesNotOverlapping::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	
	return activitiesIdsSet.contains(a->id);
	
	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintActivitiesNotOverlapping::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesNotOverlapping::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesNotOverlapping::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesNotOverlapping::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesNotOverlapping::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesNotOverlapping::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesNotOverlapping::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityTagsNotOverlapping::ConstraintActivityTagsNotOverlapping()
	: TimeConstraint()
{
	type=CONSTRAINT_ACTIVITY_TAGS_NOT_OVERLAPPING;
}

ConstraintActivityTagsNotOverlapping::ConstraintActivityTagsNotOverlapping(double wp, const QStringList& atl)
 : TimeConstraint(wp)
 {
	activityTagsNames=atl;

	this->type=CONSTRAINT_ACTIVITY_TAGS_NOT_OVERLAPPING;
}

bool ConstraintActivityTagsNotOverlapping::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(activityTagsNames.count()<2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("The following constraint is wrong (because it needs at least two activity tags). "
			"Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	activityTagsIndices.clear();
	activitiesIndicesLists.clear();
	for(const QString& activityTagName : std::as_const(activityTagsNames)){
		int activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
		assert(activityTagIndex>=0);
		activityTagsIndices.append(activityTagIndex);
		activitiesIndicesLists.append(QList<int>());
	}
	
	for(int ai=0; ai<r.nInternalActivities; ai++){
		Activity* act=&r.internalActivitiesList[ai];
		for(int i=0; i<activityTagsIndices.count(); i++){
			int at=activityTagsIndices.at(i);
			if(act->iActivityTagsSet.contains(at))
				activitiesIndicesLists[i].append(ai);
		}
	}
	
	assert(activitiesIndicesLists.count()==activityTagsIndices.count());
	assert(activityTagsNames.count()==activityTagsIndices.count());
	for(int i=0; i<activityTagsIndices.count(); i++){
		if(activitiesIndicesLists.at(i).count()<1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
				tr("Following constraint is wrong (because you need at least one activity for each activity tag, but"
				 " no activity has activity tag %1). Please correct it:\n%2").arg(activityTagsNames.at(i)).arg(this->getDetailedDescription(r)));
			return false;
		}
	}

	return true;
}

bool ConstraintActivityTagsNotOverlapping::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintActivityTagsNotOverlapping::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityTagsNotOverlapping>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(this->activityTagsNames.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(activityTagsNames))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityTagsNotOverlapping>\n";
	return s;
}

QString ConstraintActivityTagsNotOverlapping::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Activity tags not overlapping");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NAT:%1", "Number of activity tags").arg(this->activityTagsNames.count());s+=translatedCommaSpace();
	int i=0;
	for(const QString& atn : std::as_const(activityTagsNames)){
		s+=tr("AT:%1", "Activity tag").arg(atn);
		if(i<this->activityTagsNames.count()-1)
			s+=translatedCommaSpace();
		i++;
	}

	return begin+s+end;
}

QString ConstraintActivityTagsNotOverlapping::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity tags must not overlap");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activity tags=%1").arg(this->activityTagsNames.count());s+="\n";
	for(const QString& atn : std::as_const(activityTagsNames)){
		s+=tr("Activity tag=%1").arg(atn);
		s+="\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityTagsNotOverlapping::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//sum the overlapping hours for all pairs of activities.
	nbroken=0;
	
	for(int k1=1; k1<activitiesIndicesLists.count(); k1++){
		const QList<int>& l1=activitiesIndicesLists.at(k1);
		for(int k2=0; k2<k1; k2++){
			const QList<int>& l2=activitiesIndicesLists.at(k2);
			
			for(int i : std::as_const(l1)){
				int t1=c.times[i];
				if(t1!=UNALLOCATED_TIME){
					int day1=t1%r.nDaysPerWeek;
					int hour1=t1/r.nDaysPerWeek;
					int duration1=r.internalActivitiesList[i].duration;

					for(int j : std::as_const(l2)){
						int t2=c.times[j];
						if(t2!=UNALLOCATED_TIME){
							int day2=t2%r.nDaysPerWeek;
							int hour2=t2/r.nDaysPerWeek;
							int duration2=r.internalActivitiesList[j].duration;

							//the number of overlapping hours
							int tt=0;
							if(day1==day2){
								int start=std::max(hour1, hour2);
								int stop=std::min(hour1+duration1, hour2+duration2);
								if(stop>start)
									tt+=stop-start;
							}

							int tmp=tt;

							nbroken+=tmp;

							if(tt>0 && conflictsString!=nullptr){
								QString s=tr("Time constraint activity tags not overlapping broken: activity with id=%1 (%2) overlaps with activity with id=%3 (%4) on a number of %5 periods",
								 "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
								 .arg(r.internalActivitiesList[i].id)
								 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[i].id))
								 .arg(r.internalActivitiesList[j].id)
								 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[j].id))
								 .arg(tt);
								s+=translatedCommaSpace();
								s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
								
								dl.append(s);
								cl.append(tmp*weightPercentage/100);
								
								*conflictsString+= s+"\n";
							}
						}
					}
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintActivityTagsNotOverlapping::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	QSet<QString> ats(activityTagsNames.constBegin(), activityTagsNames.constEnd());
	QSet<QString> aats(a->activityTagsNames.constBegin(), a->activityTagsNames.constEnd());
#else
	QSet<QString> ats=activityTagsNames.toSet();
	QSet<QString> aats=a->activityTagsNames.toSet();
#endif
	ats.intersect(aats);

	if(ats.count()>0)
		return true;

	return false;
}

bool ConstraintActivityTagsNotOverlapping::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityTagsNotOverlapping::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityTagsNotOverlapping::isRelatedToActivityTag(ActivityTag* s)
{
	return activityTagsNames.contains(s->name);
}

bool ConstraintActivityTagsNotOverlapping::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityTagsNotOverlapping::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivityTagsNotOverlapping::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivityTagsNotOverlapping::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintMinDaysBetweenActivities::ConstraintMinDaysBetweenActivities()
	: TimeConstraint()
{
	type=CONSTRAINT_MIN_DAYS_BETWEEN_ACTIVITIES;
}

ConstraintMinDaysBetweenActivities::ConstraintMinDaysBetweenActivities(double wp, bool cisd, int nact, const QList<int>& act, int _minDays)
 : TimeConstraint(wp)
 {
	this->consecutiveIfSameDay=cisd;

	assert(nact>=2);
	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	assert(_minDays>0);
	this->minDays=_minDays;

	this->type=CONSTRAINT_MIN_DAYS_BETWEEN_ACTIVITIES;
}

bool ConstraintMinDaysBetweenActivities::operator==(ConstraintMinDaysBetweenActivities& c){
	assert(this->n_activities==this->activitiesIds.count());
	assert(c.n_activities==c.activitiesIds.count());

	if(this->n_activities!=c.n_activities)
		return false;
	for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]!=c.activitiesIds[i])
			return false;
	if(this->minDays!=c.minDays)
		return false;
	if(this->weightPercentage!=c.weightPercentage)
		return false;
	if(this->consecutiveIfSameDay!=c.consecutiveIfSameDay)
		return false;
	return true;
}

bool ConstraintMinDaysBetweenActivities::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintMinDaysBetweenActivities::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintMinDaysBetweenActivities::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMinDaysBetweenActivities::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintMinDaysBetweenActivities::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintMinDaysBetweenActivities>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Consecutive_If_Same_Day>";s+=trueFalse(this->consecutiveIfSameDay);s+="</Consecutive_If_Same_Day>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MinDays>"+CustomFETString::number(this->minDays)+"</MinDays>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMinDaysBetweenActivities>\n";
	return s;
}

QString ConstraintMinDaysBetweenActivities::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Min days between activities");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("mD:%1", "Min days").arg(this->minDays);s+=translatedCommaSpace();
	s+=tr("CSD:%1", "Consecutive if on the same day").arg(yesNoTranslated(this->consecutiveIfSameDay));

	return begin+s+end;
}

QString ConstraintMinDaysBetweenActivities::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Minimum number of days between activities");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Minimum number of days=%1").arg(this->minDays);s+="\n";
	s+=tr("Consecutive if on the same day=%1").arg(yesNoTranslated(this->consecutiveIfSameDay));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMinDaysBetweenActivities::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int dist = r.mode==MORNINGS_AFTERNOONS ? abs(day1/2-day2/2) : abs(day1-day2);
						if(dist<minDays){
							tt=minDays-dist;
							
							if(r.mode!=MORNINGS_AFTERNOONS){
								if(this->consecutiveIfSameDay && day1==day2)
									assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
							}
							else{
								if(this->consecutiveIfSameDay)
									assert( ( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) ) || (day1/2!=day2/2) );
							}
						}
						
						tmp=tt;
	
						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int dist = r.mode==MORNINGS_AFTERNOONS ? abs(day1/2-day2/2) : abs(day1-day2);

						if(dist<minDays){
							tt=minDays-dist;
							
							if(r.mode!=MORNINGS_AFTERNOONS){
								if(this->consecutiveIfSameDay && day1==day2)
									assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
							}
							else{
								if(this->consecutiveIfSameDay)
									assert( ( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) ) || (day1/2!=day2/2) );
							}
						}

						tmp=tt;
	
						nbroken+=tmp;

						if(tt>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint min days between activities broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), being %5 days too close, on days %6 and %7",
							 "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr. Close here means near")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
							 .arg(tt)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.daysOfTheWeek[day2]);
							 ;

							s+=translatedCommaSpace();
							s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							s+=translatedDot();
							
							if(this->consecutiveIfSameDay && ((r.mode!=MORNINGS_AFTERNOONS && day1==day2) || (r.mode==MORNINGS_AFTERNOONS && day1/2==day2/2))){
								s+=" ";
								s+=tr("The activities are placed consecutively in the timetable, because you selected this option"
								 " in case the activities are on the same day");
							}
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}
	
	if(true && minDays>=1 /*!this->consecutiveIfSameDay*/){ //from version 6.4.0, not allowed more than two activities on the same (real) day
	//The test minDays>=1 was added in FET-6.9.6, after the crash report by Rouge Ros on 2023-09-17. If minDays was 0, FET crashed if there were
	//more than two activities from this constraint on the same day. It is possible to have minDays==0 is the .fet file is created manually or
	//with another tool, or if the user decreases the number of days to 1 after adding one or more constraint(s) of type min days between activities.
		if(r.mode!=MORNINGS_AFTERNOONS){
			Matrix1D<int> na;
			na.resize(r.nDaysPerWeek);
			for(int d=0; d<r.nDaysPerWeek; d++)
				na[d]=0;
			
			for(int i=0; i<this->_n_activities; i++){
				int t=c.times[this->_activities[i]];
				if(t!=UNALLOCATED_TIME){
					int day=t%r.nDaysPerWeek;
					na[day]++;
				}
			}
			
			for(int d=0; d<r.nDaysPerWeek; d++)
				assert(na[d]<=2);
		}
		else{
			Matrix1D<int> na;
			na.resize(r.nDaysPerWeek/2);
			for(int d=0; d<r.nDaysPerWeek/2; d++)
				na[d]=0;
			
			for(int i=0; i<this->_n_activities; i++){
				int t=c.times[this->_activities[i]];
				if(t!=UNALLOCATED_TIME){
					int day=t%r.nDaysPerWeek;
					na[day/2]++;
				}
			}
			
			for(int d=0; d<r.nDaysPerWeek/2; d++)
				assert(na[d]<=2);
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintMinDaysBetweenActivities::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	
	return activitiesIdsSet.contains(a->id);
	
	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintMinDaysBetweenActivities::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMinDaysBetweenActivities::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinDaysBetweenActivities::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinDaysBetweenActivities::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinDaysBetweenActivities::hasWrongDayOrHour(Rules& r)
{
	if(r.mode!=MORNINGS_AFTERNOONS){
		if(minDays>=r.nDaysPerWeek)
			return true;
	}
	else{
		if(minDays>=r.nDaysPerWeek/2)
			return true;
	}
	
	return false;
}

bool ConstraintMinDaysBetweenActivities::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintMinDaysBetweenActivities::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(r.mode!=MORNINGS_AFTERNOONS){
		if(minDays>=r.nDaysPerWeek)
			minDays=r.nDaysPerWeek-1;
	}
	else{
		if(minDays>=r.nDaysPerWeek/2)
			minDays=r.nDaysPerWeek/2-1;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintMaxDaysBetweenActivities::ConstraintMaxDaysBetweenActivities()
	: TimeConstraint()
{
	type=CONSTRAINT_MAX_DAYS_BETWEEN_ACTIVITIES;
}

ConstraintMaxDaysBetweenActivities::ConstraintMaxDaysBetweenActivities(double wp, int nact, const QList<int>& act, int _maxDays)
 : TimeConstraint(wp)
 {
	assert(nact>=2);
	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	assert(_maxDays>=0);
	this->maxDays=_maxDays;

	this->type=CONSTRAINT_MAX_DAYS_BETWEEN_ACTIVITIES;
}

bool ConstraintMaxDaysBetweenActivities::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintMaxDaysBetweenActivities::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintMaxDaysBetweenActivities::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMaxDaysBetweenActivities::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintMaxDaysBetweenActivities::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintMaxDaysBetweenActivities>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MaxDays>"+CustomFETString::number(this->maxDays)+"</MaxDays>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMaxDaysBetweenActivities>\n";
	return s;
}

QString ConstraintMaxDaysBetweenActivities::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Max days between activities");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("MD:%1", "Abbreviation for maximum days").arg(this->maxDays);

	return begin+s+end;
}

QString ConstraintMaxDaysBetweenActivities::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Maximum number of days between activities");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Maximum number of days=%1").arg(this->maxDays);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMaxDaysBetweenActivities::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				//int hour1=t1/r.nDaysPerWeek;
				//int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						//int hour2=t2/r.nDaysPerWeek;
						//int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int dist = r.mode==MORNINGS_AFTERNOONS ? abs(day1/2-day2/2) : abs(day1-day2);
						if(dist>maxDays){
							tt=dist-maxDays;
							
							//if(this->consecutiveIfSameDay && day1==day2)
							//	assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}
						
						tmp=tt;
	
						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				//int hour1=t1/r.nDaysPerWeek;
				//int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						//int hour2=t2/r.nDaysPerWeek;
						//int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int dist = r.mode==MORNINGS_AFTERNOONS ? abs(day1/2-day2/2) : abs(day1-day2);

						if(dist>maxDays){
							tt=dist-maxDays;
							
							//if(this->consecutiveIfSameDay && day1==day2)
							//	assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}

						tmp=tt;
	
						nbroken+=tmp;

						if(tt>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint max days between activities broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), being %5 days too far away"
							 ", on days %6 and %7", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
							 .arg(tt)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.daysOfTheWeek[day2]);
							
							s+=translatedCommaSpace();
							s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							s+=translatedDot();
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintMaxDaysBetweenActivities::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintMaxDaysBetweenActivities::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMaxDaysBetweenActivities::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxDaysBetweenActivities::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxDaysBetweenActivities::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxDaysBetweenActivities::hasWrongDayOrHour(Rules& r)
{
	if(r.mode!=MORNINGS_AFTERNOONS){
		if(maxDays>=r.nDaysPerWeek)
			return true;
	}
	else{
		if(maxDays>=r.nDaysPerWeek/2)
			return true;
	}
	
	return false;
}

bool ConstraintMaxDaysBetweenActivities::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintMaxDaysBetweenActivities::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(r.mode!=MORNINGS_AFTERNOONS){
		if(maxDays>=r.nDaysPerWeek)
			maxDays=r.nDaysPerWeek-1;
	}
	else{
		if(maxDays>=r.nDaysPerWeek/2)
			maxDays=r.nDaysPerWeek/2-1;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesMaxHourlySpan::ConstraintActivitiesMaxHourlySpan()
	: TimeConstraint()
{
	type=CONSTRAINT_ACTIVITIES_MAX_HOURLY_SPAN;
}

ConstraintActivitiesMaxHourlySpan::ConstraintActivitiesMaxHourlySpan(double wp, int nact, const QList<int>& act, int _maxHourlySpan)
 : TimeConstraint(wp)
 {
	assert(nact>=2);
	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	assert(_maxHourlySpan>=0);
	this->maxHourlySpan=_maxHourlySpan;

	this->type=CONSTRAINT_ACTIVITIES_MAX_HOURLY_SPAN;
}

bool ConstraintActivitiesMaxHourlySpan::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintActivitiesMaxHourlySpan::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintActivitiesMaxHourlySpan::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesMaxHourlySpan::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintActivitiesMaxHourlySpan::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesMaxHourlySpan>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MaxHourlySpan>"+CustomFETString::number(this->maxHourlySpan)+"</MaxHourlySpan>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesMaxHourlySpan>\n";
	return s;
}

QString ConstraintActivitiesMaxHourlySpan::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Activities max hourly span");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("MHS:%1", "Abbreviation for maximum hourly span").arg(this->maxHourlySpan);

	return begin+s+end;
}

QString ConstraintActivitiesMaxHourlySpan::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities max hourly span");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Maximum hourly span=%1").arg(this->maxHourlySpan);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesMaxHourlySpan::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				//int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						//int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int td1 = abs(hour1-(hour2+duration2));
						int td2 = abs(hour2-(hour1+duration1));
						//int dist = abs(day1-day2);

						if(td1>maxHourlySpan || td2>maxHourlySpan)
							tt=std::max(maxHourlySpan-td1, maxHourlySpan-td2);

						/*if(dist>maxDays){
							tt=dist-maxDays;
							
							//if(this->consecutiveIfSameDay && day1==day2)
							//	assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}*/

						tmp=tt;
	
						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				//int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						//int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int td1 = abs(hour1-(hour2+duration2));
						int td2 = abs(hour2-(hour1+duration1));
						//int dist = abs(day1-day2);

						if(td1>maxHourlySpan || td2>maxHourlySpan)
							tt=std::max(maxHourlySpan-td1, maxHourlySpan-td2);

						/*if(dist>maxDays){
							tt=dist-maxDays;
							
							//if(this->consecutiveIfSameDay && day1==day2)
							//	assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}*/

						tmp=tt;
	
						nbroken+=tmp;

						if(tt>0 && conflictsString!=nullptr){
							int day1=t1%r.nDaysPerWeek;
							int day2=t2%r.nDaysPerWeek;
							
							QString s=tr("Time constraint activities max hourly span broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), spanning %5 hours too much."
							 " The first activity begins on day %6, hour %7, and the second activity begins on day %8, hour %9",
							 "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
							 .arg(tt)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.hoursOfTheDay[hour1])
							 .arg(r.daysOfTheWeek[day2])
							 .arg(r.hoursOfTheDay[hour2]);
							
							s+=translatedCommaSpace();
							s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							s+=translatedDot();
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintActivitiesMaxHourlySpan::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintActivitiesMaxHourlySpan::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesMaxHourlySpan::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxHourlySpan::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxHourlySpan::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxHourlySpan::hasWrongDayOrHour(Rules& r)
{
	if(maxHourlySpan>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintActivitiesMaxHourlySpan::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesMaxHourlySpan::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHourlySpan>r.nHoursPerDay)
		maxHourlySpan=r.nHoursPerDay;
	
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintMinGapsBetweenActivities::ConstraintMinGapsBetweenActivities()
	: TimeConstraint()
{
	type=CONSTRAINT_MIN_GAPS_BETWEEN_ACTIVITIES;
}

ConstraintMinGapsBetweenActivities::ConstraintMinGapsBetweenActivities(double wp, int nact, const QList<int>& actList, int ngaps)
 : TimeConstraint(wp)
 {
	this->n_activities=nact;
	assert(nact==actList.count());
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(actList.at(i));

	assert(ngaps>0);
	this->minGaps=ngaps;

	this->type=CONSTRAINT_MIN_GAPS_BETWEEN_ACTIVITIES;
}

bool ConstraintMinGapsBetweenActivities::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintMinGapsBetweenActivities::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintMinGapsBetweenActivities::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMinGapsBetweenActivities::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintMinGapsBetweenActivities::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintMinGapsBetweenActivities>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMinGapsBetweenActivities>\n";
	return s;
}

QString ConstraintMinGapsBetweenActivities::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Min gaps between activities");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("mG:%1", "Minimum number of gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintMinGapsBetweenActivities::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Minimum gaps between activities (if the activities are on the same day)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Minimum number of gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMinGapsBetweenActivities::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	nbroken=0;
	for(int i=1; i<this->_n_activities; i++){
		int t1=c.times[this->_activities[i]];
		if(t1!=UNALLOCATED_TIME){
			int day1=t1%r.nDaysPerWeek;
			int hour1=t1/r.nDaysPerWeek;
			int duration1=r.internalActivitiesList[this->_activities[i]].duration;

			for(int j=0; j<i; j++){
				int t2=c.times[this->_activities[j]];
				if(t2!=UNALLOCATED_TIME){
					int day2=t2%r.nDaysPerWeek;
					int hour2=t2/r.nDaysPerWeek;
					int duration2=r.internalActivitiesList[this->_activities[j]].duration;
				
					int tmp;
					int tt=0;
					int dist=abs(day1-day2);
					
					if(dist==0){ //same day
						assert(day1==day2);
						if(hour2>=hour1){
							//assert(hour1+duration1<=hour2); not true for activities which are not incompatible
							if(hour1+duration1+minGaps > hour2)
								tt = (hour1+duration1+minGaps) - hour2;
						}
						else{
							//assert(hour2+duration2<=hour1); not true for activities which are not incompatible
							if(hour2+duration2+minGaps > hour1)
								tt = (hour2+duration2+minGaps) - hour1;
						}
					}

					tmp=tt;
	
					nbroken+=tmp;

					if(tt>0 && conflictsString!=nullptr){
						QString s=tr("Time constraint min gaps between activities broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), they are on the same day %5 and there are %6 more needed hours between them",
							"%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
						 .arg(r.internalActivitiesList[this->_activities[i]].id)
						 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
						 .arg(r.internalActivitiesList[this->_activities[j]].id)
						 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
						 .arg(r.daysOfTheWeek[day1])
						 .arg(tt);

						s+=translatedCommaSpace();
						s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
						s+=translatedDot();
							
						dl.append(s);
						cl.append(tmp*weightPercentage/100);
							
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintMinGapsBetweenActivities::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintMinGapsBetweenActivities::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMinGapsBetweenActivities::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinGapsBetweenActivities::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinGapsBetweenActivities::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinGapsBetweenActivities::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintMinGapsBetweenActivities::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintMinGapsBetweenActivities::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintMaxGapsBetweenActivities::ConstraintMaxGapsBetweenActivities()
	: TimeConstraint()
{
	type=CONSTRAINT_MAX_GAPS_BETWEEN_ACTIVITIES;
}

ConstraintMaxGapsBetweenActivities::ConstraintMaxGapsBetweenActivities(double wp, int nact, const QList<int>& actList, int ngaps)
 : TimeConstraint(wp)
 {
	this->n_activities=nact;
	assert(nact==actList.count());
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(actList.at(i));

	assert(ngaps>0);
	this->maxGaps=ngaps;

	this->type=CONSTRAINT_MAX_GAPS_BETWEEN_ACTIVITIES;
}

bool ConstraintMaxGapsBetweenActivities::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();

	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintMaxGapsBetweenActivities::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)

	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}

	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintMaxGapsBetweenActivities::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMaxGapsBetweenActivities::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintMaxGapsBetweenActivities::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintMaxGapsBetweenActivities>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MaxGaps>"+CustomFETString::number(this->maxGaps)+"</MaxGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMaxGapsBetweenActivities>\n";
	return s;
}

QString ConstraintMaxGapsBetweenActivities::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Max gaps between activities");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("MG:%1", "Maximum number of gaps").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintMaxGapsBetweenActivities::getDetailedDescription(Rules& r){
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Maximum gaps between activities (if the activities are on the same day)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Maximum number of gaps=%1").arg(this->maxGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMaxGapsBetweenActivities::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	nbroken=0;
	for(int i=1; i<this->_n_activities; i++){
		int t1=c.times[this->_activities[i]];
		if(t1!=UNALLOCATED_TIME){
			int day1=t1%r.nDaysPerWeek;
			int hour1=t1/r.nDaysPerWeek;
			int duration1=r.internalActivitiesList[this->_activities[i]].duration;

			for(int j=0; j<i; j++){
				int t2=c.times[this->_activities[j]];
				if(t2!=UNALLOCATED_TIME){
					int day2=t2%r.nDaysPerWeek;
					int hour2=t2/r.nDaysPerWeek;
					int duration2=r.internalActivitiesList[this->_activities[j]].duration;

					int tmp;
					int tt=0;
					int dist=abs(day1-day2);

					if(dist==0){ //same day
						assert(day1==day2);
						if(hour2>=hour1){
							//assert(hour1+duration1<=hour2); not true for activities which are not incompatible
							if(hour1+duration1+maxGaps < hour2)
								tt = - (hour1+duration1+maxGaps) + hour2;
						}
						else{
							//assert(hour2+duration2<=hour1); not true for activities which are not incompatible
							if(hour2+duration2+maxGaps < hour1)
								tt = - (hour2+duration2+maxGaps) + hour1;
						}
					}

					tmp=tt;

					nbroken+=tmp;

					if(tt>0 && conflictsString!=nullptr){
						QString s=tr("Time constraint max gaps between activities broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), they are on the same day %5 and there are %6 extra hours between them",
							"%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
						 .arg(r.internalActivitiesList[this->_activities[i]].id)
						 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
						 .arg(r.internalActivitiesList[this->_activities[j]].id)
						 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
						 .arg(r.daysOfTheWeek[day1])
						 .arg(tt);

						s+=translatedCommaSpace();
						s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
						s+=translatedDot();

						dl.append(s);
						cl.append(tmp*weightPercentage/100);

						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintMaxGapsBetweenActivities::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintMaxGapsBetweenActivities::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMaxGapsBetweenActivities::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxGapsBetweenActivities::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxGapsBetweenActivities::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxGapsBetweenActivities::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintMaxGapsBetweenActivities::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintMaxGapsBetweenActivities::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>r.nHoursPerDay)
		maxGaps=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxHoursDaily::ConstraintTeachersMaxHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_DAILY;
}

ConstraintTeachersMaxHoursDaily::ConstraintTeachersMaxHoursDaily(double wp, int maxhours)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;

	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_DAILY;
}

bool ConstraintTeachersMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintTeachersMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxHoursDaily>\n";
	return s;
}

QString ConstraintTeachersMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers max hours daily"), s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MH:%1", "Maximum hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintTeachersMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_daily++;

				if(n_hours_daily>this->maxHoursDaily)
					nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_daily++;

				if(n_hours_daily>this->maxHoursDaily){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr(
						 "Time constraint teachers max %1 hours daily broken for teacher %2, on day %3, length=%4.")
						 .arg(CustomFETString::number(this->maxHoursDaily))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(r.daysOfTheWeek[d])
						 .arg(n_hours_daily)
						 )
						 +
						 " "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
						
						dl.append(s);
						cl.append(weightPercentage/100);
					
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxHoursDaily::ConstraintTeacherMaxHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_HOURS_DAILY;
}

ConstraintTeacherMaxHoursDaily::ConstraintTeacherMaxHoursDaily(double wp, int maxhours, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MAX_HOURS_DAILY;
}

bool ConstraintTeacherMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxHoursDaily>\n";
	return s;
}

QString ConstraintTeacherMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher max hours daily");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MH:%1", "Maximum hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintTeacherMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_daily++;

			if(n_hours_daily>this->maxHoursDaily){
				nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_daily++;

			if(n_hours_daily>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher max %1 hours daily broken for teacher %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(n_hours_daily)
					 )
					 +" "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
						
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxHoursContinuously::ConstraintTeachersMaxHoursContinuously()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_CONTINUOUSLY;
}

ConstraintTeachersMaxHoursContinuously::ConstraintTeachersMaxHoursContinuously(double wp, int maxhours)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursContinuously=maxhours;

	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintTeachersMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxHoursContinuously>\n";
	return s;
}

QString ConstraintTeachersMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers max hours continuously");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MH:%1", "Maximum hours (continuously)").arg(this->maxHoursContinuously);

	return begin+s+end;
}

QString ConstraintTeachersMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of hours continuously");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	for(int i=0; i<r.nInternalTeachers; i++){
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nc=0;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[i][d][h]>0)
					nc++;
				else{
					if(nc>this->maxHoursContinuously){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint teachers max %1 hours continuously broken for teacher %2, on day %3, length=%4.")
							 .arg(CustomFETString::number(this->maxHoursContinuously))
							 .arg(r.internalTeachersList[i]->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(nc)
							 )
							 +
							 " "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
				
							*conflictsString+= s+"\n";
						}
					}
				
					nc=0;
				}
			}

			if(nc>this->maxHoursContinuously){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teachers max %1 hours continuously broken for teacher %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->maxHoursContinuously))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nc)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxHoursContinuously::ConstraintTeacherMaxHoursContinuously()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_HOURS_CONTINUOUSLY;
}

ConstraintTeacherMaxHoursContinuously::ConstraintTeacherMaxHoursContinuously(double wp, int maxhours, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursContinuously=maxhours;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintTeacherMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxHoursContinuously>\n";
	return s;
}

QString ConstraintTeacherMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher max hours continuously");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MH:%1", "Maximum hours continuously").arg(this->maxHoursContinuously);

	return begin+s+end;
}

QString ConstraintTeacherMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of hours continuously");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	int i=this->teacher_ID;
	for(int d=0; d<r.nDaysPerWeek; d++){
		int nc=0;
		for(int h=0; h<r.nHoursPerDay; h++){
			if(teachersMatrix[i][d][h]>0)
				nc++;
			else{
				if(nc>this->maxHoursContinuously){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr(
						 "Time constraint teacher max %1 hours continuously broken for teacher %2, on day %3, length=%4.")
						 .arg(CustomFETString::number(this->maxHoursContinuously))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(r.daysOfTheWeek[d])
						 .arg(nc)
						 )
						 +
						 " "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
						
						dl.append(s);
						cl.append(weightPercentage/100);
			
						*conflictsString+= s+"\n";
					}
				}
			
				nc=0;
			}
		}

		if(nc>this->maxHoursContinuously){
			nbroken++;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint teacher max %1 hours continuously broken for teacher %2, on day %3, length=%4.")
				 .arg(CustomFETString::number(this->maxHoursContinuously))
				 .arg(r.internalTeachersList[i]->name)
				 .arg(r.daysOfTheWeek[d])
				 .arg(nc)
				 )
				 +
				 " "
				 +
				 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
				
				dl.append(s);
				cl.append(weightPercentage/100);
			
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersActivityTagMaxHoursContinuously::ConstraintTeachersActivityTagMaxHoursContinuously()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
}

ConstraintTeachersActivityTagMaxHoursContinuously::ConstraintTeachersActivityTagMaxHoursContinuously(double wp, int maxhours, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursContinuously=maxhours;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);
	
	this->canonicalTeachersList.clear();
	for(int i=0; i<r.nInternalTeachers; i++){
		bool found=false;
	
		Teacher* tch=r.internalTeachersList[i];
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalTeachersList.append(i);
	}

	return true;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersActivityTagMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersActivityTagMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersActivityTagMaxHoursContinuously>\n";
	return s;
}

QString ConstraintTeachersActivityTagMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers for activity tag %1 have max %2 hours continuously").arg(this->activityTagName).arg(this->maxHoursContinuously);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersActivityTagMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers, for an activity tag, must respect the maximum number of hours continuously");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName); s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersActivityTagMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}
	
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nc=0;
			for(int h=0; h<r.nHoursPerDay; h++){
				bool inc=false;
				if(crtTeacherTimetableActivityTag[d][h]==this->activityTagIndex)
					inc=true;
				
				if(inc){
					nc++;
				}
				else{
					if(nc>this->maxHoursContinuously){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint teachers activity tag %1 max %2 hours continuously broken for teacher %3, on day %4, length=%5.")
							 .arg(this->activityTagName)
							 .arg(CustomFETString::number(this->maxHoursContinuously))
							 .arg(r.internalTeachersList[i]->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(nc)
							 )
							 +
							 " "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
				
							*conflictsString+= s+"\n";
						}
					}
				
					nc=0;
				}
			}

			if(nc>this->maxHoursContinuously){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teachers activity tag %1 max %2 hours continuously broken for teacher %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursContinuously))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nc)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersActivityTagMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
ConstraintTeacherActivityTagMaxHoursContinuously::ConstraintTeacherActivityTagMaxHoursContinuously()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
}

ConstraintTeacherActivityTagMaxHoursContinuously::ConstraintTeacherActivityTagMaxHoursContinuously(double wp, int maxhours, const QString& teacher, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursContinuously=maxhours;
	this->teacherName=teacher;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	this->canonicalTeachersList.clear();
	int i=this->teacher_ID;
	bool found=false;
	
	Teacher* tch=r.internalTeachersList[i];
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
			found=true;
			break;
		}
	}
		
	if(found)
		this->canonicalTeachersList.append(i);

	return true;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherActivityTagMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherActivityTagMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherActivityTagMaxHoursContinuously>\n";
	return s;
}

QString ConstraintTeacherActivityTagMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher %1 for activity tag %2 has max %3 hours continuously").arg(this->teacherName).arg(this->activityTagName).arg(this->maxHoursContinuously);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeacherActivityTagMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher for an activity tag must respect the maximum number of hours continuously");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherActivityTagMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			int nc=0;
			for(int h=0; h<r.nHoursPerDay; h++){
				bool inc=false;

				if(crtTeacherTimetableActivityTag[d][h]==this->activityTagIndex)
					inc=true;
				
				if(inc)
					nc++;
				else{
					if(nc>this->maxHoursContinuously){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint teacher activity tag max %1 hours continuously broken for teacher %2, activity tag %3, on day %4, length=%5.")
							 .arg(CustomFETString::number(this->maxHoursContinuously))
							 .arg(r.internalTeachersList[i]->name)
							 .arg(this->activityTagName)
							 .arg(r.daysOfTheWeek[d])
							 .arg(nc)
							 )
							 +
							 " "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
				
							*conflictsString+= s+"\n";
						}
					}
				
					nc=0;
				}
			}

			if(nc>this->maxHoursContinuously){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher activity tag max %1 hours continuously broken for teacher %2, activity tag %3, on day %4, length=%5.")
					 .arg(CustomFETString::number(this->maxHoursContinuously))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(this->activityTagName)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nc)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	return this->activityTagName==s->name;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherActivityTagMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxDaysPerWeek::ConstraintTeacherMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_DAYS_PER_WEEK;
}

ConstraintTeacherMaxDaysPerWeek::ConstraintTeacherMaxDaysPerWeek(double wp, int maxnd, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHER_MAX_DAYS_PER_WEEK;
}

bool ConstraintTeacherMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeacherMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teacher max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MD:%1", "Max days (per week)").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	Matrix1D<int> nd;
	nd.resize(r.nHoursPerDay+1);

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}

		if(nbroken>0){
			QString s= tr("Time constraint teacher max days per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			
			dl.append(s);
			cl.append(nbroken*weightPercentage/100);
		
			*conflictsString += s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintTeacherMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxDaysPerWeek>r.nDaysPerWeek)
		maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxDaysPerWeek::ConstraintTeachersMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_DAYS_PER_WEEK;
}

ConstraintTeachersMaxDaysPerWeek::ConstraintTeachersMaxDaysPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHERS_MAX_DAYS_PER_WEEK;
}

bool ConstraintTeachersMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeachersMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teachers max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MD:%1", "Max days (per week)").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	Matrix1D<int> nd;
	nd.resize(r.nHoursPerDay+1);

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		
		for(int t=0; t<r.nInternalTeachers; t++){
			for(int h=0; h<=r.nHoursPerDay; h++)
				nd[h]=0;
			for(int d=0; d<r.nDaysPerWeek; d++){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
				nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						break;
					}
				}
			}
		
		}
	}
	//with logging
	else{
		nbroken=0;

		for(int t=0; t<r.nInternalTeachers; t++){
			int nbr=0;

			//count sort
			for(int h=0; h<=r.nHoursPerDay; h++)
				nd[h]=0;
			for(int d=0; d<r.nDaysPerWeek; d++){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
				nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
						nbr+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						nbr+=i*k;
						break;
					}
				}
			}

			if(nbr>0){
				QString s= tr("Time constraint teachers max days per week broken for teacher: %1.")
				.arg(r.internalTeachersList[t]->name);
				s += tr("This increases the conflicts total by %1")
				.arg(CustomFETString::numberPlusTwoDigitsPrecision(nbr*weightPercentage/100));
				
				dl.append(s);
				cl.append(nbr*weightPercentage/100);
			
				*conflictsString += s+"\n";
			}
		
		}
		
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintTeachersMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxDaysPerWeek>r.nDaysPerWeek)
		maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxGapsPerWeek::ConstraintTeachersMaxGapsPerWeek()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK;
}

ConstraintTeachersMaxGapsPerWeek::ConstraintTeachersMaxGapsPerWeek(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK;
	this->maxGaps=mg;
}

bool ConstraintTeachersMaxGapsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintTeachersMaxGapsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxGapsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxGapsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxGapsPerWeek>\n";
	return s;
}

QString ConstraintTeachersMaxGapsPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers max gaps per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeachersMaxGapsPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of gaps per week");s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per week=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxGapsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);
		
		c.changedForMatrixCalculation=false;
	}
	
	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;
	for(i=0; i<r.nInternalTeachers; i++){
		tg=0;
		for(j=0; j<r.nDaysPerWeek; j++){
			for(k=0; k<r.nHoursPerDay; k++)
				if(teachersMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
					break;
				}

			int cnt=0;
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
				if(teachersMatrix[i][j][k]>0){
					tg+=cnt;
					cnt=0;
				}
				else
					cnt++;
			}
		}
		if(tg>this->maxGaps){
			totalGaps+=tg-maxGaps;
			//assert(this->weightPercentage<100); partial solutions might break this rule
			if(conflictsString!=nullptr){
				QString s=tr("Time constraint teachers max gaps per week broken for teacher: %1, conflicts factor increase=%2")
					.arg(r.internalTeachersList[i]->name)
					.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));
					
				*conflictsString+= s+"\n";
				
				dl.append(s);
				cl.append((tg-maxGaps)*weightPercentage/100);
			}
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100){
			assert(totalGaps==0); //for partial solutions this rule might be broken
		}
	
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeachersMaxGapsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxGapsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersMaxGapsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxGapsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxGapsPerWeek::ConstraintTeacherMaxGapsPerWeek()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK;
}

ConstraintTeacherMaxGapsPerWeek::ConstraintTeacherMaxGapsPerWeek(double wp, const QString& tn, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK;
	this->teacherName=tn;
	this->maxGaps=mg;
}

bool ConstraintTeacherMaxGapsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacherIndex=r.searchTeacher(this->teacherName);
	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);
	return true;
}

bool ConstraintTeacherMaxGapsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxGapsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxGapsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxGapsPerWeek>\n";
	return s;
}

QString ConstraintTeacherMaxGapsPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher max gaps per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeacherMaxGapsPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("A teacher must respect the maximum number of gaps per week"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";
	s+=tr("Maximum gaps per week=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxGapsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;
		
	i=this->teacherIndex;
	
	tg=0;
	for(j=0; j<r.nDaysPerWeek; j++){
		for(k=0; k<r.nHoursPerDay; k++)
			if(teachersMatrix[i][j][k]>0){
				assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
				break;
			}

		int cnt=0;
		for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
			if(teachersMatrix[i][j][k]>0){
				tg+=cnt;
				cnt=0;
			}
			else
				cnt++;
		}
	}
	if(tg>this->maxGaps){
		totalGaps+=tg-maxGaps;
		//assert(this->weightPercentage<100); partial solutions might break this rule
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint teacher max gaps per week broken for teacher: %1, conflicts factor increase=%2")
				.arg(r.internalTeachersList[i]->name)
				.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));
					
			*conflictsString+= s+"\n";
						
			dl.append(s);
			cl.append((tg-maxGaps)*weightPercentage/100);
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeacherMaxGapsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxGapsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherMaxGapsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxGapsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxGapsPerDay::ConstraintTeachersMaxGapsPerDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_DAY;
}

ConstraintTeachersMaxGapsPerDay::ConstraintTeachersMaxGapsPerDay(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_DAY;
	this->maxGaps=mg;
}

bool ConstraintTeachersMaxGapsPerDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintTeachersMaxGapsPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxGapsPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxGapsPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxGapsPerDay>\n";
	return s;
}

QString ConstraintTeachersMaxGapsPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers max gaps per day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per day)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeachersMaxGapsPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum gaps per day");s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per day=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxGapsPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;
	for(i=0; i<r.nInternalTeachers; i++){
		for(j=0; j<r.nDaysPerWeek; j++){
			tg=0;
			for(k=0; k<r.nHoursPerDay; k++)
				if(teachersMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
					break;
				}

			int cnt=0;
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
				if(teachersMatrix[i][j][k]>0){
					tg+=cnt;
					cnt=0;
				}
				else
					cnt++;
			}
			if(tg>this->maxGaps){
				totalGaps+=tg-maxGaps;
				//assert(this->weightPercentage<100); partial solutions might break this rule
				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teachers max gaps per day broken for teacher: %1, day: %2, conflicts factor increase=%3")
						.arg(r.internalTeachersList[i]->name)
						.arg(r.daysOfTheWeek[j])
						.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));
					
					*conflictsString+= s+"\n";
					
					dl.append(s);
					cl.append((tg-maxGaps)*weightPercentage/100);
				}
			}
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeachersMaxGapsPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxGapsPerDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxGapsPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersMaxGapsPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxGapsPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nHoursPerDay)
		maxGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxGapsPerDay::ConstraintTeacherMaxGapsPerDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_DAY;
}

ConstraintTeacherMaxGapsPerDay::ConstraintTeacherMaxGapsPerDay(double wp, const QString& tn, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_DAY;
	this->teacherName=tn;
	this->maxGaps=mg;
}

bool ConstraintTeacherMaxGapsPerDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacherIndex=r.searchTeacher(this->teacherName);
	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);
	return true;
}

bool ConstraintTeacherMaxGapsPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxGapsPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxGapsPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxGapsPerDay>\n";
	return s;
}

QString ConstraintTeacherMaxGapsPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher max gaps per day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per day)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeacherMaxGapsPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("A teacher must respect the maximum number of gaps per day"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";
	s+=tr("Maximum gaps per day=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxGapsPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;
	
	i=this->teacherIndex;
	
	for(j=0; j<r.nDaysPerWeek; j++){
		tg=0;
		for(k=0; k<r.nHoursPerDay; k++)
			if(teachersMatrix[i][j][k]>0){
				assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
				break;
			}

		int cnt=0;
		for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
			if(teachersMatrix[i][j][k]>0){
				tg+=cnt;
				cnt=0;
			}
			else
				cnt++;
		}
		if(tg>this->maxGaps){
			totalGaps+=tg-maxGaps;
			//assert(this->weightPercentage<100); partial solutions might break this rule
			if(conflictsString!=nullptr){
				QString s=tr("Time constraint teacher max gaps per day broken for teacher: %1, day: %2, conflicts factor increase=%3")
					.arg(r.internalTeachersList[i]->name)
					.arg(r.daysOfTheWeek[j])
					.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));
				
				*conflictsString+= s+"\n";
				
				dl.append(s);
				cl.append((tg-maxGaps)*weightPercentage/100);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeacherMaxGapsPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxGapsPerDay::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxGapsPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherMaxGapsPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxGapsPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nHoursPerDay)
		maxGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxGapsPerMorningAndAfternoon::ConstraintTeachersMaxGapsPerMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_MORNING_AND_AFTERNOON;
}

ConstraintTeachersMaxGapsPerMorningAndAfternoon::ConstraintTeachersMaxGapsPerMorningAndAfternoon(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_MORNING_AND_AFTERNOON;
	this->maxGaps=mg;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxGapsPerMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxGapsPerMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxGapsPerMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeachersMaxGapsPerMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers max gaps per morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per morning and afternoon)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeachersMaxGapsPerMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum gaps per morning and afternoon");s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per morning and afternoon=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxGapsPerMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;
	for(i=0; i<r.nInternalTeachers; i++){
		for(j=0; j<r.nDaysPerWeek/2; j++){
			tg=0;
			for(k=0; k<r.nHoursPerDay; k++)
				if(teachersMatrix[i][2*j][k]>0){
					assert(!breakDayHour[2*j][k] && !teacherNotAvailableDayHour[i][2*j][k]);
					break;
				}

			int cnt=0;
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[2*j][k] && !teacherNotAvailableDayHour[i][2*j][k]){
				if(teachersMatrix[i][2*j][k]>0){
					tg+=cnt;
					cnt=0;
				}
				else
					cnt++;
			}

			for(k=0; k<r.nHoursPerDay; k++)
				if(teachersMatrix[i][2*j+1][k]>0){
					assert(!breakDayHour[2*j+1][k] && !teacherNotAvailableDayHour[i][2*j+1][k]);
					break;
				}

			cnt=0;
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[2*j+1][k] && !teacherNotAvailableDayHour[i][2*j+1][k]){
				if(teachersMatrix[i][2*j+1][k]>0){
					tg+=cnt;
					cnt=0;
				}
				else
					cnt++;
			}

			if(tg>this->maxGaps){
				totalGaps+=tg-maxGaps;
				//assert(this->weightPercentage<100); partial solutions might break this rule
				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teachers max gaps per morning and afternoon broken for teacher: %1, real day number: %2, conflicts factor increase=%3")
						.arg(r.internalTeachersList[i]->name)
						.arg(j)
						.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));
					
					*conflictsString+= s+"\n";
					
					dl.append(s);
					cl.append((tg-maxGaps)*weightPercentage/100);
				}
			}
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>2*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxGapsPerMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>2*r.nHoursPerDay)
		maxGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxGapsPerMorningAndAfternoon::ConstraintTeacherMaxGapsPerMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_MORNING_AND_AFTERNOON;
}

ConstraintTeacherMaxGapsPerMorningAndAfternoon::ConstraintTeacherMaxGapsPerMorningAndAfternoon(double wp, const QString& tn, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_MORNING_AND_AFTERNOON;
	this->teacherName=tn;
	this->maxGaps=mg;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacherIndex=r.searchTeacher(this->teacherName);
	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);
	return true;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxGapsPerMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxGapsPerMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxGapsPerMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeacherMaxGapsPerMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher max gaps per morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per morning and afternoon)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeacherMaxGapsPerMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("A teacher must respect the maximum number of gaps per morning and afternoon"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";
	s+=tr("Maximum gaps per morning and afternoon=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxGapsPerMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;
	
	i=this->teacherIndex;
	
	for(j=0; j<r.nDaysPerWeek/2; j++){
		tg=0;
		for(k=0; k<r.nHoursPerDay; k++)
			if(teachersMatrix[i][2*j][k]>0){
				assert(!breakDayHour[2*j][k] && !teacherNotAvailableDayHour[i][2*j][k]);
				break;
			}

		int cnt=0;
		for(; k<r.nHoursPerDay; k++) if(!breakDayHour[2*j][k] && !teacherNotAvailableDayHour[i][2*j][k]){
			if(teachersMatrix[i][2*j][k]>0){
				tg+=cnt;
				cnt=0;
			}
			else
				cnt++;
		}
		
		for(k=0; k<r.nHoursPerDay; k++)
			if(teachersMatrix[i][2*j+1][k]>0){
				assert(!breakDayHour[2*j+1][k] && !teacherNotAvailableDayHour[i][2*j+1][k]);
				break;
			}

		cnt=0;
		for(; k<r.nHoursPerDay; k++) if(!breakDayHour[2*j+1][k] && !teacherNotAvailableDayHour[i][2*j+1][k]){
			if(teachersMatrix[i][2*j+1][k]>0){
				tg+=cnt;
				cnt=0;
			}
			else
				cnt++;
		}
		
		if(tg>this->maxGaps){
			totalGaps+=tg-maxGaps;
			//assert(this->weightPercentage<100); partial solutions might break this rule
			if(conflictsString!=nullptr){
				QString s=tr("Time constraint teacher max gaps per morning and afternoon broken for teacher: %1, real day number: %2, conflicts factor increase=%3")
					.arg(r.internalTeachersList[i]->name)
					.arg(j)
					.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));
				
				*conflictsString+= s+"\n";
				
				dl.append(s);
				cl.append((tg-maxGaps)*weightPercentage/100);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>2*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxGapsPerMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>2*r.nHoursPerDay)
		maxGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintBreakTimes::ConstraintBreakTimes()
	: TimeConstraint()
{
	this->type = CONSTRAINT_BREAK_TIMES;
}

ConstraintBreakTimes::ConstraintBreakTimes(double wp, const QList<int>& d, const QList<int>& h)
	: TimeConstraint(wp)
{
	this->days = d;
	this->hours = h;
	this->type = CONSTRAINT_BREAK_TIMES;
}

bool ConstraintBreakTimes::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintBreakTimes::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintBreakTimes>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Break_Times>"+QString::number(this->days.count())+"</Number_of_Break_Times>\n";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		s+=IL3+"<Break_Time>\n";
		if(this->days.at(i)>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->days.at(i)])+"</Day>\n";
		if(this->hours.at(i)>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hours.at(i)])+"</Hour>\n";
		s+=IL3+"</Break_Time>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintBreakTimes>\n";
	return s;
}

QString ConstraintBreakTimes::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Break times");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("B at:", "Break at");
	s+=" ";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		if(this->days.at(i)>=0){
			s+=r.daysOfTheWeek[this->days.at(i)];
			s+=" ";
		}
		if(this->hours.at(i)>=0){
			s+=r.hoursOfTheDay[this->hours.at(i)];
		}
		if(i<days.count()-1)
			s+=translatedSemicolonSpace();
	}
	
	return begin+s+end;
}

QString ConstraintBreakTimes::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Break times");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Break at:"); s+="\n";
	assert(days.count()==hours.count());
	for(int i=0; i<days.count(); i++){
		if(this->days.at(i)>=0){
			s+=r.daysOfTheWeek[this->days.at(i)];
			s+=" ";
		}
		if(this->hours.at(i)>=0){
			s+=r.hoursOfTheDay[this->hours.at(i)];
		}
		if(i<days.count()-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

bool ConstraintBreakTimes::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(r);
	
	assert(days.count()==hours.count());
	for(int k=0; k<days.count(); k++){
		if(this->days.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint break times is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours.at(k) >= r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint break times is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}

	return true;
}

double ConstraintBreakTimes::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	//DEPRECATED COMMENT
	//For the moment, this function sums the number of hours each teacher
	//is teaching in this break period.
	//This function consideres all the hours, I mean if there are for example 5 weekly courses
	//scheduled on that hour (which is already a broken hard restriction - we only
	//are allowed 1 weekly course for a certain teacher at a certain hour) we calculate
	//5 broken restrictions for this break period.
	//TODO: decide if it is better to consider only 2 or 10 as a return value in this particular case
	//(currently it is 10)
	
	int nbroken;
	
	nbroken=0;
		
	for(int i=0; i<r.nInternalActivities; i++){
		int dayact=c.times[i]%r.nDaysPerWeek;
		int houract=c.times[i]/r.nDaysPerWeek;
		
		assert(days.count()==hours.count());
		for(int kk=0; kk<days.count(); kk++){
			int d=days.at(kk);
			int h=hours.at(kk);
			
			int dur=r.internalActivitiesList[i].duration;
			if(d==dayact && !(houract+dur<=h || houract>h))
			{			
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint break not respected for activity with id %1, on day %2, hour %3")
						.arg(r.internalActivitiesList[i].id)
						.arg(r.daysOfTheWeek[dayact])
						.arg(r.hoursOfTheDay[houract]);
					s+=". ";
					s+=tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintBreakTimes::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintBreakTimes::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintBreakTimes::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintBreakTimes::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintBreakTimes::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintBreakTimes::hasWrongDayOrHour(Rules& r)
{
	assert(days.count()==hours.count());
	
	for(int i=0; i<days.count(); i++)
		if(days.at(i)<0 || days.at(i)>=r.nDaysPerWeek
		 || hours.at(i)<0 || hours.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintBreakTimes::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintBreakTimes::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(days.count()==hours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<days.count(); i++)
		if(days.at(i)>=0 && days.at(i)<r.nDaysPerWeek
		 && hours.at(i)>=0 && hours.at(i)<r.nHoursPerDay){
			newDays.append(days.at(i));
			newHours.append(hours.at(i));
		}
	
	days=newDays;
	hours=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxGapsPerWeek::ConstraintStudentsMaxGapsPerWeek()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK;
}

ConstraintStudentsMaxGapsPerWeek::ConstraintStudentsMaxGapsPerWeek(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK;
	this->maxGaps=mg;
}

bool ConstraintStudentsMaxGapsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintStudentsMaxGapsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxGapsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxGapsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxGapsPerWeek>\n";
	return s;
}

QString ConstraintStudentsMaxGapsPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students max gaps per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintStudentsMaxGapsPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of gaps per week");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per week=%1").arg(this->maxGaps);s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxGapsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);
		
		c.changedForMatrixCalculation=false;
	}

	int nGaps;
	int tmp;
	int i;
	
	int tIllegalGaps=0;

	for(i=0; i<r.nInternalSubgroups; i++){
		nGaps=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			int k;
			tmp=0;
			for(k=0; k<r.nHoursPerDay; k++)
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
				if(subgroupsMatrix[i][j][k]>0){
					nGaps+=tmp;
					tmp=0;
				}
				else
					tmp++;
			}
		}
		
		int illegalGaps=nGaps-this->maxGaps;
		if(illegalGaps<0)
			illegalGaps=0;

		if(illegalGaps>0 && conflictsString!=nullptr){
			QString s=tr("Time constraint students max gaps per week broken for subgroup: %1, it has %2 extra gaps, conflicts increase=%3")
			 .arg(r.internalSubgroupsList[i]->name)
			 .arg(illegalGaps)
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(illegalGaps*weightPercentage/100));
			
			dl.append(s);
			cl.append(illegalGaps*weightPercentage/100);
			
			*conflictsString+= s+"\n";
		}
		
		tIllegalGaps+=illegalGaps;
	}
		
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsMaxGapsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxGapsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsMaxGapsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMaxGapsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxGapsPerWeek::ConstraintStudentsSetMaxGapsPerWeek()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK;
}

ConstraintStudentsSetMaxGapsPerWeek::ConstraintStudentsSetMaxGapsPerWeek(double wp, int mg, const QString& st )
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK;
	this->maxGaps=mg;
	this->students = st;
}

bool ConstraintStudentsSetMaxGapsPerWeek::computeInternalStructure(QWidget* parent, Rules& r){
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max gaps per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

bool ConstraintStudentsSetMaxGapsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxGapsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxGapsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxGapsPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMaxGapsPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set max gaps per week"); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage)); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week)").arg(this->maxGaps);s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxGapsPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of gaps per week");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per week=%1").arg(this->maxGaps);s+="\n";
	s+=tr("Students=%1").arg(this->students); s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintStudentsSetMaxGapsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//OLD COMMENT
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nGaps;
	int tmp;
	
	int tIllegalGaps=0;
	
	for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
		nGaps=0;
		int i=this->iSubgroupsList.at(sg);
		for(int j=0; j<r.nDaysPerWeek; j++){
			int k;
			tmp=0;
			for(k=0; k<r.nHoursPerDay; k++)
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
				if(subgroupsMatrix[i][j][k]>0){
					nGaps+=tmp;
					tmp=0;
				}
				else
					tmp++;
			}
		}
		
		int illegalGaps=nGaps-this->maxGaps;
		if(illegalGaps<0)
			illegalGaps=0;

		if(illegalGaps>0 && conflictsString!=nullptr){
			QString s=tr("Time constraint students set max gaps per week broken for subgroup: %1, extra gaps=%2, conflicts increase=%3")
			 .arg(r.internalSubgroupsList[i]->name)
			 .arg(illegalGaps)
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*illegalGaps));
			
			dl.append(s);
			cl.append(weightPercentage/100*illegalGaps);
			
			*conflictsString+= s+"\n";
		}
		
		tIllegalGaps+=illegalGaps;
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)     //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsSetMaxGapsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxGapsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMaxGapsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintStudentsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintStudentsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students must begin early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must begin their activities early, respecting maximum %1 later beginnings, at second hour")
	 .arg(this->maxBeginningsAtSecondHour);s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int conflTotal=0;
	
	for(int i=0; i<r.nInternalSubgroups; i++){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k])
					break;
			
			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(subgroupsMatrix[i][j][k]>0)
					firstHourOccupied=true;
			
			bool dayOccupied=firstHourOccupied;
			
			bool illegalGap=false;
			
			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
						if(subgroupsMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}
			
			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint students early max %1 beginnings at second hour broken for subgroup %2, on day %3,"
					 " because students have an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
					
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
					
					conflTotal+=1;
				}
				
				if(c.nPlacedActivities==r.nInternalActivities){
					assert(0);
				}
			}
			
			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}
		
		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint students early max %1 beginnings at second hour broken for subgroup %2,"
				 " because students have too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));
				
				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);
				
				*conflictsString+= s+"\n";
				
				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}
			
			if(c.nPlacedActivities==r.nInternalActivities){
				assert(0);
			}
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek)
		maxBeginningsAtSecondHour=r.nDaysPerWeek;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour(double wp, int mBSH, const QString& students)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->students=students;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set early is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
	return true;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;

	s+=tr("Students set must begin early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students set").arg(this->students);

	return begin+s+end;
}

QString ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";

	s+=tr("A students set must begin its activities early, respecting a maximum number of later beginnings, at second hour"); s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students); s+="\n";
	s+=tr("Maximum number of beginnings at the second hour=%1").arg(this->maxBeginningsAtSecondHour);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int conflTotal=0;

	for(int i : std::as_const(this->iSubgroupsList)){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k])
					break;
			
			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(subgroupsMatrix[i][j][k]>0)
					firstHourOccupied=true;
			
			bool dayOccupied=firstHourOccupied;
			
			bool illegalGap=false;
			
			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
						if(subgroupsMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}
			
			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint students set early max %1 beginnings at second hour broken for subgroup %2, on day %3,"
					 " because students have an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
					
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
					
					conflTotal+=1;
				}
				
				if(c.nPlacedActivities==r.nInternalActivities)
					assert(0);
			}
			
			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}
		
		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint students set early max %1 beginnings at second hour broken for subgroup %2,"
				 " because students have too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));
				
				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);
				
				*conflictsString+= s+"\n";
				
				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}
			
			if(c.nPlacedActivities==r.nInternalActivities)
				assert(0);
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek)
		maxBeginningsAtSecondHour=r.nDaysPerWeek;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxHoursDaily::ConstraintStudentsMaxHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_DAILY;
	this->maxHoursDaily = -1;
}

ConstraintStudentsMaxHoursDaily::ConstraintStudentsMaxHoursDaily(double wp, int maxnh)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_DAILY;
}

bool ConstraintStudentsMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintStudentsMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	if(this->maxHoursDaily>=0)
		s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	else
		assert(0);
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxHoursDaily>\n";
	return s;
}

QString ConstraintStudentsMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students max hours daily");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MH:%1", "Max hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintStudentsMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp;
	int too_much;
	
	assert(this->maxHoursDaily>=0);

	if(true){
		too_much=0;
		for(int i=0; i<r.nInternalSubgroups; i++)
			for(int j=0; j<r.nDaysPerWeek; j++){
				tmp=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					//OLD COMMENT
					//Here we want to see if we have a weekly activity or a 2 weeks activity
					//We don't do tmp+=subgroupsMatrix[i][j][k] because we already counted this as a hard hitness
					if(subgroupsMatrix[i][j][k]>=1)
						tmp++;
				}
				if(this->maxHoursDaily>=0 && tmp > this->maxHoursDaily){ //we would like no more than maxHoursDaily hours per day.
					too_much += 1; //tmp - this->maxHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students max hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[j])
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*1));
						
						dl.append(s);
						cl.append(weightPercentage/100*1);
					
						*conflictsString+= s+"\n";
					}
				}
			}
	}

	assert(too_much>=0);
	if(weightPercentage==100)
		assert(too_much==0);
	return too_much * weightPercentage/100;
}

bool ConstraintStudentsMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxHoursDaily::ConstraintStudentsSetMaxHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY;
	this->maxHoursDaily = -1;
}

ConstraintStudentsSetMaxHoursDaily::ConstraintStudentsSetMaxHoursDaily(double wp, int maxnh, const QString& s)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->students = s;
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY;
}

bool ConstraintStudentsSetMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxHoursDaily>\n";
	return s;
}

QString ConstraintStudentsSetMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set max hours daily");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students); s+=translatedCommaSpace();
	s+=tr("MH:%1", "Max hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours daily is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

double ConstraintStudentsSetMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp;
	int too_much;

	assert(this->maxHoursDaily>=0);

	if(true){
		too_much=0;
		for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
			int i=iSubgroupsList.at(sg);
			for(int j=0; j<r.nDaysPerWeek; j++){
				tmp=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					//Here we want to see if we have a weekly activity or a 2 weeks activity
					//We don't do tmp+=subgroupsMatrix[i][j][k] because we already counted this as a hard hitness
					if(subgroupsMatrix[i][j][k]>=1)
						tmp++;
				}
				if(this->maxHoursDaily>=0 && tmp > this->maxHoursDaily){ //we would like no more than max_hours_daily hours per day.
					too_much += 1; //tmp - this->maxHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set max hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[j])
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision( 1 *weightPercentage/100));
						
						dl.append(s);
						cl.append( 1 *weightPercentage/100);
					
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}
	
	assert(too_much>=0);
	if(weightPercentage==100)
		assert(too_much==0);
	return too_much * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxHoursContinuously::ConstraintStudentsMaxHoursContinuously()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_CONTINUOUSLY;
	this->maxHoursContinuously = -1;
}

ConstraintStudentsMaxHoursContinuously::ConstraintStudentsMaxHoursContinuously(double wp, int maxnh)
	: TimeConstraint(wp)
{
	this->maxHoursContinuously = maxnh;
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintStudentsMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintStudentsMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	if(this->maxHoursContinuously>=0)
		s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	else
		assert(0);
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxHoursContinuously>\n";
	return s;
}

QString ConstraintStudentsMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students max hours continuously");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MH:%1", "Max hours (continuously)").arg(this->maxHoursContinuously);

	return begin+s+end;
}

QString ConstraintStudentsMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of hours continuously");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken;

	nbroken=0;
	for(int i=0; i<r.nInternalSubgroups; i++){
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nc=0;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[i][d][h]>0)
					nc++;
				else{
					if(nc>this->maxHoursContinuously){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint students max %1 hours continuously broken for subgroup %2, on day %3, length=%4.")
							 .arg(CustomFETString::number(this->maxHoursContinuously))
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(nc)
							 )
							 +
							 " "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
				
							*conflictsString+= s+"\n";
						}
					}
				
					nc=0;
				}
			}

			if(nc>this->maxHoursContinuously){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students max %1 hours continuously broken for subgroup %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->maxHoursContinuously))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nc)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxHoursContinuously::ConstraintStudentsSetMaxHoursContinuously()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_CONTINUOUSLY;
	this->maxHoursContinuously = -1;
}

ConstraintStudentsSetMaxHoursContinuously::ConstraintStudentsSetMaxHoursContinuously(double wp, int maxnh, const QString& s)
	: TimeConstraint(wp)
{
	this->maxHoursContinuously = maxnh;
	this->students = s;
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintStudentsSetMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxHoursContinuously>\n";
	return s;
}

QString ConstraintStudentsSetMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set max hours continuously");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MH:%1", "Max hours (continuously)").arg(this->maxHoursContinuously);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of hours continuously");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours continuously is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

double ConstraintStudentsSetMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	for(int i : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nc=0;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[i][d][h]>0)
					nc++;
				else{
					if(nc>this->maxHoursContinuously){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint students set max %1 hours continuously broken for subgroup %2, on day %3, length=%4.")
							 .arg(CustomFETString::number(this->maxHoursContinuously))
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(nc)
							 )
							 +
							 " "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
				
							*conflictsString+= s+"\n";
						}
					}
				
					nc=0;
				}
			}

			if(nc>this->maxHoursContinuously){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students set max %1 hours continuously broken for subgroup %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->maxHoursContinuously))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nc)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsSetMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsActivityTagMaxHoursContinuously::ConstraintStudentsActivityTagMaxHoursContinuously()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
	this->maxHoursContinuously = -1;
}

ConstraintStudentsActivityTagMaxHoursContinuously::ConstraintStudentsActivityTagMaxHoursContinuously(double wp, int maxnh, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->maxHoursContinuously = maxnh;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);
	
	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsActivityTagMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsActivityTagMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	
	if(this->maxHoursContinuously>=0)
		s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	else
		assert(0);
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsActivityTagMaxHoursContinuously>\n";
	return s;
}

QString ConstraintStudentsActivityTagMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students for activity tag %1 have max %2 hours continuously")
		.arg(this->activityTagName).arg(this->maxHoursContinuously); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsActivityTagMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students, for an activity tag, must respect the maximum number of hours continuously"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsActivityTagMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);
		
		c.changedForMatrixCalculation=false;
	}
	
	int nbroken;

	nbroken=0;
	
	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	
	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			int nc=0;
			for(int h=0; h<r.nHoursPerDay; h++){
				bool inc=false;
				
				if(crtSubgroupTimetableActivityTag[d][h]==this->activityTagIndex)
					inc=true;
				
				if(inc)
					nc++;
				else{
					if(nc>this->maxHoursContinuously){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint students, activity tag %1, max %2 hours continuously, broken for subgroup %3, on day %4, length=%5.")
							 .arg(this->activityTagName)
							 .arg(CustomFETString::number(this->maxHoursContinuously))
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(nc)
							 )
							 +
							 " "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
				
							*conflictsString+= s+"\n";
						}
					}
				
					nc=0;
				}
			}

			if(nc>this->maxHoursContinuously){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students, activity tag %1, max %2 hours continuously, broken for subgroup %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursContinuously))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nc)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsActivityTagMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetActivityTagMaxHoursContinuously::ConstraintStudentsSetActivityTagMaxHoursContinuously()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
	this->maxHoursContinuously = -1;
}

ConstraintStudentsSetActivityTagMaxHoursContinuously::ConstraintStudentsSetActivityTagMaxHoursContinuously(double wp, int maxnh, const QString& s, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->maxHoursContinuously = maxnh;
	this->students = s;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_CONTINUOUSLY;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetActivityTagMaxHoursContinuously::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetActivityTagMaxHoursContinuously>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Continuously>"+CustomFETString::number(this->maxHoursContinuously)+"</Maximum_Hours_Continuously>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetActivityTagMaxHoursContinuously>\n";
	return s;
}

QString ConstraintStudentsSetActivityTagMaxHoursContinuously::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set %1 for activity tag %2 has max %3 hours continuously").arg(this->students).arg(this->activityTagName).arg(this->maxHoursContinuously);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsSetActivityTagMaxHoursContinuously::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set, for an activity tag, must respect the maximum number of hours continuously"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours continuously=%1").arg(this->maxHoursContinuously);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours continuously is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(this->iSubgroupsList)){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}
		
	return true;
}

double ConstraintStudentsSetActivityTagMaxHoursContinuously::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			int nc=0;
			for(int h=0; h<r.nHoursPerDay; h++){
				bool inc=false;
				
				if(crtSubgroupTimetableActivityTag[d][h]==this->activityTagIndex)
					inc=true;
			
				if(inc)
					nc++;
				else{
					if(nc>this->maxHoursContinuously){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint students set max %1 hours continuously broken for subgroup %2, on day %3, length=%4.")
							 .arg(CustomFETString::number(this->maxHoursContinuously))
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(nc)
							 )
							 +
							 " "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
				
							*conflictsString+= s+"\n";
						}
					}
				
					nc=0;
				}
			}

			if(nc>this->maxHoursContinuously){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students set max %1 hours continuously broken for subgroup %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->maxHoursContinuously))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nc)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursContinuously>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetActivityTagMaxHoursContinuously::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursContinuously>r.nHoursPerDay)
		maxHoursContinuously=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinHoursDaily::ConstraintStudentsMinHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_HOURS_DAILY;
	this->minHoursDaily = -1;
	
	this->allowEmptyDays=false;
}

ConstraintStudentsMinHoursDaily::ConstraintStudentsMinHoursDaily(double wp, int minnh, bool _allowEmptyDays)
	: TimeConstraint(wp)
{
	this->minHoursDaily = minnh;
	this->type = CONSTRAINT_STUDENTS_MIN_HOURS_DAILY;
	
	this->allowEmptyDays=_allowEmptyDays;
}

bool ConstraintStudentsMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

bool ConstraintStudentsMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	if(this->minHoursDaily>=0)
		s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	else
		assert(0);
	if(this->allowEmptyDays)
		s+=IL3+"<Allow_Empty_Days>true</Allow_Empty_Days>\n";
	else
		s+=IL3+"<Allow_Empty_Days>false</Allow_Empty_Days>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinHoursDaily>\n";
	return s;
}

QString ConstraintStudentsMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;

	s+=tr("Students min hours daily");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (daily)").arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("AED:%1", "Allow empty days").arg(yesNoTranslated(this->allowEmptyDays));

	return begin+s+end;
}

QString ConstraintStudentsMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Allow empty days=%1").arg(yesNoTranslated(this->allowEmptyDays));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	if(r.mode!=MORNINGS_AFTERNOONS){
		int tmp;
		int too_little;

		assert(this->minHoursDaily>=0);

		too_little=0;
		for(int i=0; i<r.nInternalSubgroups; i++)
			for(int j=0; j<r.nDaysPerWeek; j++){
				tmp=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][j][k]>=1)
						tmp++;
				}

				bool searchDay;
				if(this->allowEmptyDays==true)
					searchDay=(tmp>0);
				else
					searchDay=true;

				if(/*tmp>0*/ searchDay && this->minHoursDaily>=0 && tmp < this->minHoursDaily){ //we would like no less than minHoursDaily hours per day.
					too_little += - tmp + this->minHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[j])
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp+this->minHoursDaily)));

						dl.append(s);
						cl.append(weightPercentage/100*(-tmp+this->minHoursDaily));

						*conflictsString+= s+"\n";
					}
				}
			}

		//should not consider for empty days

		assert(too_little>=0);

		if(c.nPlacedActivities==r.nInternalActivities)
			if(weightPercentage==100) //does not work for partial solutions
				assert(too_little==0);

		return too_little * weightPercentage/100;
	}
	else{
		int tmp1, tmp2;
		int too_little;

		assert(this->minHoursDaily>=0);

		too_little=0;
		for(int i=0; i<r.nInternalSubgroups; i++)
			for(int j=0; j<r.nDaysPerWeek/2; j++){
				tmp1=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j][k]>=1)
						tmp1++;
				}

				if(tmp1>0 && tmp1<this->minHoursDaily){
					too_little += - tmp1 + this->minHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j])
						 .arg(CustomFETString::number(tmp1))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp1+this->minHoursDaily)));

						dl.append(s);
						cl.append(weightPercentage/100*(-tmp1+this->minHoursDaily));

						*conflictsString+= s+"\n";
					}
				}

				tmp2=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j+1][k]>=1)
						tmp2++;
				}

				if(tmp2>0 && tmp2<this->minHoursDaily){
					too_little += - tmp2 + this->minHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j+1])
						 .arg(CustomFETString::number(tmp2))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp2+this->minHoursDaily)));

						dl.append(s);
						cl.append(weightPercentage/100*(-tmp2+this->minHoursDaily));

						*conflictsString+= s+"\n";
					}
				}

				if(!this->allowEmptyDays==true)
					if(tmp1+tmp2==0){
						too_little++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students min hours daily broken for subgroup: %1, real day: %2, empty real day, but"
							 " the constraint does not allow empty real days, conflicts increase=%3")
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(j)
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(1)));

							dl.append(s);
							cl.append(weightPercentage/100*1);

							*conflictsString+= s+"\n";
						}
					}
			}

		assert(too_little>=0);

		if(c.nPlacedActivities==r.nInternalActivities)
			if(weightPercentage==100) //does not work for partial solutions
				assert(too_little==0);

		return too_little * weightPercentage/100;
	}
}

bool ConstraintStudentsMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinHoursDaily::ConstraintStudentsSetMinHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_HOURS_DAILY;
	this->minHoursDaily = -1;
	
	this->allowEmptyDays=false;
}

ConstraintStudentsSetMinHoursDaily::ConstraintStudentsSetMinHoursDaily(double wp, int minnh, const QString& s, bool _allowEmptyDays)
	: TimeConstraint(wp)
{
	this->minHoursDaily = minnh;
	this->students = s;
	this->type = CONSTRAINT_STUDENTS_SET_MIN_HOURS_DAILY;
	
	this->allowEmptyDays=_allowEmptyDays;
}

bool ConstraintStudentsSetMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	if(this->allowEmptyDays)
		s+=IL3+"<Allow_Empty_Days>true</Allow_Empty_Days>\n";
	else
		s+=IL3+"<Allow_Empty_Days>false</Allow_Empty_Days>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinHoursDaily>\n";
	return s;
}

QString ConstraintStudentsSetMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students set min hours daily");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (daily)").arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("AED:%1", "Allow empty days").arg(yesNoTranslated(this->allowEmptyDays));

	return begin+s+end;
}

QString ConstraintStudentsSetMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Allow empty days=%1").arg(yesNoTranslated(this->allowEmptyDays));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min hours daily is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

double ConstraintStudentsSetMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	if(r.mode!=MORNINGS_AFTERNOONS){
		int tmp;
		int too_little;

		assert(this->minHoursDaily>=0);

		too_little=0;
		for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
			int i=iSubgroupsList.at(sg);
			for(int j=0; j<r.nDaysPerWeek; j++){
				tmp=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][j][k]>=1)
						tmp++;
				}

				bool searchDay;
				if(this->allowEmptyDays==true)
					searchDay=(tmp>0);
				else
					searchDay=true;

				if(/*tmp>0*/ searchDay && this->minHoursDaily>=0 && tmp < this->minHoursDaily){
					too_little += - tmp + this->minHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[j])
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision((-tmp+this->minHoursDaily)*weightPercentage/100));

						dl.append(s);
						cl.append((-tmp+this->minHoursDaily)*weightPercentage/100);

						*conflictsString+= s+"\n";
					}
				}
			}
		}

		assert(too_little>=0);

		if(c.nPlacedActivities==r.nInternalActivities)
			if(weightPercentage==100) //does not work for partial solutions
				assert(too_little==0);

		return too_little * weightPercentage / 100.0;
	}
	else{
		int tmp1, tmp2;
		int too_little;

		assert(this->minHoursDaily>=0);

		too_little=0;
		for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
			int i=iSubgroupsList.at(sg);
			for(int j=0; j<r.nDaysPerWeek/2; j++){
				tmp1=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j][k]>=1)
						tmp1++;
				}

				if(tmp1>0 && tmp1<this->minHoursDaily){
					too_little += - tmp1 + this->minHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j])
						 .arg(CustomFETString::number(tmp1))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp1+this->minHoursDaily)));

						dl.append(s);
						cl.append(weightPercentage/100*(-tmp1+this->minHoursDaily));

						*conflictsString+= s+"\n";
					}
				}

				tmp2=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j+1][k]>=1)
						tmp2++;
				}

				if(tmp2>0 && tmp2<this->minHoursDaily){
					too_little += - tmp2 + this->minHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j+1])
						 .arg(CustomFETString::number(tmp2))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp2+this->minHoursDaily)));

						dl.append(s);
						cl.append(weightPercentage/100*(-tmp2+this->minHoursDaily));

						*conflictsString+= s+"\n";
					}
				}

				if(!this->allowEmptyDays==true)
					if(tmp1+tmp2==0){
						too_little++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students set min hours daily broken for subgroup: %1, real day: %2, empty real day, but"
							 " the constraint does not allow empty real days, conflicts increase=%3")
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(j)
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(1)));

							dl.append(s);
							cl.append(weightPercentage/100*1);

							*conflictsString+= s+"\n";
						}
					}
			}
		}

		assert(too_little>=0);

		if(c.nPlacedActivities==r.nInternalActivities)
			if(weightPercentage==100) //does not work for partial solutions
				assert(too_little==0);

		return too_little * weightPercentage / 100.0;
	}
}

bool ConstraintStudentsSetMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityPreferredStartingTime::ConstraintActivityPreferredStartingTime()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIME;
}

ConstraintActivityPreferredStartingTime::ConstraintActivityPreferredStartingTime(double wp, int actId, int d, int h, bool perm)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->day = d;
	this->hour = h;
	this->type = CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIME;
	this->permanentlyLocked=perm;
}

bool ConstraintActivityPreferredStartingTime::operator==(const ConstraintActivityPreferredStartingTime& c){
	if(this->day!=c.day)
		return false;
	if(this->hour!=c.hour)
		return false;
	if(this->activityId!=c.activityId)
		return false;
	if(this->weightPercentage!=c.weightPercentage)
		return false;
	if(this->active!=c.active)
		return false;
	//no need to care about permanently locked
	return true;
}

bool ConstraintActivityPreferredStartingTime::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	if(this->day >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
		 tr("Constraint activity preferred starting time is wrong because it refers to removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour == r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
		 tr("Constraint activity preferred starting time is wrong because preferred hour is too late (after the last acceptable slot). Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour > r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
		 tr("Constraint activity preferred starting time is wrong because it refers to removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityPreferredStartingTime::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityPreferredStartingTime::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityPreferredStartingTime>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	if(this->day>=0)
		s+=IL3+"<Day>"+protect(r.daysOfTheWeek[this->day])+"</Day>\n";
	if(this->hour>=0)
		s+=IL3+"<Hour>"+protect(r.hoursOfTheDay[this->hour])+"</Hour>\n";
	s+=IL3+"<Permanently_Locked>";s+=trueFalse(this->permanentlyLocked);s+="</Permanently_Locked>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityPreferredStartingTime>\n";
	return s;
}

QString ConstraintActivityPreferredStartingTime::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) has a preferred starting time: %3", "%1 is the id, %2 is the detailed description of the activity. %3 is time (day and hour)")
	 .arg(getActivityDescription(r, this->activityId))
	 .arg(getActivityDetailedDescription(r, this->activityId))
	 .arg(r.daysOfTheWeek[this->day]+" "+r.hoursOfTheDay[this->hour]);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));
	s+=translatedCommaSpace();
	s+=tr("PL:%1", "Abbreviation for permanently locked").arg(yesNoTranslated(this->permanentlyLocked));

	return begin+s+end;
}

QString ConstraintActivityPreferredStartingTime::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+="\n";

	s+=tr("has a preferred starting time:");
	s+="\n";
	s+=tr("Day=%1").arg(r.daysOfTheWeek[this->day]);
	s+="\n";
	s+=tr("Hour=%1").arg(r.hoursOfTheDay[this->hour]);
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	if(this->permanentlyLocked){
		s+=tr("This activity is permanently locked, which means you cannot unlock it from the 'Timetable' menu"
		" (you can unlock this activity by removing the constraint from the constraints dialog or by setting the 'permanently"
		" locked' attribute false when editing this constraint)");
	}
	else{
		s+=tr("This activity is not permanently locked, which means you can unlock it from the 'Timetable' menu");
	}
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityPreferredStartingTime::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		if(this->day>=0)
			nbroken+=abs(this->day-d);
		if(this->hour>=0)
			nbroken+=abs(this->hour-h);
	}
	if(nbroken>0)
		nbroken=1;

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity preferred starting time broken for activity with id=%1 (%2), increases conflicts total by %3",
			"%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activityId)
			.arg(getActivityDetailedDescription(r, this->activityId))
			.arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityPreferredStartingTime::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityPreferredStartingTime::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityPreferredStartingTime::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredStartingTime::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredStartingTime::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityPreferredStartingTime::hasWrongDayOrHour(Rules& r)
{
	if(day<0 || day>=r.nDaysPerWeek || hour<0 || hour>=r.nHoursPerDay)
		return true;
	return false;
}

bool ConstraintActivityPreferredStartingTime::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return false;
}

bool ConstraintActivityPreferredStartingTime::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return false;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityPreferredTimeSlots::ConstraintActivityPreferredTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_PREFERRED_TIME_SLOTS;
}

ConstraintActivityPreferredTimeSlots::ConstraintActivityPreferredTimeSlots(double wp, int actId, int nPT_L, const QList<int>& d_L, const QList<int>& h_L)
	: TimeConstraint(wp)
{
	assert(d_L.count()==nPT_L);
	assert(h_L.count()==nPT_L);

	this->p_activityId=actId;
	this->p_nPreferredTimeSlots_L=nPT_L;
	this->p_days_L=d_L;
	this->p_hours_L=h_L;
	this->type=CONSTRAINT_ACTIVITY_PREFERRED_TIME_SLOTS;
}

bool ConstraintActivityPreferredTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->p_activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(p_activityId, r.nInternalActivities);

	if(i==r.nInternalActivities){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	for(int k=0; k<p_nPreferredTimeSlots_L; k++){
		if(this->p_days_L[k] >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activity preferred time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k] == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activity preferred time slots is wrong because a preferred hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k] > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activity preferred time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}

		if(this->p_hours_L[k]<0 || this->p_days_L[k]<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activity preferred time slots is wrong because it has hour or day not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}

	this->p_activityIndex=i;
	return true;
}

bool ConstraintActivityPreferredTimeSlots::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->p_activityId))
		return true;
	return false;
}

QString ConstraintActivityPreferredTimeSlots::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintActivityPreferredTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->p_activityId)+"</Activity_Id>\n";
	s+=IL3+"<Number_of_Preferred_Time_Slots>"+CustomFETString::number(this->p_nPreferredTimeSlots_L)+"</Number_of_Preferred_Time_Slots>\n";
	for(int i=0; i<p_nPreferredTimeSlots_L; i++){
		s+=IL3+"<Preferred_Time_Slot>\n";
		if(this->p_days_L[i]>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->p_days_L[i]])+"</Day>\n";
		if(this->p_hours_L[i]>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->p_hours_L[i]])+"</Hour>\n";
		s+=IL3+"</Preferred_Time_Slot>\n";
	}
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityPreferredTimeSlots>\n";
	return s;
}

QString ConstraintActivityPreferredTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		.arg(getActivityDescription(r, this->p_activityId))
		.arg(getActivityDetailedDescription(r, this->p_activityId));
	s+=" ";

	s+=tr("has a set of preferred time slots:");
	s+=" ";
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0){
			s+=r.daysOfTheWeek[this->p_days_L[i]];
			s+=" ";
		}
		if(this->p_hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->p_hours_L[i]];
		}
		if(i<this->p_nPreferredTimeSlots_L-1)
			s+=translatedSemicolonSpace();
	}
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityPreferredTimeSlots::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		.arg(this->p_activityId)
		.arg(getActivityDetailedDescription(r, this->p_activityId));
	s+="\n";

	s+=tr("has a set of preferred time slots (all hours of the activity must be in the allowed slots):");
	s+="\n";
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0){
			s+=r.daysOfTheWeek[this->p_days_L[i]];
			s+=" ";
		}
		if(this->p_hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->p_hours_L[i]];
		}
		if(i<this->p_nPreferredTimeSlots_L-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityPreferredTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);
	
	Matrix2D<bool> allowed;
	allowed.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			allowed[d][h]=false;
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0 && this->p_hours_L[i]>=0)
			allowed[this->p_days_L[i]][this->p_hours_L[i]]=true;
		else
			assert(0);
	}

	nbroken=0;
	if(c.times[this->p_activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->p_activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->p_activityIndex]/r.nDaysPerWeek; //the hour
		for(int dur=0; dur<r.internalActivitiesList[this->p_activityIndex].duration; dur++)
			if(!allowed[d][h+dur])
				nbroken++;
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity preferred time slots broken for activity with id=%1 (%2) on %3 hours, increases conflicts total by %4",
		 "%1 is the id, %2 is the detailed description of the activity.")
		 .arg(this->p_activityId)
		 .arg(getActivityDetailedDescription(r, this->p_activityId))
		 .arg(nbroken)
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));
		
		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityPreferredTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->p_activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityPreferredTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityPreferredTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(p_nPreferredTimeSlots_L==p_days_L.count());
	assert(p_nPreferredTimeSlots_L==p_hours_L.count());
	
	for(int i=0; i<p_nPreferredTimeSlots_L; i++)
		if(p_days_L.at(i)<0 || p_days_L.at(i)>=r.nDaysPerWeek
		 || p_hours_L.at(i)<0 || p_hours_L.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintActivityPreferredTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivityPreferredTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(p_nPreferredTimeSlots_L==p_days_L.count());
	assert(p_nPreferredTimeSlots_L==p_hours_L.count());
	
	QList<int> newDays;
	QList<int> newHours;
	int newNPref=0;
	
	for(int i=0; i<p_nPreferredTimeSlots_L; i++)
		if(p_days_L.at(i)>=0 && p_days_L.at(i)<r.nDaysPerWeek
		 && p_hours_L.at(i)>=0 && p_hours_L.at(i)<r.nHoursPerDay){
			newDays.append(p_days_L.at(i));
			newHours.append(p_hours_L.at(i));
			newNPref++;
		}
	
	p_nPreferredTimeSlots_L=newNPref;
	p_days_L=newDays;
	p_hours_L=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesPreferredTimeSlots::ConstraintActivitiesPreferredTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_PREFERRED_TIME_SLOTS;
}

ConstraintActivitiesPreferredTimeSlots::ConstraintActivitiesPreferredTimeSlots(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut, int dur, int nPT_L, QList<int> d_L, QList<int> h_L)
	: TimeConstraint(wp)
{
	assert(dur==-1 || dur>=1);
	duration=dur;

	assert(d_L.count()==nPT_L);
	assert(h_L.count()==nPT_L);

	this->p_teacherName=te;
	this->p_subjectName=su;
	this->p_activityTagName=sut;
	this->p_studentsName=st;
	this->p_nPreferredTimeSlots_L=nPT_L;
	this->p_days_L=d_L;
	this->p_hours_L=h_L;
	this->type=CONSTRAINT_ACTIVITIES_PREFERRED_TIME_SLOTS;
}

bool ConstraintActivitiesPreferredTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->p_nActivities=0;
	this->p_activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->p_teacherName!=""){
			it = act->teachersNames.indexOf(this->p_teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->p_studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, p_studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->p_subjectName!="" && act->subjectName!=this->p_subjectName){
			continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->p_activityTagName!="" && !act->activityTagsNames.contains(this->p_activityTagName)){
			continue;
		}

		if(duration>=1 && act->duration!=duration)
			continue;
	
		assert(this->p_nActivities < r.nInternalActivities);
		this->p_nActivities++;
		this->p_activitiesIndices.append(i);
	}
	
	assert(this->p_nActivities==this->p_activitiesIndices.count());

	//////////////////////
	for(int k=0; k<p_nPreferredTimeSlots_L; k++){
		if(this->p_days_L[k] >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities preferred time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k] == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities preferred time slots is wrong because a preferred hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k] > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities preferred time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k]<0 || this->p_days_L[k]<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities preferred time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->p_nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesPreferredTimeSlots::hasInactiveActivities(Rules& r)
{
	QList<int> localActiveActs;
	QList<int> localAllActs;

	//returns true if all activities are inactive
	int it;
	Activity* act;
	int i;
	for(i=0; i<r.activitiesList.count(); i++){
		act=r.activitiesList.at(i);

		//check if this activity has the corresponding teacher
		if(this->p_teacherName!=""){
			it = act->teachersNames.indexOf(this->p_teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->p_studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.setsShareStudents(st, p_studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->p_subjectName!="" && act->subjectName!=this->p_subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->p_activityTagName!="" && !act->activityTagsNames.contains(this->p_activityTagName)){
				continue;
		}

		if(duration>=1 && act->duration!=duration)
			continue;
	
		if(!r.inactiveActivities.contains(act->id))
			localActiveActs.append(act->id);
			
		localAllActs.append(act->id);
	}

	if(localActiveActs.count()==0 && localAllActs.count()>0)
	//because if this constraint does not refer to any activity,
	//it should be reported as incorrect
		return true;
	else
		return false;
}

QString ConstraintActivitiesPreferredTimeSlots::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintActivitiesPreferredTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->p_teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->p_studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->p_subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->p_activityTagName)+"</Activity_Tag>\n";
	if(duration>=1)
		s+=IL3+"<Duration>"+CustomFETString::number(duration)+"</Duration>\n";
	else
		s+=IL3+"<Duration></Duration>\n";
	s+=IL3+"<Number_of_Preferred_Time_Slots>"+CustomFETString::number(this->p_nPreferredTimeSlots_L)+"</Number_of_Preferred_Time_Slots>\n";
	for(int i=0; i<p_nPreferredTimeSlots_L; i++){
		s+=IL3+"<Preferred_Time_Slot>\n";
		if(this->p_days_L[i]>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->p_days_L[i]])+"</Day>\n";
		if(this->p_hours_L[i]>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->p_hours_L[i]])+"</Hour>\n";
		s+=IL3+"</Preferred_Time_Slot>\n";
	}
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesPreferredTimeSlots>\n";
	return s;
}

QString ConstraintActivitiesPreferredTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;

	QString tc, st, su, at, dur;
	
	if(this->p_teacherName!="")
		tc=tr("teacher=%1").arg(this->p_teacherName);
	else
		tc=tr("all teachers");
		
	if(this->p_studentsName!="")
		st=tr("students=%1").arg(this->p_studentsName);
	else
		st=tr("all students");
		
	if(this->p_subjectName!="")
		su=tr("subject=%1").arg(this->p_subjectName);
	else
		su=tr("all subjects");
		
	if(this->p_activityTagName!="")
		at=tr("activity tag=%1").arg(this->p_activityTagName);
	else
		at=tr("all activity tags");
	
	if(duration>=1)
		dur=tr("duration=%1").arg(duration);
	else
		dur=tr("all durations");

	s+=tr("Activities with %1, %2, %3, %4, %5, have a set of preferred time slots:", "%1...%5 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at).arg(dur);
	s+=" ";
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0){
			s+=r.daysOfTheWeek[this->p_days_L[i]];
			s+=" ";
		}
		if(this->p_hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->p_hours_L[i]];
		}
		if(i<this->p_nPreferredTimeSlots_L-1)
			s+=translatedSemicolonSpace();
	}
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesPreferredTimeSlots::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->p_teacherName!="")
		s+=tr("Teacher=%1").arg(this->p_teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
	if(this->p_studentsName!="")
		s+=tr("Students=%1").arg(this->p_studentsName);
	else
		s+=tr("All students");
	s+="\n";
	if(this->p_subjectName!="")
		s+=tr("Subject=%1").arg(this->p_subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
	if(this->p_activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->p_activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	if(duration>=1)
		s+=tr("Duration=%1").arg(duration);
	else
		s+=tr("All durations");
	s+="\n";

	s+=tr("have a set of preferred time slots (all hours of each affected activity must be in the allowed slots):");
	s+="\n";
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0){
			s+=r.daysOfTheWeek[this->p_days_L[i]];
			s+=" ";
		}
		if(this->p_hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->p_hours_L[i]];
		}
		if(i<this->p_nPreferredTimeSlots_L-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesPreferredTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

///////////////////
	Matrix2D<bool> allowed;
	allowed.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			allowed[d][h]=false;
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0 && this->p_hours_L[i]>=0)
			allowed[this->p_days_L[i]][this->p_hours_L[i]]=true;
		else
			assert(0);
	}
////////////////////

	nbroken=0;
	int tmp;
	
	for(int i=0; i<this->p_nActivities; i++){
		tmp=0;
		int ai=this->p_activitiesIndices[i];
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
			
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++)
				if(!allowed[d][h+dur])
					tmp++;
		}
		nbroken+=tmp;
		if(conflictsString!=nullptr && tmp>0){
			QString s=tr("Time constraint activities preferred time slots broken"
			 " for activity with id=%1 (%2) on %3 hours,"
			 " increases conflicts total by %4", "%1 is the id, %2 is the detailed description of the activity.")
			 .arg(r.internalActivitiesList[ai].id)
			 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
			 .arg(tmp)
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));
			
			dl.append(s);
			cl.append(weightPercentage/100*tmp);
		
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

bool ConstraintActivitiesPreferredTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->p_teacherName!=""){
		it = a->teachersNames.indexOf(this->p_teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->p_studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->p_studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->p_subjectName!="" && a->subjectName!=this->p_subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->p_activityTagName!="" && !a->activityTagsNames.contains(this->p_activityTagName))
		return false;

	if(duration>=1 && a->duration!=duration)
		return false;

	return true;
}

bool ConstraintActivitiesPreferredTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesPreferredTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPreferredTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPreferredTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesPreferredTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(p_nPreferredTimeSlots_L==p_days_L.count());
	assert(p_nPreferredTimeSlots_L==p_hours_L.count());
	
	for(int i=0; i<p_nPreferredTimeSlots_L; i++)
		if(p_days_L.at(i)<0 || p_days_L.at(i)>=r.nDaysPerWeek
		 || p_hours_L.at(i)<0 || p_hours_L.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintActivitiesPreferredTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesPreferredTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(p_nPreferredTimeSlots_L==p_days_L.count());
	assert(p_nPreferredTimeSlots_L==p_hours_L.count());
	
	QList<int> newDays;
	QList<int> newHours;
	int newNPref=0;
	
	for(int i=0; i<p_nPreferredTimeSlots_L; i++)
		if(p_days_L.at(i)>=0 && p_days_L.at(i)<r.nDaysPerWeek
		 && p_hours_L.at(i)>=0 && p_hours_L.at(i)<r.nHoursPerDay){
			newDays.append(p_days_L.at(i));
			newHours.append(p_hours_L.at(i));
			newNPref++;
		}
	
	p_nPreferredTimeSlots_L=newNPref;
	p_days_L=newDays;
	p_hours_L=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintSubactivitiesPreferredTimeSlots::ConstraintSubactivitiesPreferredTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_SUBACTIVITIES_PREFERRED_TIME_SLOTS;
}

ConstraintSubactivitiesPreferredTimeSlots::ConstraintSubactivitiesPreferredTimeSlots(double wp, int compNo, const QString& te,
	const QString& st, const QString& su, const QString& sut, int dur, int nPT_L, QList<int> d_L, QList<int> h_L)
	: TimeConstraint(wp)
{
	assert(dur==-1 || dur>=1);
	duration=dur;

	assert(d_L.count()==nPT_L);
	assert(h_L.count()==nPT_L);

	this->componentNumber=compNo;
	this->p_teacherName=te;
	this->p_subjectName=su;
	this->p_activityTagName=sut;
	this->p_studentsName=st;
	this->p_nPreferredTimeSlots_L=nPT_L;
	this->p_days_L=d_L;
	this->p_hours_L=h_L;
	this->type=CONSTRAINT_SUBACTIVITIES_PREFERRED_TIME_SLOTS;
}

bool ConstraintSubactivitiesPreferredTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->p_nActivities=0;
	this->p_activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		
		if(!act->representsComponentNumber(this->componentNumber))
			continue;

		//check if this activity has the corresponding teacher
		if(this->p_teacherName!=""){
			it = act->teachersNames.indexOf(this->p_teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->p_studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, p_studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->p_subjectName!="" && act->subjectName!=this->p_subjectName){
			continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->p_activityTagName!="" && !act->activityTagsNames.contains(this->p_activityTagName)){
			continue;
		}

		if(duration>=1 && act->duration!=duration)
			continue;
	
		assert(this->p_nActivities < r.nInternalActivities);
		this->p_nActivities++;
		this->p_activitiesIndices.append(i);
	}

	assert(this->p_nActivities==this->p_activitiesIndices.count());

	//////////////////////
	for(int k=0; k<p_nPreferredTimeSlots_L; k++){
		if(this->p_days_L[k] >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint subactivities preferred time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k] == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint subactivities preferred time slots is wrong because a preferred hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k] > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint subactivities preferred time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->p_hours_L[k]<0 || this->p_days_L[k]<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint subactivities preferred time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->p_nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintSubactivitiesPreferredTimeSlots::hasInactiveActivities(Rules& r)
{
	QList<int> localActiveActs;
	QList<int> localAllActs;

	//returns true if all activities are inactive
	int it;
	Activity* act;
	int i;
	for(i=0; i<r.activitiesList.count(); i++){
		act=r.activitiesList.at(i);

		if(!act->representsComponentNumber(this->componentNumber))
			continue;

		//check if this activity has the corresponding teacher
		if(this->p_teacherName!=""){
			it = act->teachersNames.indexOf(this->p_teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->p_studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.setsShareStudents(st, p_studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->p_subjectName!="" && act->subjectName!=this->p_subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->p_activityTagName!="" && !act->activityTagsNames.contains(this->p_activityTagName)){
				continue;
		}

		if(duration>=1 && act->duration!=duration)
			continue;
	
		if(!r.inactiveActivities.contains(act->id))
			localActiveActs.append(act->id);
			
		localAllActs.append(act->id);
	}

	if(localActiveActs.count()==0 && localAllActs.count()>0)
		return true;
	else
		return false;
}

QString ConstraintSubactivitiesPreferredTimeSlots::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintSubactivitiesPreferredTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Component_Number>"+CustomFETString::number(this->componentNumber)+"</Component_Number>\n";
	s+=IL3+"<Teacher>"+protect(this->p_teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->p_studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->p_subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->p_activityTagName)+"</Activity_Tag>\n";
	if(duration>=1)
		s+=IL3+"<Duration>"+CustomFETString::number(duration)+"</Duration>\n";
	else
		s+=IL3+"<Duration></Duration>\n";
	s+=IL3+"<Number_of_Preferred_Time_Slots>"+CustomFETString::number(this->p_nPreferredTimeSlots_L)+"</Number_of_Preferred_Time_Slots>\n";
	for(int i=0; i<p_nPreferredTimeSlots_L; i++){
		s+=IL3+"<Preferred_Time_Slot>\n";
		if(this->p_days_L[i]>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->p_days_L[i]])+"</Day>\n";
		if(this->p_hours_L[i]>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->p_hours_L[i]])+"</Hour>\n";
		s+=IL3+"</Preferred_Time_Slot>\n";
	}
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintSubactivitiesPreferredTimeSlots>\n";
	return s;
}

QString ConstraintSubactivitiesPreferredTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	QString tc, st, su, at, dur;
	
	if(this->p_teacherName!="")
		tc=tr("teacher=%1").arg(this->p_teacherName);
	else
		tc=tr("all teachers");
		
	if(this->p_studentsName!="")
		st=tr("students=%1").arg(this->p_studentsName);
	else
		st=tr("all students");
		
	if(this->p_subjectName!="")
		su=tr("subject=%1").arg(this->p_subjectName);
	else
		su=tr("all subjects");
		
	if(this->p_activityTagName!="")
		at=tr("activity tag=%1").arg(this->p_activityTagName);
	else
		at=tr("all activity tags");
	
	if(duration>=1)
		dur=tr("duration=%1").arg(duration);
	else
		dur=tr("all durations");

	s+=tr("Subactivities with %1, %2, %3, %4, %5, %6, have a set of preferred time slots:", "%1...%6 are conditions for the subactivities")
		.arg(tr("component number=%1").arg(this->componentNumber)).arg(tc).arg(st).arg(su).arg(at).arg(dur);
		
	s+=" ";
	
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0){
			s+=r.daysOfTheWeek[this->p_days_L[i]];
			s+=" ";
		}
		if(this->p_hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->p_hours_L[i]];
		}
		if(i<this->p_nPreferredTimeSlots_L-1)
			s+=translatedSemicolonSpace();
	}
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintSubactivitiesPreferredTimeSlots::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Subactivities with:");s+="\n";
	
	s+=tr("Component number=%1").arg(this->componentNumber);
	s+="\n";

	if(this->p_teacherName!="")
		s+=tr("Teacher=%1").arg(this->p_teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->p_studentsName!="")
		s+=tr("Students=%1").arg(this->p_studentsName);
	else
		s+=tr("All students");
	s+="\n";
	
	if(this->p_subjectName!="")
		s+=tr("Subject=%1").arg(this->p_subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
	
	if(this->p_activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->p_activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	if(duration>=1)
		s+=tr("Duration=%1").arg(duration);
	else
		s+=tr("All durations");
	s+="\n";

	s+=tr("have a set of preferred time slots (all hours of each affected subactivity must be in the allowed slots):");
	s+="\n";
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0){
			s+=r.daysOfTheWeek[this->p_days_L[i]];
			s+=" ";
		}
		if(this->p_hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->p_hours_L[i]];
		}
		if(i<this->p_nPreferredTimeSlots_L-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintSubactivitiesPreferredTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

///////////////////
	Matrix2D<bool> allowed;
	allowed.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			allowed[d][h]=false;
	for(int i=0; i<this->p_nPreferredTimeSlots_L; i++){
		if(this->p_days_L[i]>=0 && this->p_hours_L[i]>=0)
			allowed[this->p_days_L[i]][this->p_hours_L[i]]=true;
		else
			assert(0);
	}
////////////////////

	nbroken=0;
	int tmp;
	
	for(int i=0; i<this->p_nActivities; i++){
		tmp=0;
		int ai=this->p_activitiesIndices[i];
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
			
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++)
				if(!allowed[d][h+dur])
					tmp++;
		}
		nbroken+=tmp;
		if(conflictsString!=nullptr && tmp>0){
			QString s=tr("Time constraint subactivities preferred time slots broken"
			 " for activity with id=%1 (%2), component number %3, on %4 hours,"
			 " increases conflicts total by %5", "%1 is the id, %2 is the detailed description of the activity.")
			 .arg(r.internalActivitiesList[ai].id)
			 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
			 .arg(componentNumber)
			 .arg(tmp)
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

			dl.append(s);
			cl.append(weightPercentage/100*tmp);
		
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

bool ConstraintSubactivitiesPreferredTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	if(!a->representsComponentNumber(this->componentNumber))
		return false;

	int it;

	//check if this activity has the corresponding teacher
	if(this->p_teacherName!=""){
		it = a->teachersNames.indexOf(this->p_teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->p_studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->p_studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->p_subjectName!="" && a->subjectName!=this->p_subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->p_activityTagName!="" && !a->activityTagsNames.contains(this->p_activityTagName))
		return false;

	if(duration>=1 && a->duration!=duration)
		return false;

	return true;
}

bool ConstraintSubactivitiesPreferredTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintSubactivitiesPreferredTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintSubactivitiesPreferredTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintSubactivitiesPreferredTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintSubactivitiesPreferredTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(p_nPreferredTimeSlots_L==p_days_L.count());
	assert(p_nPreferredTimeSlots_L==p_hours_L.count());
	
	for(int i=0; i<p_nPreferredTimeSlots_L; i++)
		if(p_days_L.at(i)<0 || p_days_L.at(i)>=r.nDaysPerWeek
		 || p_hours_L.at(i)<0 || p_hours_L.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintSubactivitiesPreferredTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintSubactivitiesPreferredTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(p_nPreferredTimeSlots_L==p_days_L.count());
	assert(p_nPreferredTimeSlots_L==p_hours_L.count());
	
	QList<int> newDays;
	QList<int> newHours;
	int newNPref=0;
	
	for(int i=0; i<p_nPreferredTimeSlots_L; i++)
		if(p_days_L.at(i)>=0 && p_days_L.at(i)<r.nDaysPerWeek
		 && p_hours_L.at(i)>=0 && p_hours_L.at(i)<r.nHoursPerDay){
			newDays.append(p_days_L.at(i));
			newHours.append(p_hours_L.at(i));
			newNPref++;
		}
	
	p_nPreferredTimeSlots_L=newNPref;
	p_days_L=newDays;
	p_hours_L=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityPreferredStartingTimes::ConstraintActivityPreferredStartingTimes()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIMES;
}

ConstraintActivityPreferredStartingTimes::ConstraintActivityPreferredStartingTimes(double wp, int actId, int nPT_L, const QList<int>& d_L, const QList<int>& h_L)
	: TimeConstraint(wp)
{
	assert(d_L.count()==nPT_L);
	assert(h_L.count()==nPT_L);

	this->activityId=actId;
	this->nPreferredStartingTimes_L=nPT_L;
	this->days_L=d_L;
	this->hours_L=h_L;
	this->type=CONSTRAINT_ACTIVITY_PREFERRED_STARTING_TIMES;
}

bool ConstraintActivityPreferredStartingTimes::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);

	if(i==r.nInternalActivities){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	for(int k=0; k<nPreferredStartingTimes_L; k++){
		if(this->days_L[k] >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activity preferred starting times is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours_L[k] == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activity preferred starting times is wrong because a preferred hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours_L[k] > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activity preferred starting times is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityPreferredStartingTimes::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityPreferredStartingTimes::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintActivityPreferredStartingTimes>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	s+=IL3+"<Number_of_Preferred_Starting_Times>"+CustomFETString::number(this->nPreferredStartingTimes_L)+"</Number_of_Preferred_Starting_Times>\n";
	for(int i=0; i<nPreferredStartingTimes_L; i++){
		s+=IL3+"<Preferred_Starting_Time>\n";
		if(this->days_L[i]>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->days_L[i]])+"</Day>\n";
		if(this->hours_L[i]>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hours_L[i]])+"</Hour>\n";
		s+=IL3+"</Preferred_Starting_Time>\n";
	}
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityPreferredStartingTimes>\n";
	return s;
}

QString ConstraintActivityPreferredStartingTimes::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(getActivityDescription(r, this->activityId))
		.arg(getActivityDetailedDescription(r, this->activityId));
	
	s+=" ";
	s+=tr("has a set of preferred starting times:");
	s+=" ";
	for(int i=0; i<this->nPreferredStartingTimes_L; i++){
		if(this->days_L[i]>=0){
			s+=r.daysOfTheWeek[this->days_L[i]];
			s+=" ";
		}
		if(this->hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->hours_L[i]];
		}
		if(i<nPreferredStartingTimes_L-1)
			s+=translatedSemicolonSpace();
	}
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight Percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityPreferredStartingTimes::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));
	
	s+="\n";
	s+=tr("has a set of preferred starting times:");
	s+="\n";
	for(int i=0; i<this->nPreferredStartingTimes_L; i++){
		if(this->days_L[i]>=0){
			s+=r.daysOfTheWeek[this->days_L[i]];
			s+=" ";
		}
		if(this->hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->hours_L[i]];
		}
		if(i<this->nPreferredStartingTimes_L-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityPreferredStartingTimes::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		int i;
		for(i=0; i<this->nPreferredStartingTimes_L; i++){
			if(this->days_L[i]>=0 && this->days_L[i]!=d)
				continue;
			if(this->hours_L[i]>=0 && this->hours_L[i]!=h)
				continue;
			break;
		}
		if(i==this->nPreferredStartingTimes_L){
			nbroken=1;
		}
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity preferred starting times broken for activity with id=%1 (%2), increases conflicts total by %3",
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(this->activityId)
		 .arg(getActivityDetailedDescription(r, this->activityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityPreferredStartingTimes::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityPreferredStartingTimes::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityPreferredStartingTimes::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredStartingTimes::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredStartingTimes::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityPreferredStartingTimes::hasWrongDayOrHour(Rules& r)
{
	assert(nPreferredStartingTimes_L==days_L.count());
	assert(nPreferredStartingTimes_L==hours_L.count());
	
	for(int i=0; i<nPreferredStartingTimes_L; i++)
		if(days_L.at(i)<0 || days_L.at(i)>=r.nDaysPerWeek
		 || hours_L.at(i)<0 || hours_L.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintActivityPreferredStartingTimes::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivityPreferredStartingTimes::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(nPreferredStartingTimes_L==days_L.count());
	assert(nPreferredStartingTimes_L==hours_L.count());
	
	QList<int> newDays;
	QList<int> newHours;
	int newNPref=0;
	
	for(int i=0; i<nPreferredStartingTimes_L; i++)
		if(days_L.at(i)>=0 && days_L.at(i)<r.nDaysPerWeek
		 && hours_L.at(i)>=0 && hours_L.at(i)<r.nHoursPerDay){
			newDays.append(days_L.at(i));
			newHours.append(hours_L.at(i));
			newNPref++;
		}
	
	nPreferredStartingTimes_L=newNPref;
	days_L=newDays;
	hours_L=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesPreferredStartingTimes::ConstraintActivitiesPreferredStartingTimes()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_PREFERRED_STARTING_TIMES;
}

ConstraintActivitiesPreferredStartingTimes::ConstraintActivitiesPreferredStartingTimes(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut, int dur, int nPT_L, QList<int> d_L, QList<int> h_L)
	: TimeConstraint(wp)
{
	assert(dur==-1 || dur>=1);
	duration=dur;

	assert(d_L.count()==nPT_L);
	assert(h_L.count()==nPT_L);

	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->nPreferredStartingTimes_L=nPT_L;
	this->days_L=d_L;
	this->hours_L=h_L;
	this->type=CONSTRAINT_ACTIVITIES_PREFERRED_STARTING_TIMES;
}

bool ConstraintActivitiesPreferredStartingTimes::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		if(duration>=1 && act->duration!=duration)
			continue;

		assert(this->nActivities < r.nInternalActivities);
		this->activitiesIndices.append(i);
		this->nActivities++;
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	//////////////////////
	for(int k=0; k<nPreferredStartingTimes_L; k++){
		if(this->days_L[k] >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities preferred starting times is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours_L[k] == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities preferred starting times is wrong because a preferred hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours_L[k] > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities preferred starting times is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesPreferredStartingTimes::hasInactiveActivities(Rules& r)
{
	QList<int> localActiveActs;
	QList<int> localAllActs;

	//returns true if all activities are inactive
	int it;
	Activity* act;
	int i;
	for(i=0; i<r.activitiesList.count(); i++){
		act=r.activitiesList.at(i);

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.setsShareStudents(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}

		if(duration>=1 && act->duration!=duration)
			continue;
	
		if(!r.inactiveActivities.contains(act->id))
			localActiveActs.append(act->id);
			
		localAllActs.append(act->id);
	}

	if(localActiveActs.count()==0 && localAllActs.count()>0)
		return true;
	else
		return false;
}

QString ConstraintActivitiesPreferredStartingTimes::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintActivitiesPreferredStartingTimes>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	if(duration>=1)
		s+=IL3+"<Duration>"+CustomFETString::number(duration)+"</Duration>\n";
	else
		s+=IL3+"<Duration></Duration>\n";
	s+=IL3+"<Number_of_Preferred_Starting_Times>"+CustomFETString::number(this->nPreferredStartingTimes_L)+"</Number_of_Preferred_Starting_Times>\n";
	for(int i=0; i<nPreferredStartingTimes_L; i++){
		s+=IL3+"<Preferred_Starting_Time>\n";
		if(this->days_L[i]>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->days_L[i]])+"</Day>\n";
		if(this->hours_L[i]>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hours_L[i]])+"</Hour>\n";
		s+=IL3+"</Preferred_Starting_Time>\n";
	}
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesPreferredStartingTimes>\n";
	return s;
}

QString ConstraintActivitiesPreferredStartingTimes::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;

	QString tc, st, su, at, dur;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");

	if(duration>=1)
		dur=tr("duration=%1").arg(duration);
	else
		dur=tr("all durations");

	s+=tr("Activities with %1, %2, %3, %4, %5, have a set of preferred starting times:", "%1...%5 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at).arg(dur);
	s+=" ";

	for(int i=0; i<this->nPreferredStartingTimes_L; i++){
		if(this->days_L[i]>=0){
			s+=r.daysOfTheWeek[this->days_L[i]];
			s+=" ";
		}
		if(this->hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->hours_L[i]];
		}
		if(i<this->nPreferredStartingTimes_L-1)
			s+=translatedSemicolonSpace();
	}
	s+=translatedCommaSpace();
	
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesPreferredStartingTimes::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
	
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
	
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	if(duration>=1)
		s+=tr("Duration=%1").arg(duration);
	else
		s+=tr("All durations");
	s+="\n";

	s+=tr("have a set of preferred starting times:");
	s+="\n";
	for(int i=0; i<this->nPreferredStartingTimes_L; i++){
		if(this->days_L[i]>=0){
			s+=r.daysOfTheWeek[this->days_L[i]];
			s+=" ";
		}
		if(this->hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->hours_L[i]];
		}
		if(i<this->nPreferredStartingTimes_L-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesPreferredStartingTimes::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	int tmp;
	
	for(int i=0; i<this->nActivities; i++){
		tmp=0;
		int ai=this->activitiesIndices[i];
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
			int i;
			for(i=0; i<this->nPreferredStartingTimes_L; i++){
				if(this->days_L[i]>=0 && this->days_L[i]!=d)
					continue;
				if(this->hours_L[i]>=0 && this->hours_L[i]!=h)
					continue;
				break;
			}
			if(i==this->nPreferredStartingTimes_L){
				tmp=1;
			}
		}
		nbroken+=tmp;
		if(conflictsString!=nullptr && tmp>0){
			QString s=tr("Time constraint activities preferred starting times broken"
			 " for activity with id=%1 (%2),"
			 " increases conflicts total by %3", "%1 is the id, %2 is the detailed description of the activity")
			 .arg(r.internalActivitiesList[ai].id)
			 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));
			
			dl.append(s);
			cl.append(weightPercentage/100*tmp);
		
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

bool ConstraintActivitiesPreferredStartingTimes::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	if(duration>=1 && a->duration!=duration)
		return false;

	return true;
}

bool ConstraintActivitiesPreferredStartingTimes::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesPreferredStartingTimes::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPreferredStartingTimes::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPreferredStartingTimes::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPreferredStartingTimes::hasWrongDayOrHour(Rules& r)
{
	assert(nPreferredStartingTimes_L==days_L.count());
	assert(nPreferredStartingTimes_L==hours_L.count());
	
	for(int i=0; i<nPreferredStartingTimes_L; i++)
		if(days_L.at(i)<0 || days_L.at(i)>=r.nDaysPerWeek
		 || hours_L.at(i)<0 || hours_L.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintActivitiesPreferredStartingTimes::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesPreferredStartingTimes::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(nPreferredStartingTimes_L==days_L.count());
	assert(nPreferredStartingTimes_L==hours_L.count());
	
	QList<int> newDays;
	QList<int> newHours;
	int newNPref=0;
	
	for(int i=0; i<nPreferredStartingTimes_L; i++)
		if(days_L.at(i)>=0 && days_L.at(i)<r.nDaysPerWeek
		 && hours_L.at(i)>=0 && hours_L.at(i)<r.nHoursPerDay){
			newDays.append(days_L.at(i));
			newHours.append(hours_L.at(i));
			newNPref++;
		}
	
	nPreferredStartingTimes_L=newNPref;
	days_L=newDays;
	hours_L=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintSubactivitiesPreferredStartingTimes::ConstraintSubactivitiesPreferredStartingTimes()
	: TimeConstraint()
{
	this->type = CONSTRAINT_SUBACTIVITIES_PREFERRED_STARTING_TIMES;
}

ConstraintSubactivitiesPreferredStartingTimes::ConstraintSubactivitiesPreferredStartingTimes(double wp, int compNo, const QString& te,
	const QString& st, const QString& su, const QString& sut, int dur, int nPT_L, QList<int> d_L, QList<int> h_L)
	: TimeConstraint(wp)
{
	assert(dur==-1 || dur>=1);
	duration=dur;

	assert(d_L.count()==nPT_L);
	assert(h_L.count()==nPT_L);

	this->componentNumber=compNo;
	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->nPreferredStartingTimes_L=nPT_L;
	this->days_L=d_L;
	this->hours_L=h_L;
	this->type=CONSTRAINT_SUBACTIVITIES_PREFERRED_STARTING_TIMES;
}

bool ConstraintSubactivitiesPreferredStartingTimes::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		
		if(!act->representsComponentNumber(this->componentNumber))
			continue;

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}

		if(duration>=1 && act->duration!=duration)
			continue;
	
		assert(this->nActivities < r.nInternalActivities);
		this->nActivities++;
		this->activitiesIndices.append(i);
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	//////////////////////
	for(int k=0; k<nPreferredStartingTimes_L; k++){
		if(this->days_L[k] >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint subactivities preferred starting times is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours_L[k] == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint subactivities preferred starting times is wrong because a preferred hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->hours_L[k] > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint subactivities preferred starting times is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintSubactivitiesPreferredStartingTimes::hasInactiveActivities(Rules& r)
{
	QList<int> localActiveActs;
	QList<int> localAllActs;

	//returns true if all activities are inactive
	int it;
	Activity* act;
	int i;
	for(i=0; i<r.activitiesList.count(); i++){
		act=r.activitiesList.at(i);

		if(!act->representsComponentNumber(this->componentNumber))
			continue;

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.setsShareStudents(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		if(duration>=1 && act->duration!=duration)
			continue;

		if(!r.inactiveActivities.contains(act->id))
			localActiveActs.append(act->id);
			
		localAllActs.append(act->id);
	}

	if(localActiveActs.count()==0 && localAllActs.count()>0)
		return true;
	else
		return false;
}

QString ConstraintSubactivitiesPreferredStartingTimes::getXmlDescription(Rules& r)
{
	QString s=IL2+"<ConstraintSubactivitiesPreferredStartingTimes>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Component_Number>"+CustomFETString::number(this->componentNumber)+"</Component_Number>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	if(duration>=1)
		s+=IL3+"<Duration>"+CustomFETString::number(duration)+"</Duration>\n";
	else
		s+=IL3+"<Duration></Duration>\n";
	s+=IL3+"<Number_of_Preferred_Starting_Times>"+CustomFETString::number(this->nPreferredStartingTimes_L)+"</Number_of_Preferred_Starting_Times>\n";
	for(int i=0; i<nPreferredStartingTimes_L; i++){
		s+=IL3+"<Preferred_Starting_Time>\n";
		if(this->days_L[i]>=0)
			s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->days_L[i]])+"</Day>\n";
		if(this->hours_L[i]>=0)
			s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hours_L[i]])+"</Hour>\n";
		s+=IL3+"</Preferred_Starting_Time>\n";
	}
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintSubactivitiesPreferredStartingTimes>\n";
	return s;
}

QString ConstraintSubactivitiesPreferredStartingTimes::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString tc, st, su, at, dur;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");
		
	if(duration>=1)
		dur=tr("duration=%1").arg(duration);
	else
		dur=tr("all durations");

	QString s;
	
	s+=tr("Subactivities with %1, %2, %3, %4, %5, %6, have a set of preferred starting times:", "%1...%6 are conditions for the subactivities")
		.arg(tr("component number=%1").arg(this->componentNumber)).arg(tc).arg(st).arg(su).arg(at).arg(dur);
	s+=" ";

	for(int i=0; i<this->nPreferredStartingTimes_L; i++){
		if(this->days_L[i]>=0){
			s+=r.daysOfTheWeek[this->days_L[i]];
			s+=" ";
		}
		if(this->hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->hours_L[i]];
		}
		if(i<this->nPreferredStartingTimes_L-1)
			s+=translatedSemicolonSpace();
	}
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintSubactivitiesPreferredStartingTimes::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Subactivities with:");s+="\n";

	s+=tr("Component number=%1").arg(this->componentNumber);s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
	
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	if(duration>=1)
		s+=tr("Duration=%1").arg(duration);
	else
		s+=tr("All durations");
	s+="\n";

	s+=tr("have a set of preferred starting times:");
	s+="\n";
	for(int i=0; i<this->nPreferredStartingTimes_L; i++){
		if(this->days_L[i]>=0){
			s+=r.daysOfTheWeek[this->days_L[i]];
			s+=" ";
		}
		if(this->hours_L[i]>=0){
			s+=r.hoursOfTheDay[this->hours_L[i]];
		}
		if(i<this->nPreferredStartingTimes_L-1)
			s+=translatedSemicolonSpace();
	}
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintSubactivitiesPreferredStartingTimes::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	int tmp;
	
	for(int i=0; i<this->nActivities; i++){
		tmp=0;
		int ai=this->activitiesIndices[i];
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
			int i;
			for(i=0; i<this->nPreferredStartingTimes_L; i++){
				if(this->days_L[i]>=0 && this->days_L[i]!=d)
					continue;
				if(this->hours_L[i]>=0 && this->hours_L[i]!=h)
					continue;
				break;
			}
			if(i==this->nPreferredStartingTimes_L){
				tmp=1;
			}
		}
		nbroken+=tmp;
		if(conflictsString!=nullptr && tmp>0){
			QString s=tr("Time constraint subactivities preferred starting times broken"
			 " for activity with id=%1 (%2), component number %3,"
			 " increases conflicts total by %4", "%1 is the id, %2 is the detailed description of the activity")
			 .arg(r.internalActivitiesList[ai].id)
			 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
			 .arg(this->componentNumber)
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

			dl.append(s);
			cl.append(weightPercentage/100*tmp);
		
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

bool ConstraintSubactivitiesPreferredStartingTimes::isRelatedToActivity(Rules& r, Activity* a)
{
	if(!a->representsComponentNumber(this->componentNumber))
		return false;

	int it;
	
	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	if(duration>=1 && a->duration!=duration)
		return false;

	return true;
}

bool ConstraintSubactivitiesPreferredStartingTimes::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintSubactivitiesPreferredStartingTimes::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintSubactivitiesPreferredStartingTimes::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintSubactivitiesPreferredStartingTimes::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintSubactivitiesPreferredStartingTimes::hasWrongDayOrHour(Rules& r)
{
	assert(nPreferredStartingTimes_L==days_L.count());
	assert(nPreferredStartingTimes_L==hours_L.count());
	
	for(int i=0; i<nPreferredStartingTimes_L; i++)
		if(days_L.at(i)<0 || days_L.at(i)>=r.nDaysPerWeek
		 || hours_L.at(i)<0 || hours_L.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintSubactivitiesPreferredStartingTimes::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintSubactivitiesPreferredStartingTimes::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(nPreferredStartingTimes_L==days_L.count());
	assert(nPreferredStartingTimes_L==hours_L.count());
	
	QList<int> newDays;
	QList<int> newHours;
	int newNPref=0;
	
	for(int i=0; i<nPreferredStartingTimes_L; i++)
		if(days_L.at(i)>=0 && days_L.at(i)<r.nDaysPerWeek
		 && hours_L.at(i)>=0 && hours_L.at(i)<r.nHoursPerDay){
			newDays.append(days_L.at(i));
			newHours.append(hours_L.at(i));
			newNPref++;
		}
	
	nPreferredStartingTimes_L=newNPref;
	days_L=newDays;
	hours_L=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesSameStartingHour::ConstraintActivitiesSameStartingHour()
	: TimeConstraint()
{
	type=CONSTRAINT_ACTIVITIES_SAME_STARTING_HOUR;
}

ConstraintActivitiesSameStartingHour::ConstraintActivitiesSameStartingHour(double wp, int nact, const QList<int>& act)
 : TimeConstraint(wp)
 {
	assert(nact>=2);
	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	this->type=CONSTRAINT_ACTIVITIES_SAME_STARTING_HOUR;
}

bool ConstraintActivitiesSameStartingHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintActivitiesSameStartingHour::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintActivitiesSameStartingHour::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesSameStartingHour::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintActivitiesSameStartingHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesSameStartingHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesSameStartingHour>\n";
	return s;
}

QString ConstraintActivitiesSameStartingHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Activities same starting hour");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));
		if(i<this->n_activities-1)
			s+=translatedCommaSpace();
	}

	return begin+s+end;
}

QString ConstraintActivitiesSameStartingHour::getDetailedDescription(Rules& r)
{
	QString s;
	
	s=tr("Time constraint");s+="\n";
	s+=tr("Activities must have the same starting hour");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesSameStartingHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//sum the differences in the scheduled hour for all pairs of activities.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				//int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						//int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int tmp=0;

						//	tmp = abs(hour1-hour2);
						if(hour1!=hour2)
							tmp=1;

						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				//int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						//int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int tmp=0;

						//	tmp = abs(hour1-hour2);
						if(hour1!=hour2)
							tmp=1;

						nbroken+=tmp;

						if(tmp>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint activities same starting hour broken, because activity with id=%1 (%2) is not at the same hour with activity with id=%3 (%4)"
							 , "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id));
							s+=". ";
							s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
						
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintActivitiesSameStartingHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintActivitiesSameStartingHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesSameStartingHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesSameStartingHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesSameStartingHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesSameStartingHour::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesSameStartingHour::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesSameStartingHour::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesSameStartingDay::ConstraintActivitiesSameStartingDay()
	: TimeConstraint()
{
	type=CONSTRAINT_ACTIVITIES_SAME_STARTING_DAY;
}

ConstraintActivitiesSameStartingDay::ConstraintActivitiesSameStartingDay(double wp, int nact, const QList<int>& act)
 : TimeConstraint(wp)
 {
	assert(nact>=2);
	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	this->type=CONSTRAINT_ACTIVITIES_SAME_STARTING_DAY;
}

bool ConstraintActivitiesSameStartingDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintActivitiesSameStartingDay::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintActivitiesSameStartingDay::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesSameStartingDay::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintActivitiesSameStartingDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesSameStartingDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesSameStartingDay>\n";
	return s;
}

QString ConstraintActivitiesSameStartingDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Activities same starting day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));
		if(i<this->n_activities-1)
			s+=translatedCommaSpace();
	}

	return begin+s+end;
}

QString ConstraintActivitiesSameStartingDay::getDetailedDescription(Rules& r)
{
	QString s;
	
	s=tr("Time constraint");s+="\n";
	s+=tr("Activities must have the same starting day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesSameStartingDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//sum the differences in the scheduled hour for all pairs of activities.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				//int hour1=t1/r.nDaysPerWeek;
				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						//int hour2=t2/r.nDaysPerWeek;
						int tmp=0;

						if(day1!=day2)
							tmp=1;

						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				//int hour1=t1/r.nDaysPerWeek;
				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						//int hour2=t2/r.nDaysPerWeek;
						int tmp=0;

						if(day1!=day2)
							tmp=1;

						nbroken+=tmp;

						if(tmp>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint activities same starting day broken, because activity with id=%1 (%2) is not on the same day with activity with id=%3 (%4)"
							 , "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id));
							s+=". ";
							s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
						
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintActivitiesSameStartingDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintActivitiesSameStartingDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesSameStartingDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesSameStartingDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesSameStartingDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesSameStartingDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesSameStartingDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesSameStartingDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTwoActivitiesConsecutive::ConstraintTwoActivitiesConsecutive()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TWO_ACTIVITIES_CONSECUTIVE;
}

ConstraintTwoActivitiesConsecutive::ConstraintTwoActivitiesConsecutive(double wp, int firstActId, int secondActId)
	: TimeConstraint(wp)
{
	this->firstActivityId = firstActId;
	this->secondActivityId=secondActId;
	this->type = CONSTRAINT_TWO_ACTIVITIES_CONSECUTIVE;
}

bool ConstraintTwoActivitiesConsecutive::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->firstActivityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(firstActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->firstActivityIndex=i;

	////////
	
	/*for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->secondActivityId)
			break;
	}*/
	
	i=r.activitiesHash.value(secondActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->secondActivityIndex=i;
	
	if(firstActivityIndex==secondActivityIndex){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to same activities):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
	assert(firstActivityIndex!=secondActivityIndex);
	
	return true;
}

bool ConstraintTwoActivitiesConsecutive::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->firstActivityId))
		return true;
	if(r.inactiveActivities.contains(this->secondActivityId))
		return true;
	return false;
}

QString ConstraintTwoActivitiesConsecutive::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTwoActivitiesConsecutive>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Id>"+CustomFETString::number(this->firstActivityId)+"</First_Activity_Id>\n";
	s+=IL3+"<Second_Activity_Id>"+CustomFETString::number(this->secondActivityId)+"</Second_Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTwoActivitiesConsecutive>\n";
	return s;
}

QString ConstraintTwoActivitiesConsecutive::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s=tr("Two activities consecutive:");
	s+=" ";
	
	s+=tr("first act. id: %1", "act.=activity").arg(getActivityDescription(r, this->firstActivityId));
	s+=translatedCommaSpace();
	s+=tr("second act. id: %1", "act.=activity").arg(getActivityDescription(r, this->secondActivityId));
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTwoActivitiesConsecutive::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Two activities consecutive (second activity must be placed immediately after the first"
	 " activity, on the same day; no gaps are allowed between them, except for break constraints)"); s+="\n";
	
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("First activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->firstActivityId)
		.arg(getActivityDetailedDescription(r, this->firstActivityId));
	s+="\n";

	s+=tr("Second activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->secondActivityId)
		.arg(getActivityDetailedDescription(r, this->secondActivityId));
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintTwoActivitiesConsecutive::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->firstActivityIndex]!=UNALLOCATED_TIME && c.times[this->secondActivityIndex]!=UNALLOCATED_TIME){
		int fd=c.times[this->firstActivityIndex]%r.nDaysPerWeek; //the day when first activity was scheduled
		int fh=c.times[this->firstActivityIndex]/r.nDaysPerWeek; //the hour
		int sd=c.times[this->secondActivityIndex]%r.nDaysPerWeek; //the day when second activity was scheduled
		int sh=c.times[this->secondActivityIndex]/r.nDaysPerWeek; //the hour
		
		if(fd!=sd)
			nbroken=1;
		else if(fh+r.internalActivitiesList[this->firstActivityIndex].duration>sh)
			nbroken=1;
		else{
			assert(fd==sd);
			int h;
			int d=fd;
			assert(d==sd);
			for(h=fh+r.internalActivitiesList[this->firstActivityIndex].duration; h<r.nHoursPerDay; h++)
				if(!breakDayHour[d][h])
					break;
					
			assert(h<=sh);
				
			if(h!=sh)
				nbroken=1;
		}
	}
	
	assert(nbroken==0 || nbroken==1);

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint two activities consecutive broken for first activity with id=%1 (%2) and "
		 "second activity with id=%3 (%4), increases conflicts total by %5", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
		 .arg(this->firstActivityId)
		 .arg(getActivityDetailedDescription(r, this->firstActivityId))
		 .arg(this->secondActivityId)
		 .arg(getActivityDetailedDescription(r, this->secondActivityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintTwoActivitiesConsecutive::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->firstActivityId==a->id)
		return true;
	if(this->secondActivityId==a->id)
		return true;
	return false;
}

bool ConstraintTwoActivitiesConsecutive::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintTwoActivitiesConsecutive::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesConsecutive::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesConsecutive::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesConsecutive::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTwoActivitiesConsecutive::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTwoActivitiesConsecutive::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTwoActivitiesGrouped::ConstraintTwoActivitiesGrouped()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TWO_ACTIVITIES_GROUPED;
}

ConstraintTwoActivitiesGrouped::ConstraintTwoActivitiesGrouped(double wp, int firstActId, int secondActId)
	: TimeConstraint(wp)
{
	this->firstActivityId = firstActId;
	this->secondActivityId=secondActId;
	this->type = CONSTRAINT_TWO_ACTIVITIES_GROUPED;
}

bool ConstraintTwoActivitiesGrouped::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->firstActivityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(firstActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->firstActivityIndex=i;

	////////
	
	/*for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->secondActivityId)
			break;
	}*/

	i=r.activitiesHash.value(secondActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->secondActivityIndex=i;
	
	if(firstActivityIndex==secondActivityIndex){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to same activities):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
	assert(firstActivityIndex!=secondActivityIndex);
	
	return true;
}

bool ConstraintTwoActivitiesGrouped::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->firstActivityId))
		return true;
	if(r.inactiveActivities.contains(this->secondActivityId))
		return true;
	return false;
}

QString ConstraintTwoActivitiesGrouped::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTwoActivitiesGrouped>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Id>"+CustomFETString::number(this->firstActivityId)+"</First_Activity_Id>\n";
	s+=IL3+"<Second_Activity_Id>"+CustomFETString::number(this->secondActivityId)+"</Second_Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTwoActivitiesGrouped>\n";
	return s;
}

QString ConstraintTwoActivitiesGrouped::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s=tr("Two activities grouped:");
	s+=" ";
	
	s+=tr("first act. id: %1", "act.=activity").arg(getActivityDescription(r, this->firstActivityId));
	s+=translatedCommaSpace();
	s+=tr("second act. id: %1", "act.=activity").arg(getActivityDescription(r, this->secondActivityId));
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTwoActivitiesGrouped::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Two activities grouped (the activities must be placed on the same day, "
	 "one immediately following the other, in any order; no gaps are allowed between them, except for break constraints)"); s+="\n";
	
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("First activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->firstActivityId)
		.arg(getActivityDetailedDescription(r, this->firstActivityId));
	s+="\n";

	s+=tr("Second activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->secondActivityId)
		.arg(getActivityDetailedDescription(r, this->secondActivityId));
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintTwoActivitiesGrouped::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->firstActivityIndex]!=UNALLOCATED_TIME && c.times[this->secondActivityIndex]!=UNALLOCATED_TIME){
		int fd=c.times[this->firstActivityIndex]%r.nDaysPerWeek; //the day when first activity was scheduled
		int fh=c.times[this->firstActivityIndex]/r.nDaysPerWeek; //the hour
		int sd=c.times[this->secondActivityIndex]%r.nDaysPerWeek; //the day when second activity was scheduled
		int sh=c.times[this->secondActivityIndex]/r.nDaysPerWeek; //the hour
		
		if(fd!=sd)
			nbroken=1;
		else if(fd==sd && fh+r.internalActivitiesList[this->firstActivityIndex].duration <= sh){
			int h;
			int d=fd;
			assert(d==sd);
			for(h=fh+r.internalActivitiesList[this->firstActivityIndex].duration; h<r.nHoursPerDay; h++)
				if(!breakDayHour[d][h])
					break;
					
			assert(h<=sh);
				
			if(h!=sh)
				nbroken=1;
		}
		else if(fd==sd && sh+r.internalActivitiesList[this->secondActivityIndex].duration <= fh){
			int h;
			int d=sd;
			assert(d==fd);
			for(h=sh+r.internalActivitiesList[this->secondActivityIndex].duration; h<r.nHoursPerDay; h++)
				if(!breakDayHour[d][h])
					break;
					
			assert(h<=fh);
				
			if(h!=fh)
				nbroken=1;
		}
		else
			nbroken=1;
	}
	
	assert(nbroken==0 || nbroken==1);

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint two activities grouped broken for first activity with id=%1 (%2) and "
		 "second activity with id=%3 (%4), increases conflicts total by %5", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
		 .arg(this->firstActivityId)
		 .arg(getActivityDetailedDescription(r, this->firstActivityId))
		 .arg(this->secondActivityId)
		 .arg(getActivityDetailedDescription(r, this->secondActivityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintTwoActivitiesGrouped::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->firstActivityId==a->id)
		return true;
	if(this->secondActivityId==a->id)
		return true;
	return false;
}

bool ConstraintTwoActivitiesGrouped::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintTwoActivitiesGrouped::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesGrouped::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesGrouped::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintTwoActivitiesGrouped::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTwoActivitiesGrouped::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTwoActivitiesGrouped::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintThreeActivitiesGrouped::ConstraintThreeActivitiesGrouped()
	: TimeConstraint()
{
	this->type = CONSTRAINT_THREE_ACTIVITIES_GROUPED;
}

ConstraintThreeActivitiesGrouped::ConstraintThreeActivitiesGrouped(double wp, int firstActId, int secondActId, int thirdActId)
	: TimeConstraint(wp)
{
	this->firstActivityId = firstActId;
	this->secondActivityId=secondActId;
	this->thirdActivityId=thirdActId;
	this->type = CONSTRAINT_THREE_ACTIVITIES_GROUPED;
}

bool ConstraintThreeActivitiesGrouped::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->firstActivityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(firstActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->firstActivityIndex=i;

	////////
	
	/*for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->secondActivityId)
			break;
	}*/

	i=r.activitiesHash.value(secondActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->secondActivityIndex=i;
	
	////////
	
	/*for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->thirdActivityId)
			break;
	}*/

	i=r.activitiesHash.value(thirdActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->thirdActivityIndex=i;
	
	if(firstActivityIndex==secondActivityIndex || firstActivityIndex==thirdActivityIndex || secondActivityIndex==thirdActivityIndex){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to same activities):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
	assert(firstActivityIndex!=secondActivityIndex && firstActivityIndex!=thirdActivityIndex && secondActivityIndex!=thirdActivityIndex);
	
	return true;
}

bool ConstraintThreeActivitiesGrouped::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->firstActivityId))
		return true;
	if(r.inactiveActivities.contains(this->secondActivityId))
		return true;
	if(r.inactiveActivities.contains(this->thirdActivityId))
		return true;
	return false;
}

QString ConstraintThreeActivitiesGrouped::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintThreeActivitiesGrouped>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Id>"+CustomFETString::number(this->firstActivityId)+"</First_Activity_Id>\n";
	s+=IL3+"<Second_Activity_Id>"+CustomFETString::number(this->secondActivityId)+"</Second_Activity_Id>\n";
	s+=IL3+"<Third_Activity_Id>"+CustomFETString::number(this->thirdActivityId)+"</Third_Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintThreeActivitiesGrouped>\n";
	return s;
}

QString ConstraintThreeActivitiesGrouped::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s=tr("Three activities grouped:");
	s+=" ";
	
	s+=tr("first act. id: %1", "act.=activity").arg(getActivityDescription(r, this->firstActivityId));
	s+=translatedCommaSpace();
	s+=tr("second act. id: %1", "act.=activity").arg(getActivityDescription(r, this->secondActivityId));
	s+=translatedCommaSpace();
	s+=tr("third act. id: %1", "act.=activity").arg(getActivityDescription(r, this->thirdActivityId));
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintThreeActivitiesGrouped::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Three activities grouped (the activities must be placed on the same day, "
	 "one immediately following the other, as a block of three activities, in any order; no gaps are allowed between them, except for break constraints)"); s+="\n";
	
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("First activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->firstActivityId)
		.arg(getActivityDetailedDescription(r, this->firstActivityId));
	s+="\n";

	s+=tr("Second activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->secondActivityId)
		.arg(getActivityDetailedDescription(r, this->secondActivityId));
	s+="\n";
	
	s+=tr("Third activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->thirdActivityId)
		.arg(getActivityDetailedDescription(r, this->thirdActivityId));
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintThreeActivitiesGrouped::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->firstActivityIndex]!=UNALLOCATED_TIME && c.times[this->secondActivityIndex]!=UNALLOCATED_TIME && c.times[this->thirdActivityIndex]!=UNALLOCATED_TIME){
		int fd=c.times[this->firstActivityIndex]%r.nDaysPerWeek; //the day when first activity was scheduled
		int fh=c.times[this->firstActivityIndex]/r.nDaysPerWeek; //the hour
		int sd=c.times[this->secondActivityIndex]%r.nDaysPerWeek; //the day when second activity was scheduled
		int sh=c.times[this->secondActivityIndex]/r.nDaysPerWeek; //the hour
		int td=c.times[this->thirdActivityIndex]%r.nDaysPerWeek; //the day when third activity was scheduled
		int th=c.times[this->thirdActivityIndex]/r.nDaysPerWeek; //the hour
		
		if(!(fd==sd && fd==td))
			nbroken=1;
		else{
			assert(fd==sd && fd==td && sd==td);
			int a1=-1,a2=-1,a3=-1;
			if(fh>=sh && fh>=th && sh>=th){
				a1=thirdActivityIndex;
				a2=secondActivityIndex;
				a3=firstActivityIndex;
				//out<<"321"<<endl;
			}
			else if(fh>=sh && fh>=th && th>=sh){
				a1=secondActivityIndex;
				a2=thirdActivityIndex;
				a3=firstActivityIndex;
				//out<<"231"<<endl;
			}
			else if(sh>=fh && sh>=th && fh>=th){
				a1=thirdActivityIndex;
				a2=firstActivityIndex;
				a3=secondActivityIndex;
				//out<<"312"<<endl;
			}
			else if(sh>=fh && sh>=th && th>=fh){
				a1=firstActivityIndex;
				a2=thirdActivityIndex;
				a3=secondActivityIndex;
				//out<<"132"<<endl;
			}
			else if(th>=fh && th>=sh && fh>=sh){
				a1=secondActivityIndex;
				a2=firstActivityIndex;
				a3=thirdActivityIndex;
				//out<<"213"<<endl;
			}
			else if(th>=fh && th>=sh && sh>=fh){
				a1=firstActivityIndex;
				a2=secondActivityIndex;
				a3=thirdActivityIndex;
				//out<<"123"<<endl;
			}
			else
				assert(0);
			
			int a1d=c.times[a1]%r.nDaysPerWeek; //the day for a1
			int a1h=c.times[a1]/r.nDaysPerWeek; //the day for a1
			int a1dur=r.internalActivitiesList[a1].duration;

			int a2d=c.times[a2]%r.nDaysPerWeek; //the day for a2
			int a2h=c.times[a2]/r.nDaysPerWeek; //the day for a2
			int a2dur=r.internalActivitiesList[a2].duration;

			int a3d=c.times[a3]%r.nDaysPerWeek; //the day for a3
			int a3h=c.times[a3]/r.nDaysPerWeek; //the day for a3
			//int a3dur=r.internalActivitiesList[a3].duration;
			
			int hoursBetweenThem=-1;
			
			assert(a1d==a2d && a1d==a3d);
			
			if(a1h+a1dur<=a2h && a2h+a2dur<=a3h){
				hoursBetweenThem=0;
				for(int hh=a1h+a1dur; hh<a2h; hh++)
					if(!breakDayHour[a1d][hh])
						hoursBetweenThem++;

				for(int hh=a2h+a2dur; hh<a3h; hh++)
					if(!breakDayHour[a2d][hh])
						hoursBetweenThem++;
			}
			
			if(hoursBetweenThem==0)
				nbroken=0;
			else
				nbroken=1;
		}
	}
	
	assert(nbroken==0 || nbroken==1);

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint three activities grouped broken for first activity with id=%1 (%2), "
		 "second activity with id=%3 (%4) and third activity with id=%5 (%6), increases conflicts total by %7",
		 "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr., %5 id, %6 det. descr.")
		 .arg(this->firstActivityId)
		 .arg(getActivityDetailedDescription(r, this->firstActivityId))
		 .arg(this->secondActivityId)
		 .arg(getActivityDetailedDescription(r, this->secondActivityId))
		 .arg(this->thirdActivityId)
		 .arg(getActivityDetailedDescription(r, this->thirdActivityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintThreeActivitiesGrouped::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->firstActivityId==a->id)
		return true;
	if(this->secondActivityId==a->id)
		return true;
	if(this->thirdActivityId==a->id)
		return true;
	return false;
}

bool ConstraintThreeActivitiesGrouped::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintThreeActivitiesGrouped::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintThreeActivitiesGrouped::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintThreeActivitiesGrouped::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintThreeActivitiesGrouped::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintThreeActivitiesGrouped::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintThreeActivitiesGrouped::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTwoActivitiesOrdered::ConstraintTwoActivitiesOrdered()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TWO_ACTIVITIES_ORDERED;
}

ConstraintTwoActivitiesOrdered::ConstraintTwoActivitiesOrdered(double wp, int firstActId, int secondActId)
	: TimeConstraint(wp)
{
	this->firstActivityId = firstActId;
	this->secondActivityId=secondActId;
	this->type = CONSTRAINT_TWO_ACTIVITIES_ORDERED;
}

bool ConstraintTwoActivitiesOrdered::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->firstActivityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(firstActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->firstActivityIndex=i;

	////////
	
	/*for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->secondActivityId)
			break;
	}*/

	i=r.activitiesHash.value(secondActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->secondActivityIndex=i;
	
	if(firstActivityIndex==secondActivityIndex){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to same activities):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
	assert(firstActivityIndex!=secondActivityIndex);
	
	return true;
}

bool ConstraintTwoActivitiesOrdered::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->firstActivityId))
		return true;
	if(r.inactiveActivities.contains(this->secondActivityId))
		return true;
	return false;
}

QString ConstraintTwoActivitiesOrdered::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTwoActivitiesOrdered>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Id>"+CustomFETString::number(this->firstActivityId)+"</First_Activity_Id>\n";
	s+=IL3+"<Second_Activity_Id>"+CustomFETString::number(this->secondActivityId)+"</Second_Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTwoActivitiesOrdered>\n";
	return s;
}

QString ConstraintTwoActivitiesOrdered::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s=tr("Two activities ordered:");
	s+=" ";
	
	s+=tr("first act. id: %1", "act.=activity").arg(getActivityDescription(r, this->firstActivityId));
	s+=translatedCommaSpace();
	s+=tr("second act. id: %1", "act.=activity").arg(getActivityDescription(r, this->secondActivityId));
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTwoActivitiesOrdered::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Two activities ordered (the second activity must begin at any time in the week later than the first"
	 " activity has finished)"); s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("First activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->firstActivityId)
		.arg(getActivityDetailedDescription(r, this->firstActivityId));
	s+="\n";

	s+=tr("Second activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->secondActivityId)
		.arg(getActivityDetailedDescription(r, this->secondActivityId));
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTwoActivitiesOrdered::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->firstActivityIndex]!=UNALLOCATED_TIME && c.times[this->secondActivityIndex]!=UNALLOCATED_TIME){
		int fd=c.times[this->firstActivityIndex]%r.nDaysPerWeek; //the day when first activity was scheduled
		int fh=c.times[this->firstActivityIndex]/r.nDaysPerWeek
		  + r.internalActivitiesList[this->firstActivityIndex].duration-1; //the end hour of first activity
		int sd=c.times[this->secondActivityIndex]%r.nDaysPerWeek; //the day when second activity was scheduled
		int sh=c.times[this->secondActivityIndex]/r.nDaysPerWeek; //the start hour of second activity
		
		if(!(fd<sd || (fd==sd && fh<sh)))
			nbroken=1;
	}
	
	assert(nbroken==0 || nbroken==1);

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint two activities ordered broken for first activity with id=%1 (%2) and "
		 "second activity with id=%3 (%4), increases conflicts total by %5", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
		 .arg(this->firstActivityId)
		 .arg(getActivityDetailedDescription(r, this->firstActivityId))
		 .arg(this->secondActivityId)
		 .arg(getActivityDetailedDescription(r, this->secondActivityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintTwoActivitiesOrdered::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->firstActivityId==a->id)
		return true;
	if(this->secondActivityId==a->id)
		return true;
	return false;
}

bool ConstraintTwoActivitiesOrdered::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintTwoActivitiesOrdered::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesOrdered::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesOrdered::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintTwoActivitiesOrdered::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTwoActivitiesOrdered::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTwoActivitiesOrdered::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTwoSetsOfActivitiesOrdered::ConstraintTwoSetsOfActivitiesOrdered()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TWO_SETS_OF_ACTIVITIES_ORDERED;
}

ConstraintTwoSetsOfActivitiesOrdered::ConstraintTwoSetsOfActivitiesOrdered(double wp, const QList<int>& firstActsIds, const QList<int>& secondActsIds)
	: TimeConstraint(wp)
{
	this->firstActivitiesIdsList = firstActsIds;
	this->secondActivitiesIdsList=secondActsIds;
	this->type = CONSTRAINT_TWO_SETS_OF_ACTIVITIES_ORDERED;
}

bool ConstraintTwoSetsOfActivitiesOrdered::computeInternalStructure(QWidget* parent, Rules& r)
{
	QSet<int> sf;
	
	this->firstActivitiesIndicesList.clear();
	for(int firstActivityId : std::as_const(this->firstActivitiesIdsList)){
		int i=r.activitiesHash.value(firstActivityId, r.nInternalActivities);
	
		if(i<r.nInternalActivities){
			this->firstActivitiesIndicesList.append(i);
			sf.insert(i);
		}
	}

	if(this->firstActivitiesIndicesList.isEmpty()){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (its first set of activities is empty/incorrect). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	////////

	bool intersect=false;
	this->secondActivitiesIndicesList.clear();
	for(int secondActivityId : std::as_const(this->secondActivitiesIdsList)){
		int i=r.activitiesHash.value(secondActivityId, r.nInternalActivities);
	
		if(i<r.nInternalActivities){
			this->secondActivitiesIndicesList.append(i);
			if(sf.contains(i)){
				intersect=true;
				break;
			}
		}
	}

	if(this->secondActivitiesIndicesList.isEmpty()){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (its second set of activities is empty/incorrect). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	if(intersect){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (the first set of activities has activities in common with the second set of activities). Please correct it:\n%1")
			 .arg(this->getDetailedDescription(r)));
		return false;
	}
	
	return true;
}

bool ConstraintTwoSetsOfActivitiesOrdered::hasInactiveActivities(Rules& r)
{
	bool okf=false;
	for(int ai : this->firstActivitiesIdsList)
		if(!r.inactiveActivities.contains(ai)){
			okf=true;
			break;
		}

	bool oks=false;
	for(int ai : this->secondActivitiesIdsList)
		if(!r.inactiveActivities.contains(ai)){
			oks=true;
			break;
		}
	
	if(!okf || !oks)
		return true;
	return false;
}

QString ConstraintTwoSetsOfActivitiesOrdered::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTwoSetsOfActivitiesOrdered>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activities_Ids_Set>\n";
	s+=IL4+"<Number_of_Activities>"+QString::number(this->firstActivitiesIdsList.count())+"</Number_of_Activities>\n";
	for(int ai : std::as_const(this->firstActivitiesIdsList))
		s+=IL4+"<Activity_Id>"+CustomFETString::number(ai)+"</Activity_Id>\n";
	s+=IL3+"</First_Activities_Ids_Set>\n";
	s+=IL3+"<Second_Activities_Ids_Set>\n";
	s+=IL4+"<Number_of_Activities>"+QString::number(this->secondActivitiesIdsList.count())+"</Number_of_Activities>\n";
	for(int ai : std::as_const(this->secondActivitiesIdsList))
		s+=IL4+"<Activity_Id>"+CustomFETString::number(ai)+"</Activity_Id>\n";
	s+=IL3+"</Second_Activities_Ids_Set>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTwoSetsOfActivitiesOrdered>\n";
	return s;
}

QString ConstraintTwoSetsOfActivitiesOrdered::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s=tr("Two sets of activities ordered:");
	s+=" ";
	
	s+=tr("first activities set:");
	s+=" ";
	s+=tr("NA:%1", "Number of activities").arg(this->firstActivitiesIdsList.count());
	s+=translatedCommaSpace();
	for(int ai : std::as_const(this->firstActivitiesIdsList))
		s+=tr("Id:%1").arg(getActivityDescription(r, ai))+translatedCommaSpace();

	s+=tr("second activities set:");
	s+=" ";
	s+=tr("NA:%1", "Number of activities").arg(this->secondActivitiesIdsList.count());
	s+=translatedCommaSpace();
	for(int ai : std::as_const(this->secondActivitiesIdsList))
		s+=tr("Id:%1").arg(getActivityDescription(r, ai))+translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTwoSetsOfActivitiesOrdered::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Two sets of activities ordered (each activity from the second set must begin at any time in the week later than each activity"
	 " from the first set has finished)"); s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("First activities set ids:");
	s+="\n";
	s+=tr("Number of activities=%1").arg(this->firstActivitiesIdsList.count());s+="\n";
	for(int ai : std::as_const(this->firstActivitiesIdsList)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(ai).arg(getActivityDetailedDescription(r, ai));
		s+="\n";
	}

	s+=tr("Second activities set ids:");
	s+="\n";
	s+=tr("Number of activities=%1").arg(this->secondActivitiesIdsList.count());s+="\n";
	for(int ai : std::as_const(this->secondActivitiesIdsList)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(ai).arg(getActivityDetailedDescription(r, ai));
		s+="\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTwoSetsOfActivitiesOrdered::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	int totalBroken=0;
	
	for(int i=0; i<this->firstActivitiesIndicesList.count(); i++){
		for(int j=0; j<this->secondActivitiesIndicesList.count(); j++){
			nbroken=0;

			int firstActivityIndex=this->firstActivitiesIndicesList[i];
			int secondActivityIndex=this->secondActivitiesIndicesList[j];

			if(c.times[firstActivityIndex]!=UNALLOCATED_TIME && c.times[secondActivityIndex]!=UNALLOCATED_TIME){
				int fd=c.times[firstActivityIndex]%r.nDaysPerWeek; //the day when first activity was scheduled
				int fh=c.times[firstActivityIndex]/r.nDaysPerWeek
				  + r.internalActivitiesList[firstActivityIndex].duration-1; //the end hour of first activity
				int sd=c.times[secondActivityIndex]%r.nDaysPerWeek; //the day when second activity was scheduled
				int sh=c.times[secondActivityIndex]/r.nDaysPerWeek; //the start hour of second activity
				
				if(!(fd<sd || (fd==sd && fh<sh)))
					nbroken=1;
			}
		
			assert(nbroken==0 || nbroken==1);
			
			totalBroken+=nbroken;

			if(conflictsString!=nullptr && nbroken>0){
				int firstActivityId=r.internalActivitiesList[firstActivityIndex].id;
				int secondActivityId=r.internalActivitiesList[secondActivityIndex].id;
			
				QString s=tr("Time constraint two sets of activities ordered broken for first activity with id=%1 (%2) and "
				 "second activity with id=%3 (%4), increases conflicts total by %5", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
				 .arg(firstActivityId)
				 .arg(getActivityDetailedDescription(r, firstActivityId))
				 .arg(secondActivityId)
				 .arg(getActivityDetailedDescription(r, secondActivityId))
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));
	
				dl.append(s);
				cl.append(weightPercentage/100*nbroken);
		
				*conflictsString+= s+"\n";
			}
		}
	}
	
	if(weightPercentage==100)
		assert(totalBroken==0);
	return totalBroken * weightPercentage/100;
}

void ConstraintTwoSetsOfActivitiesOrdered::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	QList<int> tmpList;

	tmpList.clear();
	for(int ai : std::as_const(this->firstActivitiesIdsList)){
		Activity* act=r.activitiesPointerHash.value(ai, nullptr);
		if(act!=nullptr){
			assert(act->id==ai);
			tmpList.append(act->id);
		}
	}
	this->firstActivitiesIdsList=tmpList;
	
	tmpList.clear();
	for(int ai : std::as_const(this->secondActivitiesIdsList)){
		Activity* act=r.activitiesPointerHash.value(ai, nullptr);
		if(act!=nullptr){
			assert(act->id==ai);
			tmpList.append(act->id);
		}
	}
	this->secondActivitiesIdsList=tmpList;
	
	r.internalStructureComputed=false;
}

void ConstraintTwoSetsOfActivitiesOrdered::recomputeActivitiesSets()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	firstActivitiesIdsSet=QSet<int>(firstActivitiesIdsList.constBegin(), firstActivitiesIdsList.constEnd());
	secondActivitiesIdsSet=QSet<int>(secondActivitiesIdsList.constBegin(), secondActivitiesIdsList.constEnd());
#else
	firstActivitiesIdsSet=firstActivitiesIdsList.toSet();
	secondActivitiesIdsSet=secondActivitiesIdsList.toSet();
#endif
}

bool ConstraintTwoSetsOfActivitiesOrdered::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	
	return firstActivitiesIdsSet.contains(a->id) || secondActivitiesIdsSet.contains(a->id);

	/*for(int ai : std::as_const(this->firstActivitiesIdsList))
		if(ai==a->id)
			return true;
	for(int ai : std::as_const(this->secondActivitiesIdsList))
		if(ai==a->id)
			return true;
	return false;*/
}

bool ConstraintTwoSetsOfActivitiesOrdered::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintTwoSetsOfActivitiesOrdered::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoSetsOfActivitiesOrdered::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoSetsOfActivitiesOrdered::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintTwoSetsOfActivitiesOrdered::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTwoSetsOfActivitiesOrdered::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTwoSetsOfActivitiesOrdered::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTwoActivitiesOrderedIfSameDay::ConstraintTwoActivitiesOrderedIfSameDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TWO_ACTIVITIES_ORDERED_IF_SAME_DAY;
}

ConstraintTwoActivitiesOrderedIfSameDay::ConstraintTwoActivitiesOrderedIfSameDay(double wp, int firstActId, int secondActId)
	: TimeConstraint(wp)
{
	this->firstActivityId = firstActId;
	this->secondActivityId=secondActId;
	this->type = CONSTRAINT_TWO_ACTIVITIES_ORDERED_IF_SAME_DAY;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->firstActivityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(firstActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->firstActivityIndex=i;

	////////
	
	/*for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->secondActivityId)
			break;
	}*/

	i=r.activitiesHash.value(secondActivityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to nonexistent activity ids):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->secondActivityIndex=i;
	
	if(firstActivityIndex==secondActivityIndex){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to same activities):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
	assert(firstActivityIndex!=secondActivityIndex);
	
	return true;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->firstActivityId))
		return true;
	if(r.inactiveActivities.contains(this->secondActivityId))
		return true;
	return false;
}

QString ConstraintTwoActivitiesOrderedIfSameDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTwoActivitiesOrderedIfSameDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Id>"+CustomFETString::number(this->firstActivityId)+"</First_Activity_Id>\n";
	s+=IL3+"<Second_Activity_Id>"+CustomFETString::number(this->secondActivityId)+"</Second_Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTwoActivitiesOrderedIfSameDay>\n";
	return s;
}

QString ConstraintTwoActivitiesOrderedIfSameDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s=tr("Two activities ordered if same day:");
	s+=" ";
	
	s+=tr("first act. id: %1", "act.=activity").arg(getActivityDescription(r, this->firstActivityId));
	s+=translatedCommaSpace();
	s+=tr("second act. id: %1", "act.=activity").arg(getActivityDescription(r, this->secondActivityId));
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTwoActivitiesOrderedIfSameDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Two activities are ordered if they are on the same day (the second activity must begin later than the first"
	 " activity has finished if they are on the same day)");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));
	s+="\n";

	s+=tr("First activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->firstActivityId)
		.arg(getActivityDetailedDescription(r, this->firstActivityId));
	s+="\n";

	s+=tr("Second activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->secondActivityId)
		.arg(getActivityDetailedDescription(r, this->secondActivityId));
	s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTwoActivitiesOrderedIfSameDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->firstActivityIndex]!=UNALLOCATED_TIME && c.times[this->secondActivityIndex]!=UNALLOCATED_TIME){
		int fd=c.times[this->firstActivityIndex]%r.nDaysPerWeek; //the day when first activity was scheduled
		int fh=c.times[this->firstActivityIndex]/r.nDaysPerWeek
		  + r.internalActivitiesList[this->firstActivityIndex].duration-1; //the end hour of first activity
		int sd=c.times[this->secondActivityIndex]%r.nDaysPerWeek; //the day when second activity was scheduled
		int sh=c.times[this->secondActivityIndex]/r.nDaysPerWeek; //the start hour of second activity
		
		if(!(fd!=sd || (fd==sd && fh<sh)))
			nbroken=1;
	}
	
	assert(nbroken==0 || nbroken==1);

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint two activities ordered if on the same day broken for first activity with id=%1 (%2) and "
		 "second activity with id=%3 (%4), increases conflicts total by %5", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
		 .arg(this->firstActivityId)
		 .arg(getActivityDetailedDescription(r, this->firstActivityId))
		 .arg(this->secondActivityId)
		 .arg(getActivityDetailedDescription(r, this->secondActivityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->firstActivityId==a->id)
		return true;
	if(this->secondActivityId==a->id)
		return true;
	return false;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTwoActivitiesOrderedIfSameDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityEndsStudentsDay::ConstraintActivityEndsStudentsDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_ENDS_STUDENTS_DAY;
}

ConstraintActivityEndsStudentsDay::ConstraintActivityEndsStudentsDay(double wp, int actId)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->type = CONSTRAINT_ACTIVITY_ENDS_STUDENTS_DAY;
}

bool ConstraintActivityEndsStudentsDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityEndsStudentsDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityEndsStudentsDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityEndsStudentsDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityEndsStudentsDay>\n";
	return s;
}

QString ConstraintActivityEndsStudentsDay::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) must end students' day",
		"%1 is the id, %2 is the detailed description of the activity.")
		.arg(getActivityDescription(r, this->activityId))
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityEndsStudentsDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity must end students' day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityEndsStudentsDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		
		int i=this->activityIndex;
		for(int j=0; j<r.internalActivitiesList[i].iSubgroupsList.count(); j++){
			int sb=r.internalActivitiesList[i].iSubgroupsList.at(j);
			for(int hh=h+r.internalActivitiesList[i].duration; hh<r.nHoursPerDay; hh++)
				if(subgroupsMatrix[sb][d][hh]>0){
					nbroken=1;
					break;
				}
			if(nbroken>0)
				break;
		}
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity ends students' day broken for activity with id=%1 (%2), increases conflicts total by %3",
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(this->activityId)
		 .arg(getActivityDetailedDescription(r, this->activityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityEndsStudentsDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityEndsStudentsDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityEndsStudentsDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityEndsStudentsDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityEndsStudentsDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityEndsStudentsDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivityEndsStudentsDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivityEndsStudentsDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinHoursDaily::ConstraintTeachersMinHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_DAILY;
	
	this->allowEmptyDays=true;
}

ConstraintTeachersMinHoursDaily::ConstraintTeachersMinHoursDaily(double wp, int minhours, bool _allowEmptyDays)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursDaily=minhours;
	
	this->allowEmptyDays=_allowEmptyDays;

	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_DAILY;
}

bool ConstraintTeachersMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(r);
	
	if(allowEmptyDays==false){
		QString s=tr("Cannot generate a timetable with a constraint teachers min hours daily with allow empty days=false. Please modify it,"
			" so that it allows empty days. If you need a facility like that, please use constraint teachers min days per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);
		
		return false;
	}
	
	return true;
}

bool ConstraintTeachersMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	if(this->allowEmptyDays)
		s+=IL3+"<Allow_Empty_Days>true</Allow_Empty_Days>\n";
	else
		s+=IL3+"<Allow_Empty_Days>false</Allow_Empty_Days>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinHoursDaily>\n";
	return s;
}

QString ConstraintTeachersMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers min hours daily");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (daily)").arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("AED:%1", "Allow empty days").arg(yesNoTranslated(this->allowEmptyDays));

	return begin+s+end;
}

QString ConstraintTeachersMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of hours daily"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Allow empty days=%1").arg(yesNoTranslated(this->allowEmptyDays));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	assert(this->allowEmptyDays==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_daily++;

				if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
					nbroken++;
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_daily++;

				if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr("Time constraint teachers min %1 hours daily broken for teacher %2, on day %3, length=%4.")
						 .arg(CustomFETString::number(this->minHoursDaily))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(r.daysOfTheWeek[d])
						 .arg(n_hours_daily)
						 )
						 +
						 " "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
						
						dl.append(s);
						cl.append(weightPercentage/100);
					
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(a);
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeachersMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinHoursDaily::ConstraintTeacherMinHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_HOURS_DAILY;
	
	this->allowEmptyDays=true;
}

ConstraintTeacherMinHoursDaily::ConstraintTeacherMinHoursDaily(double wp, int minhours, const QString& teacher, bool _allowEmptyDays)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursDaily=minhours;
	this->teacherName=teacher;
	
	this->allowEmptyDays=_allowEmptyDays;

	this->type=CONSTRAINT_TEACHER_MIN_HOURS_DAILY;
}

bool ConstraintTeacherMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	
	if(allowEmptyDays==false){
		QString s=tr("Cannot generate a timetable with a constraint teacher min hours daily with allow empty days=false. Please modify it,"
			" so that it allows empty days. If you need a facility like that, please use constraint teacher min days per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);
		
		return false;
	}
	
	return true;
}

bool ConstraintTeacherMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	if(this->allowEmptyDays)
		s+=IL3+"<Allow_Empty_Days>true</Allow_Empty_Days>\n";
	else
		s+=IL3+"<Allow_Empty_Days>false</Allow_Empty_Days>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinHoursDaily>\n";
	return s;
}

QString ConstraintTeacherMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher min hours daily");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mH:%1", "Minimum hours (daily)").arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("AED:%1", "Allow empty days").arg(yesNoTranslated(this->allowEmptyDays));

	return begin+s+end;
}

QString ConstraintTeacherMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Allow empty days=%1").arg(yesNoTranslated(this->allowEmptyDays));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	assert(this->allowEmptyDays==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_daily++;

			if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
				nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_daily++;

			if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher min %1 hours daily broken for teacher %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->minHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(n_hours_daily)
					 )
					 +" "
					 +
					 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100));
						
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
			
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinDaysPerWeek::ConstraintTeacherMinDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_DAYS_PER_WEEK;
}

ConstraintTeacherMinDaysPerWeek::ConstraintTeacherMinDaysPerWeek(double wp, int mindays, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(mindays>0);
	this->minDaysPerWeek=mindays;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MIN_DAYS_PER_WEEK;
}

bool ConstraintTeacherMinDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMinDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Days_Per_Week>"+CustomFETString::number(this->minDaysPerWeek)+"</Minimum_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinDaysPerWeek>\n";
	return s;
}

QString ConstraintTeacherMinDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher min days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mD:%1", "Minimum days per week").arg(this->minDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMinDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum days per week=%1").arg(this->minDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	int i=this->teacher_ID;
	int nd=0;
	for(int d=0; d<r.nDaysPerWeek; d++){
		for(int h=0; h<r.nHoursPerDay; h++){
			if(teachersMatrix[i][d][h]>0){
				nd++;
				break;
			}
		}
	}

	if(nd<this->minDaysPerWeek){
		nbroken+=this->minDaysPerWeek-nd;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint teacher min %1 days per week broken for teacher %2.")
			 .arg(CustomFETString::number(this->minDaysPerWeek))
			 .arg(r.internalTeachersList[i]->name)
			 )
			 +" "
			 +
			 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));
				
			dl.append(s);
			cl.append(double(nbroken)*weightPercentage/100);
		
			*conflictsString+= s+"\n";
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
			
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintTeacherMinDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minDaysPerWeek>r.nDaysPerWeek)
		minDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinDaysPerWeek::ConstraintTeachersMinDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_DAYS_PER_WEEK;
}

ConstraintTeachersMinDaysPerWeek::ConstraintTeachersMinDaysPerWeek(double wp, int mindays)
 : TimeConstraint(wp)
 {
	assert(mindays>0);
	this->minDaysPerWeek=mindays;

	this->type=CONSTRAINT_TEACHERS_MIN_DAYS_PER_WEEK;
}

bool ConstraintTeachersMinDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMinDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Days_Per_Week>"+CustomFETString::number(this->minDaysPerWeek)+"</Minimum_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinDaysPerWeek>\n";
	return s;
}

QString ConstraintTeachersMinDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers min days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mD:%1", "Minimum days per week").arg(this->minDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMinDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum days per week=%1").arg(this->minDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbrokentotal=0;
	for(int i=0; i<r.nInternalTeachers; i++){
		int nbroken;

		nbroken=0;
		//int i=this->teacher_ID;
		int nd=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[i][d][h]>0){
					nd++;
					break;
				}
			}
		}

		if(nd<this->minDaysPerWeek){
			nbroken+=this->minDaysPerWeek-nd;
			nbrokentotal+=nbroken;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint teachers min %1 days per week broken for teacher %2.")
				 .arg(CustomFETString::number(this->minDaysPerWeek))
				 .arg(r.internalTeachersList[i]->name)
				 )
				 +" "
				 +
				 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));
					
				dl.append(s);
				cl.append(double(nbroken)*weightPercentage/100);
			
				*conflictsString+= s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbrokentotal==0);
			
	return weightPercentage/100 * nbrokentotal;
}

bool ConstraintTeachersMinDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersMinDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintTeachersMinDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minDaysPerWeek>r.nDaysPerWeek)
		minDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherIntervalMaxDaysPerWeek::ConstraintTeacherIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintTeacherIntervalMaxDaysPerWeek::ConstraintTeacherIntervalMaxDaysPerWeek(double wp, int maxnd, const QString& tn, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHER_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	return true;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeacherIntervalMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teacher interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Abbreviation for teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher respects working in an hourly interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;
	
	int t=this->teacher_ID;

	nbroken=0;
	
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int d=0; d<r.nDaysPerWeek; d++){
		ocDay[d]=false;
		for(int h=startHour; h<endHour; h++){
			if(teachersMatrix[t][d][h]>0){
				ocDay[d]=true;
			}
		}
	}
	int nOcDays=0;
	for(int d=0; d<r.nDaysPerWeek; d++)
		if(ocDay[d])
			nOcDays++;
	if(nOcDays > this->maxDaysPerWeek){
		nbroken+=nOcDays-this->maxDaysPerWeek;

		if(nbroken>0){
			QString s= tr("Time constraint teacher interval max days per week broken for teacher: %1, allowed %2 days, required %3 days.")
			 .arg(r.internalTeachersList[t]->name)
			 .arg(this->maxDaysPerWeek)
			 .arg(nOcDays);
			s+=" ";
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			
			dl.append(s);
			cl.append(nbroken*weightPercentage/100);
		
			*conflictsString += s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		this->maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersIntervalMaxDaysPerWeek::ConstraintTeachersIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintTeachersIntervalMaxDaysPerWeek::ConstraintTeachersIntervalMaxDaysPerWeek(double wp, int maxnd, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHERS_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	return true;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeachersIntervalMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teachers interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers respect working in an hourly interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;
	
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int t=0; t<r.nInternalTeachers; t++){
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(teachersMatrix[t][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if(nOcDays-this->maxDaysPerWeek>0){
				QString s= tr("Time constraint teachers interval max days per week broken for teacher: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalTeachersList[t]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));
				
				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);
			
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		this->maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetIntervalMaxDaysPerWeek::ConstraintStudentsSetIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsSetIntervalMaxDaysPerWeek::ConstraintStudentsSetIntervalMaxDaysPerWeek(double wp, int maxnd, const QString& sn, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_SET_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	/////////
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set interval max days per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetIntervalMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Students set interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set respects working in an hourly interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);
		
		c.changedForMatrixCalculation=false;
	}

	int nbroken;
	
	nbroken=0;
	
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students set interval max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));
			
				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);
		
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		this->maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsIntervalMaxDaysPerWeek::ConstraintStudentsIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsIntervalMaxDaysPerWeek::ConstraintStudentsIntervalMaxDaysPerWeek(double wp, int maxnd, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	return true;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsIntervalMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Students interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students respect working in an hourly interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;
	
	nbroken=0;
	
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students interval max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));
			
				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);
		
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	return true;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		this->maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesEndStudentsDay::ConstraintActivitiesEndStudentsDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_END_STUDENTS_DAY;
}

ConstraintActivitiesEndStudentsDay::ConstraintActivitiesEndStudentsDay(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut)
	: TimeConstraint(wp)
{
	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->type=CONSTRAINT_ACTIVITIES_END_STUDENTS_DAY;
}

bool ConstraintActivitiesEndStudentsDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		assert(this->nActivities < r.nInternalActivities);
		this->nActivities++;
		this->activitiesIndices.append(i);
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesEndStudentsDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintActivitiesEndStudentsDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesEndStudentsDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesEndStudentsDay>\n";
	return s;
}

QString ConstraintActivitiesEndStudentsDay::getDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString tc, st, su, at;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");
	
	QString s;
	s+=tr("Activities with %1, %2, %3, %4, must end students' day", "%1...%4 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Abbreviation for Weight Percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesEndStudentsDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
		
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	s+=tr("must end students' day");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesEndStudentsDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	for(int kk=0; kk<this->nActivities; kk++){
		int tmp=0;
		int ai=this->activitiesIndices[kk];
	
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
		
			for(int j=0; j<r.internalActivitiesList[ai].iSubgroupsList.count(); j++){
				int sb=r.internalActivitiesList[ai].iSubgroupsList.at(j);
				for(int hh=h+r.internalActivitiesList[ai].duration; hh<r.nHoursPerDay; hh++)
					if(subgroupsMatrix[sb][d][hh]>0){
						nbroken++;
						tmp=1;
						break;
					}
				if(tmp>0)
					break;
			}

			if(conflictsString!=nullptr && tmp>0){
				QString s=tr("Time constraint activities end students' day broken for activity with id=%1 (%2), increases conflicts total by %3",
				 "%1 is the id, %2 is the detailed description of the activity")
				 .arg(r.internalActivitiesList[ai].id)
				 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

				dl.append(s);
				cl.append(weightPercentage/100*tmp);
	
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivitiesEndStudentsDay::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	return true;
}

bool ConstraintActivitiesEndStudentsDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesEndStudentsDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesEndStudentsDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesEndStudentsDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesEndStudentsDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesEndStudentsDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesEndStudentsDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityEndsTeachersDay::ConstraintActivityEndsTeachersDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_ENDS_TEACHERS_DAY;
}

ConstraintActivityEndsTeachersDay::ConstraintActivityEndsTeachersDay(double wp, int actId)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->type = CONSTRAINT_ACTIVITY_ENDS_TEACHERS_DAY;
}

bool ConstraintActivityEndsTeachersDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"), 
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityEndsTeachersDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityEndsTeachersDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityEndsTeachersDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityEndsTeachersDay>\n";
	return s;
}

QString ConstraintActivityEndsTeachersDay::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) must end teachers' day",
		"%1 is the id, %2 is the detailed description of the activity.")
		.arg(getActivityDescription(r, this->activityId))
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityEndsTeachersDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity must end teachers' day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityEndsTeachersDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString> &dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		
		int i=this->activityIndex;
		for(int j=0; j<r.internalActivitiesList[i].iTeachersList.count(); j++){
			int tch=r.internalActivitiesList[i].iTeachersList.at(j);
			for(int hh=h+r.internalActivitiesList[i].duration; hh<r.nHoursPerDay; hh++)
				if(teachersMatrix[tch][d][hh]>0){
					nbroken=1;
					break;
				}
			if(nbroken>0)
				break;
		}
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity ends teachers' day broken for activity with id=%1 (%2), increases conflicts total by %3",
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(this->activityId)
		 .arg(getActivityDetailedDescription(r, this->activityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityEndsTeachersDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityEndsTeachersDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityEndsTeachersDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityEndsTeachersDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityEndsTeachersDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityEndsTeachersDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivityEndsTeachersDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivityEndsTeachersDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesEndTeachersDay::ConstraintActivitiesEndTeachersDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_END_TEACHERS_DAY;
}

ConstraintActivitiesEndTeachersDay::ConstraintActivitiesEndTeachersDay(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut)
	: TimeConstraint(wp)
{
	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->type=CONSTRAINT_ACTIVITIES_END_TEACHERS_DAY;
}

bool ConstraintActivitiesEndTeachersDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		assert(this->nActivities < MAX_ACTIVITIES);	
		this->nActivities++;
		this->activitiesIndices.append(i);
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesEndTeachersDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintActivitiesEndTeachersDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesEndTeachersDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesEndTeachersDay>\n";
	return s;
}

QString ConstraintActivitiesEndTeachersDay::getDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString tc, st, su, at;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");
	
	QString s;
	s+=tr("Activities with %1, %2, %3, %4, must end teachers' day", "%1...%4 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Abbreviation for Weight Percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesEndTeachersDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
		
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	s+=tr("must end teachers' day");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesEndTeachersDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString> &dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	for(int kk=0; kk<this->nActivities; kk++){
		int tmp=0;
		int ai=this->activitiesIndices[kk];
	
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
		
			for(int j=0; j<r.internalActivitiesList[ai].iTeachersList.count(); j++){
				int tch=r.internalActivitiesList[ai].iTeachersList.at(j);
				for(int hh=h+r.internalActivitiesList[ai].duration; hh<r.nHoursPerDay; hh++)
					if(teachersMatrix[tch][d][hh]>0){
						nbroken++;
						tmp=1;
						break;
					}
				if(tmp>0)
					break;
			}

			if(conflictsString!=nullptr && tmp>0){
				QString s=tr("Time constraint activities end teachers' day broken for activity with id=%1 (%2), increases conflicts total by %3",
				 "%1 is the id, %2 is the detailed description of the activity")
				 .arg(r.internalActivitiesList[ai].id)
				 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

				dl.append(s);
				cl.append(weightPercentage/100*tmp);
	
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivitiesEndTeachersDay::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	return true;
}

bool ConstraintActivitiesEndTeachersDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesEndTeachersDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesEndTeachersDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesEndTeachersDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesEndTeachersDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesEndTeachersDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesEndTeachersDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersActivityTagMaxHoursDaily::ConstraintTeachersActivityTagMaxHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY;
}

ConstraintTeachersActivityTagMaxHoursDaily::ConstraintTeachersActivityTagMaxHoursDaily(double wp, int maxhours, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);
	
	this->canonicalTeachersList.clear();
	for(int i=0; i<r.nInternalTeachers; i++){
		bool found=false;
	
		Teacher* tch=r.internalTeachersList[i];
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalTeachersList.append(i);
	}

	return true;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersActivityTagMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersActivityTagMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersActivityTagMaxHoursDaily>\n";
	return s;
}

QString ConstraintTeachersActivityTagMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers for activity tag %1 have max %2 hours daily").arg(this->activityTagName).arg(this->maxHoursDaily);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersActivityTagMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers, for an activity tag, must respect the maximum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName); s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersActivityTagMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;
	
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	nbroken=0;
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;
				
		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}
	
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;

			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr("Time constraint teachers activity tag %1 max %2 hours daily broken for teacher %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100.0);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersActivityTagMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherActivityTagMaxHoursDaily::ConstraintTeacherActivityTagMaxHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY;
}

ConstraintTeacherActivityTagMaxHoursDaily::ConstraintTeacherActivityTagMaxHoursDaily(double wp, int maxhours, const QString& teacher, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->teacherName=teacher;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	this->canonicalTeachersList.clear();
	int i=this->teacher_ID;
	bool found=false;
	
	Teacher* tch=r.internalTeachersList[i];
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
			found=true;
			break;
		}
	}
		
	if(found)
		this->canonicalTeachersList.append(i);

	return true;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherActivityTagMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherActivityTagMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherActivityTagMaxHoursDaily>\n";
	return s;
}

QString ConstraintTeacherActivityTagMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher %1 for activity tag %2 has max %3 hours daily").arg(this->teacherName).arg(this->activityTagName).arg(this->maxHoursDaily);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeacherActivityTagMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher for an activity tag must respect the maximum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherActivityTagMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	nbroken=0;
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;
				
		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}
	
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;

			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr("Time constraint teacher activity tag %1 max %2 hours daily broken for teacher %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100.0);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	return this->activityTagName==s->name;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherActivityTagMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsActivityTagMaxHoursDaily::ConstraintStudentsActivityTagMaxHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY;
	this->maxHoursDaily = -1;
}

ConstraintStudentsActivityTagMaxHoursDaily::ConstraintStudentsActivityTagMaxHoursDaily(double wp, int maxnh, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);
	
	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsActivityTagMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsActivityTagMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	
	if(this->maxHoursDaily>=0)
		s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	else
		assert(0);
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsActivityTagMaxHoursDaily>\n";
	return s;
}

QString ConstraintStudentsActivityTagMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students for activity tag %1 have max %2 hours daily")
		.arg(this->activityTagName).arg(this->maxHoursDaily); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsActivityTagMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students, for an activity tag, must respect the maximum number of hours daily"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsActivityTagMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken;

	nbroken=0;
	
	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;
				
			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students, activity tag %1, max %2 hours daily, broken for subgroup %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsActivityTagMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetActivityTagMaxHoursDaily::ConstraintStudentsSetActivityTagMaxHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY;
	this->maxHoursDaily = -1;
}

ConstraintStudentsSetActivityTagMaxHoursDaily::ConstraintStudentsSetActivityTagMaxHoursDaily(double wp, int maxnh, const QString& s, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->students = s;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetActivityTagMaxHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetActivityTagMaxHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetActivityTagMaxHoursDaily>\n";
	return s;
}

QString ConstraintStudentsSetActivityTagMaxHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set %1 for activity tag %2 has max %3 hours daily").arg(this->students).arg(this->activityTagName).arg(this->maxHoursDaily);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsSetActivityTagMaxHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set, for an activity tag, must respect the maximum number of hours daily"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours daily is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(this->iSubgroupsList)){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}
		
	return true;
}

double ConstraintStudentsSetActivityTagMaxHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	
	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;
				
			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students set, activity tag %1, max %2 hours daily, broken for subgroup %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetActivityTagMaxHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersActivityTagMinHoursDaily::ConstraintTeachersActivityTagMinHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MIN_HOURS_DAILY;
}

ConstraintTeachersActivityTagMinHoursDaily::ConstraintTeachersActivityTagMinHoursDaily(double wp, int minhours, int mindays, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursDaily=minhours;
	this->minDaysWithTag=mindays;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MIN_HOURS_DAILY;
}

bool ConstraintTeachersActivityTagMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);
	
	this->canonicalTeachersList.clear();
	for(int i=0; i<r.nInternalTeachers; i++){
		bool found=false;
	
		Teacher* tch=r.internalTeachersList[i];
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalTeachersList.append(i);
	}

	return true;
}

bool ConstraintTeachersActivityTagMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersActivityTagMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersActivityTagMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	s+=IL3+"<Minimum_Days_With_Tag>"+CustomFETString::number(this->minDaysWithTag)+"</Minimum_Days_With_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersActivityTagMinHoursDaily>\n";
	return s;
}

QString ConstraintTeachersActivityTagMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers for activity tag %1 have min %2 hours daily").arg(this->activityTagName).arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("mDWT:%1", "Min days with tag").arg(this->minDaysWithTag);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersActivityTagMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers, for an activity tag, must respect the minimum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName); s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily); s+="\n";
	s+=tr("Minimum days with tag=%1").arg(this->minDaysWithTag);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersActivityTagMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;
	
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	nbroken=0;
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;
		
		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}
		
		int nrd = r.nDaysPerWeek - this->minDaysWithTag;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;

			if(nd==0 && nrd>0){
				nrd--;
				continue;
			}
			if(nd<this->minHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr("Time constraint teachers activity tag %1 min %2 hours daily broken for teacher %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->minHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100.0);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100.0)
			assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintTeachersActivityTagMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersActivityTagMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersActivityTagMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintTeachersActivityTagMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;
	
	if(minDaysWithTag>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintTeachersActivityTagMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersActivityTagMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;
	
	if(minDaysWithTag>r.nDaysPerWeek)
		minDaysWithTag=r.nDaysPerWeek;
	
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherActivityTagMinHoursDaily::ConstraintTeacherActivityTagMinHoursDaily()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MIN_HOURS_DAILY;
}

ConstraintTeacherActivityTagMinHoursDaily::ConstraintTeacherActivityTagMinHoursDaily(double wp, int minhours, int mindays, const QString& teacher, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursDaily=minhours;
	this->minDaysWithTag=mindays;
	this->teacherName=teacher;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MIN_HOURS_DAILY;
}

bool ConstraintTeacherActivityTagMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	this->canonicalTeachersList.clear();
	int i=this->teacher_ID;
	bool found=false;
	
	Teacher* tch=r.internalTeachersList[i];
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
			found=true;
			break;
		}
	}
		
	if(found)
		this->canonicalTeachersList.append(i);

	return true;
}

bool ConstraintTeacherActivityTagMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherActivityTagMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherActivityTagMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	s+=IL3+"<Minimum_Days_With_Tag>"+CustomFETString::number(this->minDaysWithTag)+"</Minimum_Days_With_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherActivityTagMinHoursDaily>\n";
	return s;
}

QString ConstraintTeacherActivityTagMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher %1 for activity tag %2 has min %3 hours daily").arg(this->teacherName).arg(this->activityTagName).arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("mDWT:%1", "Min days with tag").arg(this->minDaysWithTag);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeacherActivityTagMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher for an activity tag must respect the minimum number of hours daily");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily); s+="\n";
	s+=tr("Minimum days with tag=%1").arg(this->minDaysWithTag);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherActivityTagMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	nbroken=0;
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;
				
		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}
	
		int nrd = r.nDaysPerWeek - this->minDaysWithTag;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;

			if(nd==0 && nrd>0){
				nrd--;
				continue;
			}
			if(nd<this->minHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr("Time constraint teacher activity tag %1 min %2 hours daily broken for teacher %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->minHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100.0);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100.0)
			assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintTeacherActivityTagMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherActivityTagMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherActivityTagMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	return this->activityTagName==s->name;
}

bool ConstraintTeacherActivityTagMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;

	if(minDaysWithTag>r.nDaysPerWeek)
		return true;

	return false;
}

bool ConstraintTeacherActivityTagMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherActivityTagMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;

	if(minDaysWithTag>r.nDaysPerWeek)
		minDaysWithTag=r.nDaysPerWeek;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsActivityTagMinHoursDaily::ConstraintStudentsActivityTagMinHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MIN_HOURS_DAILY;
	this->minHoursDaily = -1;
}

ConstraintStudentsActivityTagMinHoursDaily::ConstraintStudentsActivityTagMinHoursDaily(double wp, int minnh, int mindays, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->minHoursDaily = minnh;
	this->minDaysWithTag=mindays;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MIN_HOURS_DAILY;
}

bool ConstraintStudentsActivityTagMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);
	
	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

bool ConstraintStudentsActivityTagMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsActivityTagMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsActivityTagMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	
	if(this->minHoursDaily>=0)
		s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	else
		assert(0);

	s+=IL3+"<Minimum_Days_With_Tag>"+CustomFETString::number(this->minDaysWithTag)+"</Minimum_Days_With_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsActivityTagMinHoursDaily>\n";
	return s;
}

QString ConstraintStudentsActivityTagMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students for activity tag %1 have min %2 hours daily")
		.arg(this->activityTagName).arg(this->minHoursDaily); s+=translatedCommaSpace();
	s+=tr("mDWT:%1", "Min days with tag").arg(this->minDaysWithTag);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsActivityTagMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students, for an activity tag, must respect the minimum number of hours daily"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Minimum days with tag=%1").arg(this->minDaysWithTag);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsActivityTagMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken;

	nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	
	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		int nrd = r.nDaysPerWeek - this->minDaysWithTag;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;
				
			if(nd==0 && nrd>0){
				nrd--;
				continue;
			}
			if(nd<this->minHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students, activity tag %1, min %2 hours daily, broken for subgroup %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->minHoursDaily))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100.0)
			assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintStudentsActivityTagMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsActivityTagMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsActivityTagMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsActivityTagMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintStudentsActivityTagMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsActivityTagMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;
	
	if(minDaysWithTag>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsActivityTagMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsActivityTagMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;

	if(minDaysWithTag>r.nDaysPerWeek)
		minDaysWithTag=r.nDaysPerWeek;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetActivityTagMinHoursDaily::ConstraintStudentsSetActivityTagMinHoursDaily()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MIN_HOURS_DAILY;
	this->minHoursDaily = -1;
}

ConstraintStudentsSetActivityTagMinHoursDaily::ConstraintStudentsSetActivityTagMinHoursDaily(double wp, int minnh, int mindays, const QString& s, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->minHoursDaily = minnh;
	this->minDaysWithTag=mindays;
	this->students = s;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MIN_HOURS_DAILY;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetActivityTagMinHoursDaily::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetActivityTagMinHoursDaily>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	s+=IL3+"<Minimum_Days_With_Tag>"+CustomFETString::number(this->minDaysWithTag)+"</Minimum_Days_With_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetActivityTagMinHoursDaily>\n";
	return s;
}

QString ConstraintStudentsSetActivityTagMinHoursDaily::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set %1 for activity tag %2 has min %3 hours daily").arg(this->students).arg(this->activityTagName).arg(this->minHoursDaily);
	s+=translatedCommaSpace();
	s+=tr("mDWT:%1", "Min days with tag").arg(this->minDaysWithTag);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsSetActivityTagMinHoursDaily::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set, for an activity tag, must respect the minimum number of hours daily"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Minimum days with tag=%1").arg(this->minDaysWithTag);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min hours daily is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(this->iSubgroupsList)){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}
		
	return true;
}

double ConstraintStudentsSetActivityTagMinHoursDaily::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	nbroken=0;
	
	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		int nrd = r.nDaysPerWeek - this->minDaysWithTag;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d][h]==this->activityTagIndex)
					nd++;
				
			if(nd==0 && nrd>0){
				nrd--;
				continue;
			}
			if(nd<this->minHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students set, activity tag %1, min %2 hours daily, broken for subgroup %3, on day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->minHoursDaily))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100.0)
			assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>r.nHoursPerDay)
		return true;
	
	if(minDaysWithTag>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetActivityTagMinHoursDaily::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minHoursDaily>r.nHoursPerDay)
		minHoursDaily=r.nHoursPerDay;

	if(minDaysWithTag>r.nDaysPerWeek)
		minDaysWithTag=r.nDaysPerWeek;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxGapsPerDay::ConstraintStudentsMaxGapsPerDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_DAY;
}

ConstraintStudentsMaxGapsPerDay::ConstraintStudentsMaxGapsPerDay(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_DAY;
	this->maxGaps=mg;
}

bool ConstraintStudentsMaxGapsPerDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxGapsPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxGapsPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxGapsPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxGapsPerDay>\n";
	return s;
}

QString ConstraintStudentsMaxGapsPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students max gaps per day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per day)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintStudentsMaxGapsPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of gaps per day");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per day=%1").arg(this->maxGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxGapsPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nGaps;
	int tmp;
	int i;
	
	int tIllegalGaps=0;

	for(i=0; i<r.nInternalSubgroups; i++){
		for(int j=0; j<r.nDaysPerWeek; j++){
			nGaps=0;
	
			int k;
			tmp=0;
			for(k=0; k<r.nHoursPerDay; k++)
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
				if(subgroupsMatrix[i][j][k]>0){
					nGaps+=tmp;
					tmp=0;
				}
				else
					tmp++;
			}
		
			int illegalGaps=nGaps-this->maxGaps;
			if(illegalGaps<0)
				illegalGaps=0;

			if(illegalGaps>0 && conflictsString!=nullptr){
				QString s=tr("Time constraint students max gaps per day broken for subgroup: %1, it has %2 extra gaps, on day %3, conflicts increase=%4")
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(illegalGaps)
				 .arg(r.daysOfTheWeek[j])
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(illegalGaps*weightPercentage/100));
				
				dl.append(s);
				cl.append(illegalGaps*weightPercentage/100);
				
				*conflictsString+= s+"\n";
			}
		
			tIllegalGaps+=illegalGaps;
		}
	}
	
	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsMaxGapsPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxGapsPerDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxGapsPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxGapsPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsMaxGapsPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMaxGapsPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nHoursPerDay)
		maxGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxGapsPerDay::ConstraintStudentsSetMaxGapsPerDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_DAY;
}

ConstraintStudentsSetMaxGapsPerDay::ConstraintStudentsSetMaxGapsPerDay(double wp, int mg, const QString& st )
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_DAY;
	this->maxGaps=mg;
	this->students = st;
}

bool ConstraintStudentsSetMaxGapsPerDay::computeInternalStructure(QWidget* parent, Rules& r){
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max gaps per day is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

bool ConstraintStudentsSetMaxGapsPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxGapsPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxGapsPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxGapsPerDay>\n";
	return s;
}

QString ConstraintStudentsSetMaxGapsPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set max gaps per day"); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage)); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per day)").arg(this->maxGaps);s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxGapsPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of gaps per day");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per day=%1").arg(this->maxGaps);s+="\n";
	s+=tr("Students=%1").arg(this->students); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintStudentsSetMaxGapsPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//OLD COMMENT
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nGaps;
	int tmp;
	
	int tIllegalGaps=0;
	
	for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
		int i=this->iSubgroupsList.at(sg);
		for(int j=0; j<r.nDaysPerWeek; j++){
			nGaps=0;
	
			int k;
			tmp=0;
			for(k=0; k<r.nHoursPerDay; k++)
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
				if(subgroupsMatrix[i][j][k]>0){
					nGaps+=tmp;
					tmp=0;
				}
				else
					tmp++;
			}
		
			int illegalGaps=nGaps-this->maxGaps;
			if(illegalGaps<0)
				illegalGaps=0;

			if(illegalGaps>0 && conflictsString!=nullptr){
				QString s=tr("Time constraint students set max gaps per day broken for subgroup: %1, extra gaps=%2, on day %3, conflicts increase=%4")
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(illegalGaps)
				 .arg(r.daysOfTheWeek[j])
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*illegalGaps));
				
				dl.append(s);
				cl.append(weightPercentage/100*illegalGaps);
				
				*conflictsString+= s+"\n";
			}
		
			tIllegalGaps+=illegalGaps;
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)     //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsSetMaxGapsPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxGapsPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsSetMaxGapsPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMaxGapsPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxGaps>r.nHoursPerDay)
		maxGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::ConstraintActivitiesOccupyMaxTimeSlotsFromSelection()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TIME_SLOTS_FROM_SELECTION;
}

ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::ConstraintActivitiesOccupyMaxTimeSlotsFromSelection(double wp,
	const QList<int>& a_L, const QList<int>& d_L, const QList<int>& h_L, int max_slots)
	: TimeConstraint(wp)
{
	assert(d_L.count()==h_L.count());

	this->activitiesIds=a_L;
	this->selectedDays=d_L;
	this->selectedHours=h_L;
	this->maxOccupiedTimeSlots=max_slots;
	
	this->type=CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TIME_SLOTS_FROM_SELECTION;
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();
	
	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());
	
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/
			
	//////////////////////
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy max time slots from selection is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy max time slots from selection is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy max time slots from selection is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy max time slots from selection is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::getXmlDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintActivitiesOccupyMaxTimeSlotsFromSelection>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";
	
	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}
	s+=IL3+"<Max_Number_of_Occupied_Time_Slots>"+CustomFETString::number(this->maxOccupiedTimeSlots)+"</Max_Number_of_Occupied_Time_Slots>\n";
	
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesOccupyMaxTimeSlotsFromSelection>\n";
	return s;
}

QString ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Activities occupy max time slots from selection, WP:%1%, NA:%2, A: %3, STS: %4, MTS:%5", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, STS means selected time slots, MTS means max time slots")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(timeslots)
	 .arg(CustomFETString::number(this->maxOccupiedTimeSlots));
	
	return begin+s+end;
}

QString ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::getDetailedDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities occupy max time slots from selection"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	s+=tr("Maximum number of occupied slots from selection=%1").arg(CustomFETString::number(this->maxOccupiedTimeSlots)); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	///////////////////
	Matrix2D<bool> used;
	used.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			used[d][h]=false;
	
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<act->duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				used[d][h+dur]=true;
			}
		}
	}

	int cnt=0;
	assert(this->selectedDays.count()==this->selectedHours.count());
	for(int t=0; t<this->selectedDays.count(); t++){
		int d=this->selectedDays.at(t);
		int h=this->selectedHours.at(t);
		
		if(used[d][h])
			cnt++;
	}

	nbroken=0;
	
	if(cnt > this->maxOccupiedTimeSlots){
		nbroken=1;
	
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
			
			dl.append(s);
			cl.append(weightPercentage/100.0);
		
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;
			
	if(maxOccupiedTimeSlots>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesOccupyMaxTimeSlotsFromSelection::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;
	
	if(maxOccupiedTimeSlots>r.nDaysPerWeek*r.nHoursPerDay)
		maxOccupiedTimeSlots=r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesOccupyMinTimeSlotsFromSelection::ConstraintActivitiesOccupyMinTimeSlotsFromSelection()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_OCCUPY_MIN_TIME_SLOTS_FROM_SELECTION;
}

ConstraintActivitiesOccupyMinTimeSlotsFromSelection::ConstraintActivitiesOccupyMinTimeSlotsFromSelection(double wp,
	const QList<int>& a_L, const QList<int>& d_L, const QList<int>& h_L, int min_slots)
	: TimeConstraint(wp)
{
	assert(d_L.count()==h_L.count());

	this->activitiesIds=a_L;
	this->selectedDays=d_L;
	this->selectedHours=h_L;
	this->minOccupiedTimeSlots=min_slots;
	
	this->type=CONSTRAINT_ACTIVITIES_OCCUPY_MIN_TIME_SLOTS_FROM_SELECTION;
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();
	
	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());
	
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/
			
	//////////////////////
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy min time slots from selection is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy min time slots from selection is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy min time slots from selection is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities occupy min time slots from selection is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesOccupyMinTimeSlotsFromSelection::getXmlDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintActivitiesOccupyMinTimeSlotsFromSelection>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";
	
	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}
	s+=IL3+"<Min_Number_of_Occupied_Time_Slots>"+CustomFETString::number(this->minOccupiedTimeSlots)+"</Min_Number_of_Occupied_Time_Slots>\n";
	
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesOccupyMinTimeSlotsFromSelection>\n";
	return s;
}

QString ConstraintActivitiesOccupyMinTimeSlotsFromSelection::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
		
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Activities occupy min time slots from selection, WP:%1%, NA:%2, A: %3, STS: %4, mTS:%5", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, STS means selected time slots, mTS means min time slots")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(timeslots)
	 .arg(CustomFETString::number(this->minOccupiedTimeSlots));
	
	return begin+s+end;
}

QString ConstraintActivitiesOccupyMinTimeSlotsFromSelection::getDetailedDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities occupy min time slots from selection"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	s+=tr("Minimum number of occupied slots from selection=%1").arg(CustomFETString::number(this->minOccupiedTimeSlots)); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesOccupyMinTimeSlotsFromSelection::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	///////////////////
	Matrix2D<bool> used;
	used.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			used[d][h]=false;
	
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<act->duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				used[d][h+dur]=true;
			}
		}
	}

	int cnt=0;
	assert(this->selectedDays.count()==this->selectedHours.count());
	for(int t=0; t<this->selectedDays.count(); t++){
		int d=this->selectedDays.at(t);
		int h=this->selectedHours.at(t);
		
		if(used[d][h])
			cnt++;
	}

	nbroken=0;
	
	if(cnt < this->minOccupiedTimeSlots){
		nbroken=1;
	
		if(conflictsString!=nullptr){
			QString s;
			if(c.nPlacedActivities==r.nInternalActivities){
				s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
				 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
			}
			else{
				s=tr("Time constraint %1 broken for the partial timetable.").arg(this->getDescription(r));
				s+=" ";
				s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			}
			
			dl.append(s);
			cl.append(weightPercentage/100.0);
		
			*conflictsString+= s+"\n";
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100.0)
			assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesOccupyMinTimeSlotsFromSelection::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesOccupyMinTimeSlotsFromSelection::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;
			
	if(minOccupiedTimeSlots>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesOccupyMinTimeSlotsFromSelection::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;
	
	if(minOccupiedTimeSlots>r.nDaysPerWeek*r.nHoursPerDay)
		minOccupiedTimeSlots=r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_MAX_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS;
}

ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots(double wp,
	const QList<int>& a_L, const QList<int>& d_L, const QList<int>& h_L, int max_simultaneous)
	: TimeConstraint(wp)
{
	assert(d_L.count()==h_L.count());

	this->activitiesIds=a_L;
	this->selectedDays=d_L;
	this->selectedHours=h_L;
	this->maxSimultaneous=max_simultaneous;
	
	this->type=CONSTRAINT_ACTIVITIES_MAX_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS;
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();
	
	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());
	
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/
			
	//////////////////////
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max simultaneous in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max simultaneous in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max simultaneous in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max simultaneous in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";
	
	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}
	s+=IL3+"<Max_Number_of_Simultaneous_Activities>"+CustomFETString::number(this->maxSimultaneous)+"</Max_Number_of_Simultaneous_Activities>\n";
	
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Activities max simultaneous in selected time slots, WP:%1%, NA:%2, A: %3, STS: %4, MS:%5", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, STS means selected time slots, MS means max simultaneous (number of activities in each selected time slot)")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(timeslots)
	 .arg(CustomFETString::number(this->maxSimultaneous));
	
	return begin+s+end;
}

QString ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::getDetailedDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities max simultaneous in selected time slots"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	s+=tr("Maximum number of simultaneous activities in each selected time slot=%1").arg(CustomFETString::number(this->maxSimultaneous)); s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

///////////////////

	Matrix2D<int> count;
	count.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			count[d][h]=0;
	
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<act->duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				count[d][h+dur]++;
			}
		}
	}

	nbroken=0;

	assert(this->selectedDays.count()==this->selectedHours.count());
	for(int t=0; t<this->selectedDays.count(); t++){
		int d=this->selectedDays.at(t);
		int h=this->selectedHours.at(t);
		
		if(count[d][h] > this->maxSimultaneous)
			nbroken++;
	}

	if(nbroken>0){
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
			
			dl.append(s);
			cl.append(weightPercentage/100.0);
		
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;

	//Do not care about maxSimultaneous, which can be as high as MAX_ACTIVITIES

	return false;
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesMaxSimultaneousInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;

	//Do not modify maxSimultaneous, which can be as high as MAX_ACTIVITIES
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::ConstraintActivitiesMinSimultaneousInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_MIN_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS;
}

ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::ConstraintActivitiesMinSimultaneousInSelectedTimeSlots(double wp,
	const QList<int>& a_L, const QList<int>& d_L, const QList<int>& h_L, int min_simultaneous, bool allow_empty_slots)
	: TimeConstraint(wp)
{
	assert(d_L.count()==h_L.count());

	this->activitiesIds=a_L;
	this->selectedDays=d_L;
	this->selectedHours=h_L;
	this->minSimultaneous=min_simultaneous;
	this->allowEmptySlots=allow_empty_slots;
	
	this->type=CONSTRAINT_ACTIVITIES_MIN_SIMULTANEOUS_IN_SELECTED_TIME_SLOTS;
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();
	
	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());
	
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/
			
	//////////////////////
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities min simultaneous in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities min simultaneous in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities min simultaneous in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities min simultaneous in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintActivitiesMinSimultaneousInSelectedTimeSlots>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";
	
	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}
	s+=IL3+"<Min_Number_of_Simultaneous_Activities>"+CustomFETString::number(this->minSimultaneous)+"</Min_Number_of_Simultaneous_Activities>\n";
	s+=IL3+"<Allow_Empty_Slots>"+trueFalse(allowEmptySlots)+"</Allow_Empty_Slots>\n";
	
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesMinSimultaneousInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Activities min simultaneous in selected time slots, WP:%1%, NA:%2, A: %3, STS: %4, mS:%5, AES=%6", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, STS means selected time slots, mS means min simultaneous (number of activities in each selected time slot), "
	 "AES means allow empty slots.")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(timeslots)
	 .arg(CustomFETString::number(this->minSimultaneous))
	 .arg(yesNoTranslated(allowEmptySlots));
	
	return begin+s+end;
}

QString ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::getDetailedDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities min simultaneous in selected time slots"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	s+=tr("Minimum number of simultaneous activities in each selected time slot=%1").arg(CustomFETString::number(this->minSimultaneous)); s+="\n";
	s+=tr("Allow empty slots=%1").arg(yesNoTranslated(allowEmptySlots)); s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

///////////////////

	Matrix2D<int> count;
	count.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			count[d][h]=0;
	
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<act->duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				count[d][h+dur]++;
			}
		}
	}

	nbroken=0;

	assert(this->selectedDays.count()==this->selectedHours.count());
	for(int t=0; t<this->selectedDays.count(); t++){
		int d=this->selectedDays.at(t);
		int h=this->selectedHours.at(t);
		
		if(allowEmptySlots && count[d][h]>0 && count[d][h] < this->minSimultaneous)
			nbroken++;
		else if(!allowEmptySlots && count[d][h] < this->minSimultaneous)
			nbroken++;
	}

	if(nbroken>0){
		if(conflictsString!=nullptr){
			QString s;
			if(c.nPlacedActivities==r.nInternalActivities){
				s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
				 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
			}
			else{
				s=tr("Time constraint %1 broken for the partial timetable.").arg(this->getDescription(r));
				s+=" ";
				s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			}

			dl.append(s);
			cl.append(weightPercentage/100.0);
		
			*conflictsString+= s+"\n";
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100.0)
			assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;

	//Do not care about minSimultaneous, which can be as high as MAX_ACTIVITIES

	return false;
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesMinSimultaneousInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;

	//Do not modify minSimultaneous, which can be as high as MAX_ACTIVITIES
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_MAX_TOTAL_ACTIVITIES_FROM_SET_IN_SELECTED_TIME_SLOTS;
}

ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots(double wp,
	const QList<int>& a_L, const QList<int>& d_L, const QList<int>& h_L, int max_activities)
	: TimeConstraint(wp)
{
	assert(d_L.count()==h_L.count());

	this->activitiesIds=a_L;
	this->selectedDays=d_L;
	this->selectedHours=h_L;
	this->maxActivities=max_activities;

	this->type=CONSTRAINT_MAX_TOTAL_ACTIVITIES_FROM_SET_IN_SELECTED_TIME_SLOTS;
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();

	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());

	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/

	//////////////////////
	assert(this->selectedDays.count()==this->selectedHours.count());

	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint max total activities from set in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint max total activities from set in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint max total activities from set in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint max total activities from set in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
	}
	///////////////////////

	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive

	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots>\n";

	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}
	s+=IL3+"<Max_Total_Number_of_Activities>"+CustomFETString::number(this->maxActivities)+"</Max_Total_Number_of_Activities>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	QString s=tr("Max total activities from set in selected time slots, WP:%1%, NA:%2, A: %3, STS: %4, MA:%5", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, STS means selected time slots, MA means max number of activities.")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(timeslots)
	 .arg(CustomFETString::number(this->maxActivities));

	return begin+s+end;
}

QString ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::getDetailedDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Max total activities from set in selected time slots"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	s+=tr("Maximum total number of activities in selected time slots=%1").arg(CustomFETString::number(this->maxActivities)); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

///////////////////

	QSet<int> selectedTimeSlotsSet;
	for(int i=0; i<this->selectedDays.count(); i++)
		selectedTimeSlotsSet.insert(selectedDays.at(i)+selectedHours.at(i)*r.nDaysPerWeek);

	int cnt=0;
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			for(int dur=0; dur<act->duration; dur++){
				if(selectedTimeSlotsSet.contains(c.times[ai]+dur*r.nDaysPerWeek)){
					cnt++;
					break;
				}
			}
		}
	}

	nbroken=0;

	if(cnt > this->maxActivities)
		nbroken++;

	if(nbroken>0){
		if(conflictsString!=nullptr){
			QString s;
			s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));

			dl.append(s);
			cl.append(weightPercentage/100.0);

			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::removeUseless(Rules& r)
{
	QList<int> newActs;

	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}

	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());

	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;

	//Do not care about minSimultaneous, which can be as high as MAX_ACTIVITIES

	return false;
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintMaxTotalActivitiesFromSetInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(selectedDays.count()==selectedHours.count());

	QList<int> newDays;
	QList<int> newHours;

	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}

	selectedDays=newDays;
	selectedHours=newHours;

	//Do not modify minSimultaneous, which can be as high as MAX_ACTIVITIES

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesMaxInATerm::ConstraintActivitiesMaxInATerm()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_MAX_IN_A_TERM;
}

ConstraintActivitiesMaxInATerm::ConstraintActivitiesMaxInATerm(double wp,
	const QList<int>& a_L, int max_acts)
	: TimeConstraint(wp)
{
	this->activitiesIds=a_L;
	this->maxActivitiesInATerm=max_acts;

	this->type=CONSTRAINT_ACTIVITIES_MAX_IN_A_TERM;
}

bool ConstraintActivitiesMaxInATerm::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();

	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());

	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/

	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesMaxInATerm::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive

	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesMaxInATerm::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesMaxInATerm>\n";

	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";

	s+=IL3+"<Max_Number_of_Activities_in_A_Term>"+CustomFETString::number(this->maxActivitiesInATerm)+"</Max_Number_of_Activities_in_A_Term>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesMaxInATerm>\n";
	return s;
}

QString ConstraintActivitiesMaxInATerm::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());

	QString s=tr("Activities max in a term, WP:%1%, NA:%2, A: %3, MAIAT:%4", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, MAIAT means max activities in a term")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(CustomFETString::number(this->maxActivitiesInATerm));

	return begin+s+end;
}

QString ConstraintActivitiesMaxInATerm::getDetailedDescription(Rules& r)
{
	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities max in a term"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Maximum number of activities in a term=%1").arg(CustomFETString::number(this->maxActivitiesInATerm)); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesMaxInATerm::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	Matrix1D<int> cnt;
	cnt.resize(r.nTerms);
	for(int i=0; i<r.nTerms; i++)
		cnt[i]=0;
	for(int ai : std::as_const(this->_activitiesIndices))
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int term=d/r.nDaysPerTerm;
			cnt[term]++;
		}

	nbroken=0;

	for(int i=0; i<r.nTerms; i++)
		if(cnt[i]>maxActivitiesInATerm)
			nbroken++;

	if(nbroken>0){
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));

			dl.append(s);
			cl.append(weightPercentage/100.0);

			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesMaxInATerm::removeUseless(Rules& r)
{
	QList<int> newActs;

	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}

	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesMaxInATerm::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesMaxInATerm::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesMaxInATerm::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesMaxInATerm::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxInATerm::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxInATerm::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxInATerm::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintActivitiesMaxInATerm::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintActivitiesMaxInATerm::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesOccupyMaxTerms::ConstraintActivitiesOccupyMaxTerms()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TERMS;
}

ConstraintActivitiesOccupyMaxTerms::ConstraintActivitiesOccupyMaxTerms(double wp,
	const QList<int>& a_L, int max_occupied)
	: TimeConstraint(wp)
{
	this->activitiesIds=a_L;
	this->maxOccupiedTerms=max_occupied;

	this->type=CONSTRAINT_ACTIVITIES_OCCUPY_MAX_TERMS;
}

bool ConstraintActivitiesOccupyMaxTerms::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();

	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());

	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/

	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesOccupyMaxTerms::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive

	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesOccupyMaxTerms::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesOccupyMaxTerms>\n";

	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";

	s+=IL3+"<Max_Number_of_Occupied_Terms>"+CustomFETString::number(this->maxOccupiedTerms)+"</Max_Number_of_Occupied_Terms>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesOccupyMaxTerms>\n";
	return s;
}

QString ConstraintActivitiesOccupyMaxTerms::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());

	QString s=tr("Activities occupy max terms, WP:%1%, NA:%2, A: %3, MOT:%4", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, MOT means max occupied terms")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(CustomFETString::number(this->maxOccupiedTerms));

	return begin+s+end;
}

QString ConstraintActivitiesOccupyMaxTerms::getDetailedDescription(Rules& r)
{
	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities occupy max terms"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Maximum number of occupied terms=%1").arg(CustomFETString::number(this->maxOccupiedTerms)); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesOccupyMaxTerms::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	Matrix1D<bool> occupiedTerm;
	occupiedTerm.resize(r.nTerms);
	for(int i=0; i<r.nTerms; i++)
		occupiedTerm[i]=false;
	for(int ai : std::as_const(this->_activitiesIndices))
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int term=d/r.nDaysPerTerm;
			occupiedTerm[term]=true;
		}

	nbroken=0;

	int cnt=0;
	for(int i=0; i<r.nTerms; i++)
		if(occupiedTerm[i])
			cnt++;

	if(cnt>maxOccupiedTerms)
		nbroken++;

	if(nbroken>0){
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));

			dl.append(s);
			cl.append(weightPercentage/100.0);

			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesOccupyMaxTerms::removeUseless(Rules& r)
{
	QList<int> newActs;

	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}

	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesOccupyMaxTerms::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesOccupyMaxTerms::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesOccupyMaxTerms::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesOccupyMaxTerms::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMaxTerms::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMaxTerms::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMaxTerms::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintActivitiesOccupyMaxTerms::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintActivitiesOccupyMaxTerms::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxDaysPerWeek::ConstraintStudentsSetMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsSetMaxDaysPerWeek::ConstraintStudentsSetMaxDaysPerWeek(double wp, int maxnd, const QString& sn)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_DAYS_PER_WEEK;
}

bool ConstraintStudentsSetMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max days per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

bool ConstraintStudentsSetMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Students set max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);
		
		c.changedForMatrixCalculation=false;
	}

	int nbroken;
	
	nbroken=0;
	
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students set max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));
			
				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);
		
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsSetMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		this->maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxDaysPerWeek::ConstraintStudentsMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsMaxDaysPerWeek::ConstraintStudentsMaxDaysPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_MAX_DAYS_PER_WEEK;
}

bool ConstraintStudentsMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsMaxDaysPerWeek::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Students max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsMaxDaysPerWeek::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;
	
	nbroken=0;
	
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));
			
				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);
		
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	return true;
}

bool ConstraintStudentsMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintStudentsMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxDaysPerWeek>r.nDaysPerWeek)
		this->maxDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxSpanPerDay::ConstraintTeacherMaxSpanPerDay()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_SPAN_PER_DAY;
	this->maxSpanPerDay = -1;
	allowOneDayExceptionPlusOne=false;
}

ConstraintTeacherMaxSpanPerDay::ConstraintTeacherMaxSpanPerDay(double wp, int maxspan, bool except, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(maxspan>0);
	this->maxSpanPerDay=maxspan;
	this->teacherName=teacher;

	allowOneDayExceptionPlusOne=except;

	this->type=CONSTRAINT_TEACHER_MAX_SPAN_PER_DAY;
}

bool ConstraintTeacherMaxSpanPerDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxSpanPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxSpanPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxSpanPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Allow_One_Day_Exception_of_Plus_One>"+trueFalse(allowOneDayExceptionPlusOne)+"</Allow_One_Day_Exception_of_Plus_One>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxSpanPerDay>\n";
	return s;
}

QString ConstraintTeacherMaxSpanPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher max span per day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MS:%1", "Maximum span (in hours, per day)").arg(this->maxSpanPerDay);s+=translatedCommaSpace();
	s+=tr("ODE:%1", "One day exception (in which the teacher can have span+1)").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));

	return begin+s+end;
}

QString ConstraintTeacherMaxSpanPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of span (in hours) per day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";
	s+=tr("Allow one day exception of plus one=%1").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxSpanPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;
	
	bool except;
	if(allowOneDayExceptionPlusOne)
		except=true;
	else
		except=false;
	
	for(int d=0; d<r.nDaysPerWeek; d++){
		int begin=-1;
		int end=-1;
		for(int h=0; h<r.nHoursPerDay; h++)
			if(teachersMatrix[this->teacher_ID][d][h]>0){
				begin=h;
				break;
			}
		for(int h=r.nHoursPerDay-1; h>=0; h--)
			if(teachersMatrix[this->teacher_ID][d][h]>0){
				end=h;
				break;
			}
		if(end>=0 && begin>=0 && end>=begin){
			int span=end-begin+1;
			if(span>this->maxSpanPerDay){
				if(except && span==maxSpanPerDay+1)
					except=false;
				else
					nbroken++;
			}
		}
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintTeacherMaxSpanPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxSpanPerDay::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxSpanPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSpanPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSpanPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSpanPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMaxSpanPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxSpanPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxSpanPerDay>r.nHoursPerDay)
		maxSpanPerDay=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxSpanPerDay::ConstraintTeachersMaxSpanPerDay()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_SPAN_PER_DAY;
	this->maxSpanPerDay = -1;
	allowOneDayExceptionPlusOne=false;
}

ConstraintTeachersMaxSpanPerDay::ConstraintTeachersMaxSpanPerDay(double wp, int maxspan, bool except)
 : TimeConstraint(wp)
 {
	assert(maxspan>0);
	this->maxSpanPerDay=maxspan;
	
	allowOneDayExceptionPlusOne=except;

	this->type=CONSTRAINT_TEACHERS_MAX_SPAN_PER_DAY;
}

bool ConstraintTeachersMaxSpanPerDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxSpanPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxSpanPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxSpanPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Allow_One_Day_Exception_of_Plus_One>"+trueFalse(allowOneDayExceptionPlusOne)+"</Allow_One_Day_Exception_of_Plus_One>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxSpanPerDay>\n";
	return s;
}

QString ConstraintTeachersMaxSpanPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers max span per day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MS:%1", "Maximum span (in hours, per day)").arg(this->maxSpanPerDay);s+=translatedCommaSpace();
	s+=tr("ODE:%1", "One day exception (in which the teachers can have span+1)").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));

	return begin+s+end;
}

QString ConstraintTeachersMaxSpanPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of span (in hours) per day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";
	s+=tr("Allow one day exception of plus one=%1").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxSpanPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;
	
	for(int tch=0; tch<r.nInternalTeachers; tch++){
		bool except;
		if(allowOneDayExceptionPlusOne)
			except=true;
		else
			except=false;

		for(int d=0; d<r.nDaysPerWeek; d++){
			int begin=-1;
			int end=-1;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[tch][d][h]>0){
					begin=h;
					break;
				}
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(teachersMatrix[tch][d][h]>0){
					end=h;
					break;
				}
			if(end>=0 && begin>=0 && end>=begin){
				int span=end-begin+1;
				if(span>this->maxSpanPerDay){
					if(except && span==maxSpanPerDay+1)
						except=false;
					else
						nbroken++;
				}
			}
		}
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintTeachersMaxSpanPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxSpanPerDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxSpanPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSpanPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSpanPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSpanPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMaxSpanPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxSpanPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxSpanPerDay>r.nHoursPerDay)
		maxSpanPerDay=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxSpanPerDay::ConstraintStudentsSetMaxSpanPerDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_DAY;
	this->maxSpanPerDay = -1;
}

ConstraintStudentsSetMaxSpanPerDay::ConstraintStudentsSetMaxSpanPerDay(double wp, int maxspan, const QString& sn)
	: TimeConstraint(wp)
{
	this->maxSpanPerDay = maxspan;
	this->students = sn;
	this->type = CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_DAY;
}

bool ConstraintStudentsSetMaxSpanPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxSpanPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxSpanPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxSpanPerDay>\n";
	return s;
}

QString ConstraintStudentsSetMaxSpanPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set max span per day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students); s+=translatedCommaSpace();
	s+=tr("MS:%1", "Max span (in hours, per day)").arg(this->maxSpanPerDay);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxSpanPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of span (in hours) per day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMaxSpanPerDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max span per day is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

double ConstraintStudentsSetMaxSpanPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;
	
	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<r.nDaysPerWeek; d++){
			int begin=-1;
			int end=-1;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(subgroupsMatrix[sbg][d][h]>0){
					begin=h;
					break;
				}
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(subgroupsMatrix[sbg][d][h]>0){
					end=h;
					break;
				}
			if(end>=0 && begin>=0 && end>=begin){
				int span=end-begin+1;
				if(span>this->maxSpanPerDay)
					nbroken++;
			}
		}
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintStudentsSetMaxSpanPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxSpanPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMaxSpanPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMaxSpanPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxSpanPerDay>r.nHoursPerDay)
		maxSpanPerDay=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxSpanPerDay::ConstraintStudentsMaxSpanPerDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_SPAN_PER_DAY;
	this->maxSpanPerDay = -1;
}

ConstraintStudentsMaxSpanPerDay::ConstraintStudentsMaxSpanPerDay(double wp, int maxspan)
	: TimeConstraint(wp)
{
	this->maxSpanPerDay = maxspan;
	this->type = CONSTRAINT_STUDENTS_MAX_SPAN_PER_DAY;
}

bool ConstraintStudentsMaxSpanPerDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxSpanPerDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxSpanPerDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxSpanPerDay>\n";
	return s;
}

QString ConstraintStudentsMaxSpanPerDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students max span per day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MS:%1", "Max span (in hours, per day)").arg(this->maxSpanPerDay);

	return begin+s+end;
}

QString ConstraintStudentsMaxSpanPerDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of span (in hours) per day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMaxSpanPerDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

double ConstraintStudentsMaxSpanPerDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;
	
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<r.nDaysPerWeek; d++){
			int begin=-1;
			int end=-1;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(subgroupsMatrix[sbg][d][h]>0){
					begin=h;
					break;
				}
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(subgroupsMatrix[sbg][d][h]>0){
					end=h;
					break;
				}
			if(end>=0 && begin>=0 && end>=begin){
				int span=end-begin+1;
				if(span>this->maxSpanPerDay)
					nbroken++;
			}
		}
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintStudentsMaxSpanPerDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxSpanPerDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxSpanPerDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxSpanPerDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxSpanPerDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxSpanPerDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMaxSpanPerDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMaxSpanPerDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxSpanPerDay>r.nHoursPerDay)
		maxSpanPerDay=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinRestingHours::ConstraintTeacherMinRestingHours()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_RESTING_HOURS;
	this->minRestingHours=-1;
	this->circular=true;
}

ConstraintTeacherMinRestingHours::ConstraintTeacherMinRestingHours(double wp, int minrestinghours, bool circ, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(minrestinghours>0);
	this->minRestingHours=minrestinghours;
	this->circular=circ;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MIN_RESTING_HOURS;
}

bool ConstraintTeacherMinRestingHours::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMinRestingHours::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinRestingHours::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinRestingHours>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Circular>"+trueFalse(circular)+"</Circular>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinRestingHours>\n";
	return s;
}

QString ConstraintTeacherMinRestingHours::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teacher min resting hours");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);s+=translatedCommaSpace();
	s+=tr("C:%1", "Circular").arg(yesNoTranslated(this->circular));

	return begin+s+end;
}

QString ConstraintTeacherMinRestingHours::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum resting hours (between days)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";
	s+=tr("Circular=%1").arg(yesNoTranslated(circular));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinRestingHours::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;

	for(int d=0; d<=r.nDaysPerWeek-2+(circular?1:0); d++){
		int cnt=0;
		for(int h=r.nHoursPerDay-1; h>=0; h--){
			if(teachersMatrix[this->teacher_ID][d][h]>0)
				break;
			else
				cnt++;
		}
		for(int h=0; h<r.nHoursPerDay; h++){
			if(teachersMatrix[this->teacher_ID][(d+1<=r.nDaysPerWeek-1?d+1:0)][h]>0)
				break;
			else
				cnt++;
		}
		if(cnt < this->minRestingHours)
			nbroken++;
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintTeacherMinRestingHours::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinRestingHours::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinRestingHours::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRestingHours::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRestingHours::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRestingHours::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinRestingHours::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinRestingHours::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minRestingHours>r.nHoursPerDay)
		minRestingHours=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinRestingHours::ConstraintTeachersMinRestingHours()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_RESTING_HOURS;
	this->minRestingHours=-1;
	this->circular=true;
}

ConstraintTeachersMinRestingHours::ConstraintTeachersMinRestingHours(double wp, int minrestinghours, bool circ)
 : TimeConstraint(wp)
 {
	assert(minrestinghours>0);
	this->minRestingHours=minrestinghours;
	this->circular=circ;

	this->type=CONSTRAINT_TEACHERS_MIN_RESTING_HOURS;
}

bool ConstraintTeachersMinRestingHours::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMinRestingHours::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinRestingHours::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinRestingHours>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Circular>"+trueFalse(circular)+"</Circular>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinRestingHours>\n";
	return s;
}

QString ConstraintTeachersMinRestingHours::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Teachers min resting hours");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);s+=translatedCommaSpace();
	s+=tr("C:%1", "Circular").arg(yesNoTranslated(this->circular));

	return begin+s+end;
}

QString ConstraintTeachersMinRestingHours::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum resting hours (between days)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";
	s+=tr("Circular=%1").arg(yesNoTranslated(circular));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinRestingHours::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;

	for(int tch=0; tch<r.nInternalTeachers; tch++){
		for(int d=0; d<=r.nDaysPerWeek-2+(circular?1:0); d++){
			int cnt=0;
			for(int h=r.nHoursPerDay-1; h>=0; h--){
				if(teachersMatrix[tch][d][h]>0)
					break;
				else
					cnt++;
			}
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[tch][(d+1<=r.nDaysPerWeek-1?d+1:0)][h]>0)
					break;
				else
					cnt++;
			}
			if(cnt < this->minRestingHours)
				nbroken++;
		}
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintTeachersMinRestingHours::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinRestingHours::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersMinRestingHours::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRestingHours::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRestingHours::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRestingHours::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinRestingHours::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinRestingHours::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minRestingHours>r.nHoursPerDay)
		minRestingHours=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinRestingHours::ConstraintStudentsSetMinRestingHours()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS;
	this->minRestingHours = -1;
	this->circular=true;
}

ConstraintStudentsSetMinRestingHours::ConstraintStudentsSetMinRestingHours(double wp, int minrestinghours, bool circ, const QString& sn)
	: TimeConstraint(wp)
{
	this->minRestingHours = minrestinghours;
	this->circular=circ;
	this->students = sn;
	this->type = CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS;
}

bool ConstraintStudentsSetMinRestingHours::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinRestingHours::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinRestingHours>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Circular>"+trueFalse(circular)+"</Circular>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinRestingHours>\n";
	return s;
}

QString ConstraintStudentsSetMinRestingHours::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set min resting hours");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students); s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);s+=translatedCommaSpace();
	s+=tr("C:%1", "Circular").arg(yesNoTranslated(this->circular));

	return begin+s+end;
}

QString ConstraintStudentsSetMinRestingHours::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum resting hours (between days)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";
	s+=tr("Circular=%1").arg(yesNoTranslated(circular));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinRestingHours::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min resting hours is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

double ConstraintStudentsSetMinRestingHours::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<=r.nDaysPerWeek-2+(circular?1:0); d++){
			int cnt=0;
			for(int h=r.nHoursPerDay-1; h>=0; h--){
				if(subgroupsMatrix[sbg][d][h]>0)
					break;
				else
					cnt++;
			}
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][(d+1<=r.nDaysPerWeek-1?d+1:0)][h]>0)
					break;
				else
					cnt++;
			}
			if(cnt < this->minRestingHours)
				nbroken++;
		}
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintStudentsSetMinRestingHours::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinRestingHours::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinRestingHours::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinRestingHours::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinRestingHours::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinRestingHours::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinRestingHours::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinRestingHours::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minRestingHours>r.nHoursPerDay)
		minRestingHours=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinRestingHours::ConstraintStudentsMinRestingHours()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_RESTING_HOURS;
	this->minRestingHours = -1;
	this->circular=true;
}

ConstraintStudentsMinRestingHours::ConstraintStudentsMinRestingHours(double wp, int minrestinghours, bool circ)
	: TimeConstraint(wp)
{
	this->minRestingHours = minrestinghours;
	this->circular=circ;
	this->type = CONSTRAINT_STUDENTS_MIN_RESTING_HOURS;
}

bool ConstraintStudentsMinRestingHours::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinRestingHours::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinRestingHours>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Circular>"+trueFalse(circular)+"</Circular>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinRestingHours>\n";
	return s;
}

QString ConstraintStudentsMinRestingHours::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students min resting hours");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);s+=translatedCommaSpace();
	s+=tr("C:%1", "Circular").arg(yesNoTranslated(this->circular));

	return begin+s+end;
}

QString ConstraintStudentsMinRestingHours::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum resting hours (between days)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";
	s+=tr("Circular=%1").arg(yesNoTranslated(circular));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinRestingHours::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

double ConstraintStudentsMinRestingHours::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);
	
	int nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<=r.nDaysPerWeek-2+(circular?1:0); d++){
			int cnt=0;
			for(int h=r.nHoursPerDay-1; h>=0; h--){
				if(subgroupsMatrix[sbg][d][h]>0)
					break;
				else
					cnt++;
			}
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][(d+1<=r.nDaysPerWeek-1?d+1:0)][h]>0)
					break;
				else
					cnt++;
			}
			if(cnt < this->minRestingHours)
				nbroken++;
		}
	}
	
	assert(nbroken==0);
	
	return nbroken;
}

bool ConstraintStudentsMinRestingHours::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinRestingHours::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinRestingHours::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinRestingHours::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinRestingHours::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinRestingHours::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinRestingHours::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinRestingHours::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minRestingHours>r.nHoursPerDay)
		minRestingHours=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
	this->students=QString("");
}

ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags(double wp, const QString& _students, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
	this->students=_students;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags>\n";
	return s;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students set min gaps between ordered pair of activity tags");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum gaps between an ordered pair of activity tags");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::computeInternalStructure(QWidget* parent, Rules& r)
{
	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min gaps between ordered pair of activity tags is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);
	
	QList<int> iSubgroupsList;
	populateInternalSubgroupsList(r, ss, iSubgroupsList);
	/*iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!iSubgroupsList.contains(tmp))
			iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!iSubgroupsList.contains(tmp))
				iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!iSubgroupsList.contains(tmp))
					iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(iSubgroupsList)){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		
		if(foundF && foundS)
			this->canonicalSubgroupsList.append(i);
	}
	
	return true;
}

double ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=-1;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[d][h]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtSubgroupTimetableActivityTag[d][h]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtSubgroupTimetableActivityTag[d][h]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students set min %1 gaps between ordered pair of activity tags broken for subgroup: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTags::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
}

ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags(double wp, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags>\n";
	return s;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students min gaps between ordered pair of activity tags");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum gaps between an ordered pair of activity tags");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
	
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		
		if(foundF && foundS)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

double ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=-1;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[d][h]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtSubgroupTimetableActivityTag[d][h]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtSubgroupTimetableActivityTag[d][h]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students min %1 gaps between ordered pair of activity tags broken for subgroup: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTags::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
	this->teacher=QString("");
}

ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags(double wp, const QString& _teacher, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
	this->teacher=_teacher;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags>\n";
	return s;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teacher min gaps between ordered pair of activity tags");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum gaps between an ordered pair of activity tags");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::computeInternalStructure(QWidget* parent, Rules& r)
{
	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	int teacherIndex=r.teachersHash.value(teacher, -1);

	if(teacherIndex<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher min gaps between ordered pair of activity tags is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	/////////////
	this->canonicalTeachersList.clear();

	bool foundF=false; //found first
	bool foundS=false; //found second
	
	Teacher* tch=r.internalTeachersList[teacherIndex];
	
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(!foundF)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
				foundF=true;
		if(!foundS)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
				foundS=true;
				
		if(foundF && foundS)
			break;
	}
	
	if(foundF && foundS)
		this->canonicalTeachersList.append(teacherIndex);
	
	return true;
}

double ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=-1;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[d][h]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtTeacherTimetableActivityTag[d][h]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtTeacherTimetableActivityTag[d][h]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teacher min %1 gaps between ordered pair of activity tags broken for teacher: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::isRelatedToTeacher(Teacher* t)
{
	if(t->name==this->teacher)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTags::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
}

ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags(double wp, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags>\n";
	return s;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teachers min gaps between ordered pair of activity tags");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum gaps between an ordered pair of activity tags");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
	
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	/////////////
	this->canonicalTeachersList.clear();

	for(int teacherIndex=0; teacherIndex<r.nInternalTeachers; teacherIndex++){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		Teacher* tch=r.internalTeachersList[teacherIndex];
	
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		if(foundF && foundS)
			this->canonicalTeachersList.append(teacherIndex);
	}
	
	return true;
}

double ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=-1;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[d][h]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtTeacherTimetableActivityTag[d][h]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtTeacherTimetableActivityTag[d][h]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teachers min %1 gaps between ordered pair of activity tags broken for teacher: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTags::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinGapsBetweenActivityTag::ConstraintStudentsSetMinGapsBetweenActivityTag()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->students=QString("");
}

ConstraintStudentsSetMinGapsBetweenActivityTag::ConstraintStudentsSetMinGapsBetweenActivityTag(double wp, const QString& _students, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
	this->students=_students;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTag::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinGapsBetweenActivityTag>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinGapsBetweenActivityTag>\n";
	return s;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTag::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students set min gaps between activity tag");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTag::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum gaps between an activity tag");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::computeInternalStructure(QWidget* parent, Rules& r)
{
	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);
	
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min gaps between activity tag is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);
	
	QList<int> iSubgroupsList;
	populateInternalSubgroupsList(r, ss, iSubgroupsList);
	/*iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!iSubgroupsList.contains(tmp))
			iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!iSubgroupsList.contains(tmp))
				iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!iSubgroupsList.contains(tmp))
					iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(iSubgroupsList)){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}
	
	return true;
}

double ConstraintStudentsSetMinGapsBetweenActivityTag::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtSubgroupTimetableActivityTag[d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[d][h]==-1){
					cnt++;
				}
				else if(crt==crtSubgroupTimetableActivityTag[d][h]){
					//nothing
				}
				else{
					assert(crtSubgroupTimetableActivityTag[d][h]>=0);
					assert(crt!=crtSubgroupTimetableActivityTag[d][h]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students set min %1 gaps between activity tag broken for subgroup: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtSubgroupTimetableActivityTag[d][h];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTag::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinGapsBetweenActivityTag::ConstraintStudentsMinGapsBetweenActivityTag()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->activityTag=QString("");
}

ConstraintStudentsMinGapsBetweenActivityTag::ConstraintStudentsMinGapsBetweenActivityTag(double wp, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinGapsBetweenActivityTag::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinGapsBetweenActivityTag>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinGapsBetweenActivityTag>\n";
	return s;
}

QString ConstraintStudentsMinGapsBetweenActivityTag::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students min gaps between activity tag");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsMinGapsBetweenActivityTag::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum gaps between an activity tag");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);
	
	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

double ConstraintStudentsMinGapsBetweenActivityTag::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtSubgroupTimetableActivityTag[d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[d][h]==-1){
					cnt++;
				}
				else if(crt==crtSubgroupTimetableActivityTag[d][h]){
					//nothing
				}
				else{
					assert(crtSubgroupTimetableActivityTag[d][h]>=0);
					assert(crt!=crtSubgroupTimetableActivityTag[d][h]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students min %1 gaps between activity tag broken for subgroup: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtSubgroupTimetableActivityTag[d][h];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinGapsBetweenActivityTag::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinGapsBetweenActivityTag::ConstraintTeacherMinGapsBetweenActivityTag()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->teacher=QString("");
}

ConstraintTeacherMinGapsBetweenActivityTag::ConstraintTeacherMinGapsBetweenActivityTag(double wp, const QString& _teacher, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
	this->teacher=_teacher;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinGapsBetweenActivityTag::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinGapsBetweenActivityTag>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinGapsBetweenActivityTag>\n";
	return s;
}

QString ConstraintTeacherMinGapsBetweenActivityTag::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teacher min gaps between activity tag");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeacherMinGapsBetweenActivityTag::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum gaps between an activity tag");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::computeInternalStructure(QWidget* parent, Rules& r)
{
	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);

	int teacherIndex=r.teachersHash.value(teacher, -1);

	if(teacherIndex<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher min gaps between activity tag is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	/////////////
	this->canonicalTeachersList.clear();

	bool found=false;
	
	Teacher* tch=r.internalTeachersList[teacherIndex];
	
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(!found)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
				found=true;
		
		if(found)
			break;
	}
	
	if(found)
		this->canonicalTeachersList.append(teacherIndex);
	
	return true;
}

double ConstraintTeacherMinGapsBetweenActivityTag::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtTeacherTimetableActivityTag[d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[d][h]==-1){
					cnt++;
				}
				else if(crt==crtTeacherTimetableActivityTag[d][h]){
					//nothing
				}
				else{
					assert(crtTeacherTimetableActivityTag[d][h]>=0);
					assert(crt!=crtTeacherTimetableActivityTag[d][h]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teacher min %1 gaps between activity tag broken for teacher: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtTeacherTimetableActivityTag[d][h];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::isRelatedToTeacher(Teacher* t)
{
	if(t->name==this->teacher)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinGapsBetweenActivityTag::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinGapsBetweenActivityTag::ConstraintTeachersMinGapsBetweenActivityTag()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = 0;
	this->activityTag=QString("");
}

ConstraintTeachersMinGapsBetweenActivityTag::ConstraintTeachersMinGapsBetweenActivityTag(double wp, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinGapsBetweenActivityTag::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinGapsBetweenActivityTag>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinGapsBetweenActivityTag>\n";
	return s;
}

QString ConstraintTeachersMinGapsBetweenActivityTag::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teachers min gaps between activity tag");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeachersMinGapsBetweenActivityTag::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum gaps between an activity tag");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);

	/////////////
	this->canonicalTeachersList.clear();

	for(int teacherIndex=0; teacherIndex<r.nInternalTeachers; teacherIndex++){
		bool found=false;
	
		Teacher* tch=r.internalTeachersList[teacherIndex];
	
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		if(found)
			this->canonicalTeachersList.append(teacherIndex);
	}
	
	return true;
}

double ConstraintTeachersMinGapsBetweenActivityTag::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtTeacherTimetableActivityTag[d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[d][h]==-1){
					cnt++;
				}
				else if(crt==crtTeacherTimetableActivityTag[d][h]){
					//nothing
				}
				else{
					assert(crtTeacherTimetableActivityTag[d][h]>=0);
					assert(crt!=crtTeacherTimetableActivityTag[d][h]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teachers min %1 gaps between activity tag broken for teacher: %2,"
							 " day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(r.daysOfTheWeek[d])
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtTeacherTimetableActivityTag[d][h];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinGapsBetweenActivityTag::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>r.nHoursPerDay)
		minGaps=r.nHoursPerDay;

	return true;
}

//2024-03-15
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
	this->students=QString("");
}

ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay(double wp, const QString& _students, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
	this->students=_students;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	return s;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students set min gaps between ordered pair of activity tags per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum gaps between an ordered pair of activity tags per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min gaps between ordered pair of activity tags per real day is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);
	
	QList<int> iSubgroupsList;
	populateInternalSubgroupsList(r, ss, iSubgroupsList);
	/*iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!iSubgroupsList.contains(tmp))
			iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!iSubgroupsList.contains(tmp))
				iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!iSubgroupsList.contains(tmp))
					iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(iSubgroupsList)){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		
		if(foundF && foundS)
			this->canonicalSubgroupsList.append(i);
	}
	
	return true;
}

double ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=-1;
			for(int h=0; h<2*r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students set min %1 gaps between ordered pair of activity tags per real day broken for subgroup: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
}

ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay(double wp, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	return s;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students min gaps between ordered pair of activity tags per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum gaps between an ordered pair of activity tags per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		
		if(foundF && foundS)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

double ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=-1;
			for(int h=0; h<2*r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students min %1 gaps between ordered pair of activity tags per real day broken for subgroup: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
	this->teacher=QString("");
}

ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay(double wp, const QString& _teacher, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
	this->teacher=_teacher;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	return s;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teacher min gaps between ordered pair of activity tags per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum gaps between an ordered pair of activity tags per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	int teacherIndex=r.teachersHash.value(teacher, -1);

	if(teacherIndex<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher min gaps between ordered pair of activity tags per real day is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	/////////////
	this->canonicalTeachersList.clear();

	bool foundF=false; //found first
	bool foundS=false; //found second
	
	Teacher* tch=r.internalTeachersList[teacherIndex];
	
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(!foundF)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
				foundF=true;
		if(!foundS)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
				foundS=true;
				
		if(foundF && foundS)
			break;
	}
	
	if(foundF && foundS)
		this->canonicalTeachersList.append(teacherIndex);
	
	return true;
}

double ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=-1;
			for(int h=0; h<2*r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teacher min %1 gaps between ordered pair of activity tags per real day broken for teacher: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	if(t->name==this->teacher)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
}

ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay(double wp, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay>\n";
	return s;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teachers min gaps between ordered pair of activity tags per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum gaps between an ordered pair of activity tags per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	/////////////
	this->canonicalTeachersList.clear();

	for(int teacherIndex=0; teacherIndex<r.nInternalTeachers; teacherIndex++){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		Teacher* tch=r.internalTeachersList[teacherIndex];
	
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		if(foundF && foundS)
			this->canonicalTeachersList.append(teacherIndex);
	}
	
	return true;
}

double ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=-1;
			for(int h=0; h<2*r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_firstActivityTagIndex){
					cnt=0;
				}
				else if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					if(cnt>=0)
						cnt++;
				}
				else if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==_secondActivityTagIndex){
					if(cnt>=0 && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teachers min %1 gaps between ordered pair of activity tags per real day broken for teacher: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
								
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					cnt=-1;
				}
				else{
					assert(0);
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->students=QString("");
}

ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay(double wp, const QString& _students, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
	this->students=_students;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay>\n";
	return s;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students set min gaps between activity tag per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum gaps between an activity tag per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);
	
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min gaps between activity tag per real day is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);
	
	QList<int> iSubgroupsList;
	populateInternalSubgroupsList(r, ss, iSubgroupsList);
	/*iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!iSubgroupsList.contains(tmp))
			iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!iSubgroupsList.contains(tmp))
				iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!iSubgroupsList.contains(tmp))
					iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(iSubgroupsList)){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}
	
	return true;
}

double ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtSubgroupTimetableActivityTag[2*d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<2*r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					cnt++;
				}
				else if(crt==crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]){
					//nothing
				}
				else{
					assert(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]>=0);
					assert(crt!=crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students set min %1 gaps between activity tag per real day broken for subgroup: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::ConstraintStudentsMinGapsBetweenActivityTagPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->activityTag=QString("");
}

ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::ConstraintStudentsMinGapsBetweenActivityTagPerRealDay(double wp, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinGapsBetweenActivityTagPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinGapsBetweenActivityTagPerRealDay>\n";
	return s;
}

QString ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students min gaps between activity tag per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum gaps between an activity tag per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);
	
	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

double ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtSubgroupTimetableActivityTag[2*d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<2*r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					cnt++;
				}
				else if(crt==crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]){
					//nothing
				}
				else{
					assert(crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]>=0);
					assert(crt!=crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint students min %1 gaps between activity tag per real day broken for subgroup: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(sbg->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtSubgroupTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinGapsBetweenActivityTagPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::ConstraintTeacherMinGapsBetweenActivityTagPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->teacher=QString("");
}

ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::ConstraintTeacherMinGapsBetweenActivityTagPerRealDay(double wp, const QString& _teacher, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
	this->teacher=_teacher;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinGapsBetweenActivityTagPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinGapsBetweenActivityTagPerRealDay>\n";
	return s;
}

QString ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teacher min gaps between activity tag per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum gaps between an activity tag per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);

	int teacherIndex=r.teachersHash.value(teacher, -1);

	if(teacherIndex<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher min gaps between activity tag per real day is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	/////////////
	this->canonicalTeachersList.clear();

	bool found=false;
	
	Teacher* tch=r.internalTeachersList[teacherIndex];
	
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(!found)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
				found=true;
		
		if(found)
			break;
	}
	
	if(found)
		this->canonicalTeachersList.append(teacherIndex);
	
	return true;
}

double ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtTeacherTimetableActivityTag[2*d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<2*r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					cnt++;
				}
				else if(crt==crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]){
					//nothing
				}
				else{
					assert(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]>=0);
					assert(crt!=crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teacher min %1 gaps between activity tag per real day broken for teacher: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::isRelatedToTeacher(Teacher* t)
{
	if(t->name==this->teacher)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinGapsBetweenActivityTagPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::ConstraintTeachersMinGapsBetweenActivityTagPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = 0;
	this->activityTag=QString("");
}

ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::ConstraintTeachersMinGapsBetweenActivityTagPerRealDay(double wp, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_PER_REAL_DAY;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinGapsBetweenActivityTagPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinGapsBetweenActivityTagPerRealDay>\n";
	return s;
}

QString ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teachers min gaps between activity tag per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum gaps between an activity tag per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);

	/////////////
	this->canonicalTeachersList.clear();

	for(int teacherIndex=0; teacherIndex<r.nInternalTeachers; teacherIndex++){
		bool found=false;
	
		Teacher* tch=r.internalTeachersList[teacherIndex];
	
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		if(found)
			this->canonicalTeachersList.append(teacherIndex);
	}
	
	return true;
}

double ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int cnt=0;
			bool begin=false;
			int crt=crtTeacherTimetableActivityTag[2*d][0];
			if(crt==-1){
				cnt++; //not needed
				begin=true;
			}
			for(int h=1; h<2*r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]==-1){
					cnt++;
				}
				else if(crt==crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]){
					//nothing
				}
				else{
					assert(crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]>=0);
					assert(crt!=crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay]);
					if(!begin && cnt<minGaps){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=tr("Time constraint teachers min %1 gaps between activity tag per real day broken for teacher: %2,"
							 " real day: %3, real gaps=%4, conflicts increase=%5")
							 .arg(minGaps)
							 .arg(tch->name)
							 .arg(d)
							 .arg(CustomFETString::number(cnt))
							 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
							
							dl.append(s);
							cl.append(1*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
					
					if(begin)
						begin=false;
					
					crt=crtTeacherTimetableActivityTag[2*d+h/r.nHoursPerDay][h%r.nHoursPerDay];
					cnt=0;
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinGapsBetweenActivityTagPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

//2024-05-18
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
	this->students=QString("");
}

ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon(double wp, const QString& _students, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
	this->students=_students;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students set min gaps between ordered pair of activity tags between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum gaps between an ordered pair of activity tags between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min gaps between ordered pair of activity tags between morning and afternoon is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);
	
	QList<int> iSubgroupsList;
	populateInternalSubgroupsList(r, ss, iSubgroupsList);
	/*iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!iSubgroupsList.contains(tmp))
			iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!iSubgroupsList.contains(tmp))
				iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!iSubgroupsList.contains(tmp))
					iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(iSubgroupsList)){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		
		if(foundF && foundS)
			this->canonicalSubgroupsList.append(i);
	}
	
	return true;
}

double ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtSubgroupTimetableActivityTag[2*d][h]==_firstActivityTagIndex){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[2*d+1][h]==_secondActivityTagIndex){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students set min %1 gaps between ordered pair of activity tags between morning and afternoon broken for subgroup: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(sbg->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
}

ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon(double wp, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students min gaps between ordered pair of activity tags between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum gaps between an ordered pair of activity tags between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		
		if(foundF && foundS)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

double ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtSubgroupTimetableActivityTag[2*d][h]==_firstActivityTagIndex){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[2*d+1][h]==_secondActivityTagIndex){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students min %1 gaps between ordered pair of activity tags between morning and afternoon broken for subgroup: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(sbg->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
	this->teacher=QString("");
}

ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon(double wp, const QString& _teacher, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
	this->teacher=_teacher;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teacher min gaps between ordered pair of activity tags between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum gaps between an ordered pair of activity tags between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	int teacherIndex=r.teachersHash.value(teacher, -1);

	if(teacherIndex<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher min gaps between ordered pair of activity tags between morning and afternoon is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	/////////////
	this->canonicalTeachersList.clear();

	bool foundF=false; //found first
	bool foundS=false; //found second
	
	Teacher* tch=r.internalTeachersList[teacherIndex];
	
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(!foundF)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
				foundF=true;
		if(!foundS)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
				foundS=true;
				
		if(foundF && foundS)
			break;
	}
	
	if(foundF && foundS)
		this->canonicalTeachersList.append(teacherIndex);
	
	return true;
}

double ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtTeacherTimetableActivityTag[2*d][h]==_firstActivityTagIndex){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[2*d+1][h]==_secondActivityTagIndex){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teacher min %1 gaps between ordered pair of activity tags between morning and afternoon broken for teacher: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(tch->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	if(t->name==this->teacher)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->firstActivityTag=QString("");
	this->secondActivityTag=QString("");
}

ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon(double wp, int _minGaps, const QString& _firstActivityTag, const QString& _secondActivityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ORDERED_PAIR_OF_ACTIVITY_TAGS_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->firstActivityTag=_firstActivityTag;
	this->secondActivityTag=_secondActivityTag;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<First_Activity_Tag>"+protect(this->firstActivityTag)+"</First_Activity_Tag>\n";
	s+=IL3+"<Second_Activity_Tag>"+protect(this->secondActivityTag)+"</Second_Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teachers min gaps between ordered pair of activity tags between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("FAT:%1", "First activity tag").arg(this->firstActivityTag);s+=translatedCommaSpace();
	s+=tr("SAT:%1", "Second activity tag").arg(this->secondActivityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum gaps between an ordered pair of activity tags between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("First activity tag=%1").arg(this->firstActivityTag);s+="\n";
	s+=tr("Second activity tag=%1").arg(this->secondActivityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_firstActivityTagIndex=r.activityTagsHash.value(firstActivityTag, -1);
	assert(this->_firstActivityTagIndex>=0);
		
	_secondActivityTagIndex=r.activityTagsHash.value(secondActivityTag, -1);
	assert(this->_secondActivityTagIndex>=0);

	/////////////
	this->canonicalTeachersList.clear();

	for(int teacherIndex=0; teacherIndex<r.nInternalTeachers; teacherIndex++){
		bool foundF=false; //found first
		bool foundS=false; //found second
	
		Teacher* tch=r.internalTeachersList[teacherIndex];
	
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(!foundF)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_firstActivityTagIndex))
					foundF=true;
			if(!foundS)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_secondActivityTagIndex))
					foundS=true;
					
			if(foundF && foundS)
				break;
		}
		if(foundF && foundS)
			this->canonicalTeachersList.append(teacherIndex);
	}
	
	return true;
}

double ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_firstActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_firstActivityTagIndex;
				}
				else if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_secondActivityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=this->_secondActivityTagIndex;
				}
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtTeacherTimetableActivityTag[2*d][h]==_firstActivityTagIndex){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[2*d+1][h]==_secondActivityTagIndex){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teachers min %1 gaps between ordered pair of activity tags between morning and afternoon broken for teacher: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(tch->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->firstActivityTag || s->name==this->secondActivityTag)
		return true;

	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinGapsBetweenOrderedPairOfActivityTagsBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->students=QString("");
}

ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon(double wp, const QString& _students, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
	this->students=_students;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students set min gaps between activity tag between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum gaps between an activity tag between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);
	
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min gaps between activity tag between morning and afternoon is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);
	
	QList<int> iSubgroupsList;
	populateInternalSubgroupsList(r, ss, iSubgroupsList);
	/*iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!iSubgroupsList.contains(tmp))
			iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!iSubgroupsList.contains(tmp))
				iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!iSubgroupsList.contains(tmp))
					iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(iSubgroupsList)){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}
	
	return true;
}

double ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtSubgroupTimetableActivityTag[2*d][h]>=0){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[2*d+1][h]>=0){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students set min %1 gaps between activity tag between morning and afternoon broken for subgroup: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(sbg->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMinGapsBetweenActivityTagBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->activityTag=QString("");
}

ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon(double wp, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Students min gaps between activity tag between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum gaps between an activity tag between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);
	
	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool found=false;
	
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		
		if(found)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

double ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
					crtSubgroupTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtSubgroupTimetableActivityTag[2*d][h]>=0){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[2*d+1][h]>=0){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students min %1 gaps between activity tag between morning and afternoon broken for subgroup: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(sbg->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMinGapsBetweenActivityTagBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->activityTag=QString("");
	this->teacher=QString("");
}

ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon(double wp, const QString& _teacher, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
	this->teacher=_teacher;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teacher min gaps between activity tag between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum gaps between an activity tag between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);

	int teacherIndex=r.teachersHash.value(teacher, -1);

	if(teacherIndex<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher min gaps between activity tag between morning and afternoon is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	/////////////
	this->canonicalTeachersList.clear();

	bool found=false;
	
	Teacher* tch=r.internalTeachersList[teacherIndex];
	
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(!found)
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
				found=true;
		
		if(found)
			break;
	}
	
	if(found)
		this->canonicalTeachersList.append(teacherIndex);
	
	return true;
}

double ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtTeacherTimetableActivityTag[2*d][h]>=0){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[2*d+1][h]>=0){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teacher min %1 gaps between activity tag between morning and afternoon broken for teacher: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(tch->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	if(t->name==this->teacher)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMinGapsBetweenActivityTagBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = 0;
	this->activityTag=QString("");
}

ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon(double wp, int _minGaps, const QString& _activityTag)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MIN_GAPS_BETWEEN_ACTIVITY_TAG_BETWEEN_MORNING_AND_AFTERNOON;

	this->minGaps = _minGaps;
	this->activityTag=_activityTag;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTag)+"</Activity_Tag>\n";
	s+=IL3+"<MinGaps>"+CustomFETString::number(this->minGaps)+"</MinGaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	
	s+=tr("Teachers min gaps between activity tag between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("AT:%1", "Activity tag").arg(this->activityTag);s+=translatedCommaSpace();
	s+=tr("mG:%1", "Min gaps").arg(this->minGaps);

	return begin+s+end;
}

QString ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum gaps between an activity tag between morning and afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTag);s+="\n";
	s+=tr("Minimum gaps=%1").arg(this->minGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	_activityTagIndex=r.activityTagsHash.value(activityTag, -1);
	assert(this->_activityTagIndex>=0);

	/////////////
	this->canonicalTeachersList.clear();

	for(int teacherIndex=0; teacherIndex<r.nInternalTeachers; teacherIndex++){
		bool found=false;
	
		Teacher* tch=r.internalTeachersList[teacherIndex];
	
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(!found)
				if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->_activityTagIndex))
					found=true;

			if(found)
				break;
		}
		if(found)
			this->canonicalTeachersList.append(teacherIndex);
	}
	
	return true;
}

double ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}
	
	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);

	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];

		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->_activityTagIndex)){
					assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
					crtTeacherTimetableActivityTag[d][h+dur]=ai;
				}
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int lm=-1; //last in the morning
			for(int h=r.nHoursPerDay-1; h>=0; h--)
				if(crtTeacherTimetableActivityTag[2*d][h]>=0){
					lm=h;
					break;
			}
			
			int fa=-1; //first in the afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[2*d+1][h]>=0){
					fa=h;
					break;
			}
			
			int cnt=-1;
			if(lm>=0 && fa>=0){
				cnt=r.nHoursPerDay-lm-1+fa;
				assert(cnt>=0);
			}
			if(cnt>=0 && cnt<minGaps){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teachers min %1 gaps between activity tag between morning and afternoon broken for teacher: %2,"
					 " real day: %3, real gaps=%4, conflicts increase=%5")
					 .arg(minGaps)
					 .arg(tch->name)
					 .arg(d)
					 .arg(CustomFETString::number(cnt))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));
						
					dl.append(s);
					cl.append(1*weightPercentage/100);
					
					*conflictsString+= s+"\n";
				}
			}
		}
	}
	
	if(weightPercentage==100)
		assert(nbroken==0);

	return nbroken * weightPercentage / 100.0;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	if(s->name==this->activityTag)
		return true;

	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minGaps>2*r.nHoursPerDay)
		return true;
		
	return false;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMinGapsBetweenActivityTagBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minGaps>2*r.nHoursPerDay)
		minGaps=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

//For mornings-afternoons

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxHoursDailyRealDays::ConstraintTeachersMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_REAL_DAYS;
}

ConstraintTeachersMaxHoursDailyRealDays::ConstraintTeachersMaxHoursDailyRealDays(double wp, int maxhours)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;

	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintTeachersMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxHoursDailyRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintTeachersMaxHoursDailyRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers max hours daily per real day"), s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MH:%1", "Maximum hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintTeachersMaxHoursDailyRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of hours daily per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek/2; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d][h]>0)
						n_hours_daily++;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d+1][h]>0)
						n_hours_daily++;

				if(n_hours_daily>this->maxHoursDaily)
					nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek/2; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d][h]>0)
						n_hours_daily++;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d+1][h]>0)
						n_hours_daily++;

				if(n_hours_daily>this->maxHoursDaily){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr(
						 "Time constraint teachers max %1 hours daily per real day broken for teacher %2, on real day %3, length=%4.")
						 .arg(CustomFETString::number(this->maxHoursDaily))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(d/*r.daysOfTheWeek[d]*/)
						 .arg(n_hours_daily)
						 )
						 +
						 " "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));

						dl.append(s);
						cl.append(weightPercentage/100);

						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxHoursDailyRealDays::ConstraintTeacherMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_HOURS_DAILY_REAL_DAYS;
}

ConstraintTeacherMaxHoursDailyRealDays::ConstraintTeacherMaxHoursDailyRealDays(double wp, int maxhours, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintTeacherMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxHoursDailyRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintTeacherMaxHoursDailyRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher max hours daily per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MH:%1", "Maximum hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintTeacherMaxHoursDailyRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of hours daily per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d][h]>0)
					n_hours_daily++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d+1][h]>0)
					n_hours_daily++;

			if(n_hours_daily>this->maxHoursDaily){
				nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d][h]>0)
					n_hours_daily++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d+1][h]>0)
					n_hours_daily++;

			if(n_hours_daily>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher max %1 hours daily per real day broken for teacher %2, on real day %3, length=%4.")
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(d/*r.daysOfTheWeek[d]*/)
					 .arg(n_hours_daily)
					 )
					 +" "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));

					dl.append(s);
					cl.append(weightPercentage/100);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxRealDaysPerWeek::ConstraintTeacherMaxRealDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_REAL_DAYS_PER_WEEK;
}

ConstraintTeacherMaxRealDaysPerWeek::ConstraintTeacherMaxRealDaysPerWeek(double wp, int maxnd, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHER_MAX_REAL_DAYS_PER_WEEK;
}

bool ConstraintTeacherMaxRealDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxRealDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxRealDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxRealDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxRealDaysPerWeek>\n";
	return s;
}

QString ConstraintTeacherMaxRealDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max real days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MD:%1", "Max days (per week)").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMaxRealDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of real days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxRealDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		int nd[MAX_HOURS_PER_DAY + 1];
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{*/
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		//int nd[2*MAX_HOURS_PER_DAY + 1];
		int nOD=0; //n occupied days
		//for(int h=0; h<=2*r.nHoursPerDay; h++)
		//nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][2*d][h]>=1 ? 1 : 0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][2*d+1][h]>=1 ? 1 : 0;
			if(nh>0)
				nOD++;
			//nd[nh]++;
		}

		//return the minimum occupied days which do not respect this constraint
/*		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=2*r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}*/

		if(nOD>this->maxDaysPerWeek)
			nbroken=1;

		if(nbroken>0 && conflictsString!=nullptr){
			QString s= tr("Time constraint teacher max real days per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}
	//}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxRealDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxRealDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxRealDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxRealDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxRealDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxRealDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherMaxRealDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxRealDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxDaysPerWeek>r.nDaysPerWeek/2)
		maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxRealDaysPerWeek::ConstraintTeachersMaxRealDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_REAL_DAYS_PER_WEEK;
}

ConstraintTeachersMaxRealDaysPerWeek::ConstraintTeachersMaxRealDaysPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHERS_MAX_REAL_DAYS_PER_WEEK;
}

bool ConstraintTeachersMaxRealDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxRealDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxRealDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxRealDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxRealDaysPerWeek>\n";
	return s;
}

QString ConstraintTeachersMaxRealDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max real days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MD:%1", "Max days (per week)").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMaxRealDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of real days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxRealDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort

		for(int t=0; t<r.nInternalTeachers; t++){
			int nd[MAX_HOURS_PER_DAY + 1];
			for(int h=0; h<=r.nHoursPerDay; h++)
				nd[h]=0;
			for(int d=0; d<r.nDaysPerWeek; d++){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
				nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						break;
					}
				}
			}

		}
	}
	//with logging
	else{*/
		nbroken=0;

		for(int t=0; t<r.nInternalTeachers; t++){
			int nbr=0;

			//count sort
			//int t=this->teacher_ID;
			//int nd[2*MAX_HOURS_PER_DAY + 1];
			//for(int h=0; h<=2*r.nHoursPerDay; h++)
			//	nd[h]=0;
			int nOD=0;
			for(int d=0; d<r.nDaysPerWeek/2; d++){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][2*d][h]>=1 ? 1 : 0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][2*d+1][h]>=1 ? 1 : 0;
				if(nh>0)
					nOD++;
				//nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
/*			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=2*r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
						nbr+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						nbr+=i*k;
						break;
					}
				}
			}*/

			if(nOD>this->maxDaysPerWeek)
				 nbr=1;

			if(nbr>0 && conflictsString!=nullptr){
				QString s= tr("Time constraint teachers max real days per week broken for teacher: %1.")
				.arg(r.internalTeachersList[t]->name);
				s += tr("This increases the conflicts total by %1")
				.arg(CustomFETString::numberPlusTwoDigitsPrecision(nbr*weightPercentage/100));

				dl.append(s);
				cl.append(nbr*weightPercentage/100);

				*conflictsString += s+"\n";
			}

		}
//	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxRealDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxRealDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxRealDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxRealDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxRealDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxRealDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersMaxRealDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxRealDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxDaysPerWeek>r.nDaysPerWeek/2)
		maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxGapsPerRealDay::ConstraintTeachersMaxGapsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_REAL_DAY;
	this->maxGaps=-1;
	this->allowOneDayExceptionPlusOne=false;
}

ConstraintTeachersMaxGapsPerRealDay::ConstraintTeachersMaxGapsPerRealDay(double wp, int mg, bool except)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_REAL_DAY;
	this->maxGaps=mg;
	this->allowOneDayExceptionPlusOne=except;
}

bool ConstraintTeachersMaxGapsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxGapsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxGapsPerRealDay::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxGapsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Allow_One_Day_Exception_of_Plus_One>"+trueFalse(allowOneDayExceptionPlusOne)+"</Allow_One_Day_Exception_of_Plus_One>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxGapsPerRealDay>\n";
	return s;
}

QString ConstraintTeachersMaxGapsPerRealDay::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers max gaps per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per real day)").arg(this->maxGaps);s+=translatedCommaSpace();
	s+=tr("ODE:%1", "One day exception (in which the teacher can have gaps+1)").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));

	return begin+s+end;
}

QString ConstraintTeachersMaxGapsPerRealDay::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum gaps per real day");s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per real day=%1").arg(this->maxGaps); s+="\n";
	s+=tr("Allow one day exception of plus one=%1").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxGapsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tg;
	int i, j, k;
	int totalGaps;

	int real_d, double_h;

	totalGaps=0;
	for(i=0; i<r.nInternalTeachers; i++){
		int except;
		if(allowOneDayExceptionPlusOne)
			except=1;
		else
			except=0;

		//for(j=0; j<r.nDaysPerWeek; j++){
		for(real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
			tg=0;
			for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(teachersMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
					break;
				}
			}

			int cnt=0;
			for(; double_h<2*r.nHoursPerDay; double_h++){
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
					if(teachersMatrix[i][j][k]>0){
						tg+=cnt;
						cnt=0;
					}
					else{
						cnt++;
					}
				}
			}
			if(tg==this->maxGaps+1 && except>0)
				except--;
			else if(tg>this->maxGaps && except>0){
				assert(tg>this->maxGaps+1);
				except--;
				totalGaps+=tg-maxGaps-1;
				//assert(this->weightPercentage<100); partial solutions might break this rule
				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teachers max gaps per real day broken for teacher: %1, real day number %2, conflicts factor increase=%3")
						.arg(r.internalTeachersList[i]->name)
						.arg(real_d)
						.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps-1)*weightPercentage/100));

					*conflictsString+= s+"\n";

					dl.append(s);
					cl.append((tg-maxGaps-1)*weightPercentage/100);
				}
			}
			else if(tg>this->maxGaps){
				assert(except==0);
				totalGaps+=tg-maxGaps;
				//assert(this->weightPercentage<100); partial solutions might break this rule
				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teachers max gaps per real day broken for teacher: %1, real day number %2, conflicts factor increase=%3")
						.arg(r.internalTeachersList[i]->name)
						.arg(real_d)
						.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));

					*conflictsString+= s+"\n";

					dl.append(s);
					cl.append((tg-maxGaps)*weightPercentage/100);
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeachersMaxGapsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxGapsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxGapsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMaxGapsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxGapsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>2*r.nHoursPerDay)
		maxGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxGapsPerRealDay::ConstraintTeacherMaxGapsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_REAL_DAY;
	this->maxGaps = -1;
	this->allowOneDayExceptionPlusOne=false;
}

ConstraintTeacherMaxGapsPerRealDay::ConstraintTeacherMaxGapsPerRealDay(double wp, const QString& tn, int mg, bool except)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_REAL_DAY;
	this->teacherName=tn;
	this->maxGaps=mg;
	this->allowOneDayExceptionPlusOne=except;
}

bool ConstraintTeacherMaxGapsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacherIndex=r.searchTeacher(this->teacherName);
	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);
	return true;
}

bool ConstraintTeacherMaxGapsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxGapsPerRealDay::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxGapsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Allow_One_Day_Exception_of_Plus_One>"+trueFalse(allowOneDayExceptionPlusOne)+"</Allow_One_Day_Exception_of_Plus_One>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxGapsPerRealDay>\n";
	return s;
}

QString ConstraintTeacherMaxGapsPerRealDay::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher max gaps per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per real day)").arg(this->maxGaps);s+=translatedCommaSpace();
	s+=tr("ODE:%1", "One day exception (in which the teacher can have gaps+1)").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));

	return begin+s+end;
}

QString ConstraintTeacherMaxGapsPerRealDay::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("A teacher must respect the maximum number of gaps per real day"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";
	s+=tr("Maximum gaps per real day=%1").arg(this->maxGaps); s+="\n";
	s+=tr("Allow one day exception of plus one=%1").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxGapsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;

	i=this->teacherIndex;

	int real_d, double_h;

	int except;
	if(allowOneDayExceptionPlusOne)
		except=1;
	else
		except=0;

	for(real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
		tg=0;
		for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
			if(double_h<r.nHoursPerDay)
				j=2*real_d;
			else
				j=2*real_d+1;
			k=double_h%r.nHoursPerDay;
			if(teachersMatrix[i][j][k]>0){
				assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
				break;
			}
		}

		int cnt=0;
		for(; double_h<2*r.nHoursPerDay; double_h++){
			if(double_h<r.nHoursPerDay)
				j=2*real_d;
			else
				j=2*real_d+1;
			k=double_h%r.nHoursPerDay;
			if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
				if(teachersMatrix[i][j][k]>0){
					tg+=cnt;
					cnt=0;
				}
				else
					cnt++;
			}
		}
		if(tg==this->maxGaps+1 && except>0)
			except--;
		else if(tg>this->maxGaps && except>0){
			assert(tg>this->maxGaps+1);
			except--;
			totalGaps+=tg-maxGaps-1;
			//assert(this->weightPercentage<100); partial solutions might break this rule
			if(conflictsString!=nullptr){
				QString s=tr("Time constraint teacher max gaps per real day broken for teacher: %1, real day number %2, conflicts factor increase=%3")
					.arg(r.internalTeachersList[i]->name)
					.arg(real_d)
					.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps-1)*weightPercentage/100));

				*conflictsString+= s+"\n";

				dl.append(s);
				cl.append((tg-maxGaps-1)*weightPercentage/100);
			}
		}
		else if(tg>this->maxGaps){
			assert(except==0);
			totalGaps+=tg-maxGaps;
			//assert(this->weightPercentage<100); partial solutions might break this rule
			if(conflictsString!=nullptr){
				QString s=tr("Time constraint teacher max gaps per real day broken for teacher: %1, real day number %2, conflicts factor increase=%3")
					.arg(r.internalTeachersList[i]->name)
					.arg(real_d)
					.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));

				*conflictsString+= s+"\n";

				dl.append(s);
				cl.append((tg-maxGaps)*weightPercentage/100);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeacherMaxGapsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxGapsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxGapsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMaxGapsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxGapsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>2*r.nHoursPerDay)
		maxGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxHoursDailyRealDays::ConstraintStudentsMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_REAL_DAYS;
	this->maxHoursDaily = -1;
}

ConstraintStudentsMaxHoursDailyRealDays::ConstraintStudentsMaxHoursDailyRealDays(double wp, int maxnh)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintStudentsMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxHoursDailyRealDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	if(this->maxHoursDaily>=0)
		s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	else
		assert(0);
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintStudentsMaxHoursDailyRealDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students max hours daily per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MH:%1", "Max hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintStudentsMaxHoursDailyRealDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of hours daily per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp;
	int too_much;

	assert(this->maxHoursDaily>=0);

	if(true){
		too_much=0;
		for(int i=0; i<r.nInternalSubgroups; i++)
			for(int j=0; j<r.nDaysPerWeek/2; j++){
				tmp=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j][k]>=1)
						tmp++;
				}
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j+1][k]>=1)
						tmp++;
				}
				if(this->maxHoursDaily>=0 && tmp > this->maxHoursDaily){ //we would like no more than maxHoursDaily hours per day.
					too_much += 1; //tmp - this->maxHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students max hours daily per real day broken for subgroup: %1, real day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(j/*r.daysOfTheWeek[j]*/)
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*1));

						dl.append(s);
						cl.append(weightPercentage/100*1);

						*conflictsString+= s+"\n";
					}
				}
			}
	}

	assert(too_much>=0);
	if(weightPercentage==100)
		assert(too_much==0);
	return too_much * weightPercentage/100;
}

bool ConstraintStudentsMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxHoursDailyRealDays::ConstraintStudentsSetMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_REAL_DAYS;
	this->maxHoursDaily = -1;
}

ConstraintStudentsSetMaxHoursDailyRealDays::ConstraintStudentsSetMaxHoursDailyRealDays(double wp, int maxnh, const QString& s)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->students = s;
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxHoursDailyRealDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintStudentsSetMaxHoursDailyRealDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students set max hours daily per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students); s+=translatedCommaSpace();
	s+=tr("MH:%1", "Max hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxHoursDailyRealDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of hours daily per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours daily is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

double ConstraintStudentsSetMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp;
	int too_much;

	assert(this->maxHoursDaily>=0);

	if(true){
		too_much=0;
		for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
			int i=iSubgroupsList.at(sg);
			for(int j=0; j<r.nDaysPerWeek/2; j++){
				tmp=0;
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j][k]>=1)
						tmp++;
				}
				for(int k=0; k<r.nHoursPerDay; k++){
					if(subgroupsMatrix[i][2*j+1][k]>=1)
						tmp++;
				}
				if(this->maxHoursDaily>=0 && tmp > this->maxHoursDaily){ //we would like no more than max_hours_daily hours per day.
					too_much += 1; //tmp - this->maxHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set max hours daily per real day broken for subgroup: %1, real day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(j/*r.daysOfTheWeek[j]*/)
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision( 1 *weightPercentage/100));

						dl.append(s);
						cl.append( 1 *weightPercentage/100);

						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	assert(too_much>=0);
	if(weightPercentage==100)
		assert(too_much==0);
	return too_much * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinHoursPerMorning::ConstraintTeachersMinHoursPerMorning()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_PER_MORNING;

	this->allowEmptyMornings=true;
}

ConstraintTeachersMinHoursPerMorning::ConstraintTeachersMinHoursPerMorning(double wp, int minhours, bool _allowEmptyMornings)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursPerMorning=minhours;

	this->allowEmptyMornings=_allowEmptyMornings;

	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_PER_MORNING;
}

bool ConstraintTeachersMinHoursPerMorning::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(r);

	if(allowEmptyMornings==false){
		QString s=tr("Cannot generate a timetable with a constraint teachers min hours per morning with allow empty mornings=false. Please modify it,"
			" so that it allows empty mornings. If you need a facility like that, please use constraint teachers min mornings per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);

		return false;
	}

	return true;
}

bool ConstraintTeachersMinHoursPerMorning::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinHoursPerMorning::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinHoursPerMorning>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Hours_Per_Morning>"+CustomFETString::number(this->minHoursPerMorning)+"</Minimum_Hours_Per_Morning>\n";
	if(this->allowEmptyMornings)
		s+=IL3+"<Allow_Empty_Mornings>true</Allow_Empty_Mornings>\n";
	else
		s+=IL3+"<Allow_Empty_Mornings>false</Allow_Empty_Mornings>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinHoursPerMorning>\n";
	return s;
}

QString ConstraintTeachersMinHoursPerMorning::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers min hours per morning");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (per morning)").arg(this->minHoursPerMorning);s+=translatedCommaSpace();
	s+=tr("AEM:%1", "Allow empty mornings").arg(yesNoTranslated(this->allowEmptyMornings));

	return begin+s+end;
}

QString ConstraintTeachersMinHoursPerMorning::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of hours per morning"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum hours per morning=%1").arg(this->minHoursPerMorning);s+="\n";
	s+=tr("Allow empty mornings=%1").arg(yesNoTranslated(this->allowEmptyMornings));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinHoursPerMorning::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	assert(this->allowEmptyMornings==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				if(d%2==1)
					continue;
				int n_hours_per_morning=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_per_morning++;

				if(n_hours_per_morning>0 && n_hours_per_morning<this->minHoursPerMorning){
					nbroken++;
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				if(d%2==1)
					continue;
				int n_hours_per_morning=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_per_morning++;

				if(n_hours_per_morning>0 && n_hours_per_morning<this->minHoursPerMorning){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr("Time constraint teachers min %1 hours per morning broken for teacher %2, on day %3, length=%4.")
						 .arg(CustomFETString::number(this->minHoursPerMorning))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(r.daysOfTheWeek[d])
						 .arg(n_hours_per_morning)
						 )
						 +
						 " "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));

						dl.append(s);
						cl.append(weightPercentage/100);

						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMinHoursPerMorning::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(a);
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeachersMinHoursPerMorning::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinHoursPerMorning::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursPerMorning::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursPerMorning::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursPerMorning::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerMorning>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMinHoursPerMorning::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMinHoursPerMorning::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerMorning>r.nHoursPerDay)
		minHoursPerMorning=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinHoursPerMorning::ConstraintTeacherMinHoursPerMorning()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_HOURS_PER_MORNING;

	this->allowEmptyMornings=true;
}

ConstraintTeacherMinHoursPerMorning::ConstraintTeacherMinHoursPerMorning(double wp, int minhours, const QString& teacher, bool _allowEmptyMornings)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursPerMorning=minhours;
	this->teacherName=teacher;

	this->allowEmptyMornings=_allowEmptyMornings;

	this->type=CONSTRAINT_TEACHER_MIN_HOURS_PER_MORNING;
}

bool ConstraintTeacherMinHoursPerMorning::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	if(allowEmptyMornings==false){
		QString s=tr("Cannot generate a timetable with a constraint teacher min hours per morning with allow empty mornings=false. Please modify it,"
			" so that it allows empty mornings. If you need a facility like that, please use constraint teacher min mornings per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);

		return false;
	}

	return true;
}

bool ConstraintTeacherMinHoursPerMorning::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinHoursPerMorning::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinHoursPerMorning>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Hours_Per_Morning>"+CustomFETString::number(this->minHoursPerMorning)+"</Minimum_Hours_Per_Morning>\n";
	if(this->allowEmptyMornings)
		s+=IL3+"<Allow_Empty_Mornings>true</Allow_Empty_Mornings>\n";
	else
		s+=IL3+"<Allow_Empty_Mornings>false</Allow_Empty_Mornings>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinHoursPerMorning>\n";
	return s;
}

QString ConstraintTeacherMinHoursPerMorning::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher min hours per morning");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mH:%1", "Minimum hours (per morning)").arg(this->minHoursPerMorning);s+=translatedCommaSpace();
	s+=tr("AEM:%1", "Allow empty mornings").arg(yesNoTranslated(this->allowEmptyMornings));

	return begin+s+end;
}

QString ConstraintTeacherMinHoursPerMorning::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of hours per morning");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum hours per morning=%1").arg(this->minHoursPerMorning);s+="\n";
	s+=tr("Allow empty mornings=%1").arg(yesNoTranslated(this->allowEmptyMornings));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinHoursPerMorning::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	assert(this->allowEmptyMornings==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			if(d%2==1)
				continue;
			int n_hours_per_morning=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_per_morning++;

			if(n_hours_per_morning>0 && n_hours_per_morning<this->minHoursPerMorning){
				nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			if(d%2==1)
				continue;
			int n_hours_per_morning=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_per_morning++;

			if(n_hours_per_morning>0 && n_hours_per_morning<this->minHoursPerMorning){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher min %1 hours per morning broken for teacher %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->minHoursPerMorning))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(n_hours_per_morning)
					 )
					 +" "
					 +
					 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100));

					dl.append(s);
					cl.append(weightPercentage/100);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinHoursPerMorning::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinHoursPerMorning::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinHoursPerMorning::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursPerMorning::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursPerMorning::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursPerMorning::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerMorning>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMinHoursPerMorning::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMinHoursPerMorning::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerMorning>r.nHoursPerDay)
		minHoursPerMorning=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinHoursDailyRealDays::ConstraintTeachersMinHoursDailyRealDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_DAILY_REAL_DAYS;

	this->allowEmptyDays=true;
}

ConstraintTeachersMinHoursDailyRealDays::ConstraintTeachersMinHoursDailyRealDays(double wp, int minhours, bool _allowEmptyDays)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursDaily=minhours;

	this->allowEmptyDays=_allowEmptyDays;

	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintTeachersMinHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(r);

	if(allowEmptyDays==false){
		QString s=tr("Cannot generate a timetable with a constraint teachers min hours daily for real days with allow empty days=false. Please modify it,"
			" so that it allows empty days. If you need a facility like that, please use constraint teachers min days per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);

		return false;
	}

	return true;
}

bool ConstraintTeachersMinHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinHoursDailyRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	if(this->allowEmptyDays)
		s+=IL3+"<Allow_Empty_Days>true</Allow_Empty_Days>\n";
	else
		s+=IL3+"<Allow_Empty_Days>false</Allow_Empty_Days>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinHoursDailyRealDays>\n";
	return s;
}

QString ConstraintTeachersMinHoursDailyRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers min hours daily for real days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (daily)").arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("AED:%1", "Allow empty days").arg(yesNoTranslated(this->allowEmptyDays));

	return begin+s+end;
}

QString ConstraintTeachersMinHoursDailyRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of hours daily for real days"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Allow empty days=%1").arg(yesNoTranslated(this->allowEmptyDays));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	assert(this->allowEmptyDays==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek/2; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d][h]>0)
						n_hours_daily++;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d+1][h]>0)
						n_hours_daily++;

				if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
					nbroken++;
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek/2; d++){
				int n_hours_daily=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d][h]>0)
						n_hours_daily++;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][2*d+1][h]>0)
						n_hours_daily++;

				if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr("Time constraint teachers min %1 hours daily for real days broken for teacher %2, on real day %3, length=%4.")
						 .arg(CustomFETString::number(this->minHoursDaily))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(d/*r.daysOfTheWeek[d]*/)
						 .arg(n_hours_daily)
						 )
						 +
						 " "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));

						dl.append(s);
						cl.append(weightPercentage/100);

						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMinHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(a);
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeachersMinHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMinHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMinHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursDaily>2*r.nHoursPerDay)
		minHoursDaily=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinHoursDailyRealDays::ConstraintTeacherMinHoursDailyRealDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_HOURS_DAILY_REAL_DAYS;

	this->allowEmptyDays=true;
}

ConstraintTeacherMinHoursDailyRealDays::ConstraintTeacherMinHoursDailyRealDays(double wp, int minhours, const QString& teacher, bool _allowEmptyDays)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursDaily=minhours;
	this->teacherName=teacher;

	this->allowEmptyDays=_allowEmptyDays;

	this->type=CONSTRAINT_TEACHER_MIN_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintTeacherMinHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	if(allowEmptyDays==false){
		QString s=tr("Cannot generate a timetable with a constraint teacher min hours daily for real days with allow empty days=false. Please modify it,"
			" so that it allows empty days. If you need a facility like that, please use constraint teacher min days per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);

		return false;
	}

	return true;
}

bool ConstraintTeacherMinHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinHoursDailyRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Hours_Daily>"+CustomFETString::number(this->minHoursDaily)+"</Minimum_Hours_Daily>\n";
	if(this->allowEmptyDays)
		s+=IL3+"<Allow_Empty_Days>true</Allow_Empty_Days>\n";
	else
		s+=IL3+"<Allow_Empty_Days>false</Allow_Empty_Days>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinHoursDailyRealDays>\n";
	return s;
}

QString ConstraintTeacherMinHoursDailyRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher min hours daily for real days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mH:%1", "Minimum hours (daily)").arg(this->minHoursDaily);s+=translatedCommaSpace();
	s+=tr("AED:%1", "Allow empty days").arg(yesNoTranslated(this->allowEmptyDays));

	return begin+s+end;
}

QString ConstraintTeacherMinHoursDailyRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of hours daily for real days");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum hours daily=%1").arg(this->minHoursDaily);s+="\n";
	s+=tr("Allow empty days=%1").arg(yesNoTranslated(this->allowEmptyDays));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	assert(this->allowEmptyDays==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d][h]>0)
					n_hours_daily++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d+1][h]>0)
					n_hours_daily++;

			if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
				nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int n_hours_daily=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d][h]>0)
					n_hours_daily++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][2*d+1][h]>0)
					n_hours_daily++;

			if(n_hours_daily>0 && n_hours_daily<this->minHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher min %1 hours daily for real days broken for teacher %2, on real day %3, length=%4.")
					 .arg(CustomFETString::number(this->minHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(d/*r.daysOfTheWeek[d]*/)
					 .arg(n_hours_daily)
					 )
					 +" "
					 +
					 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100));

					dl.append(s);
					cl.append(weightPercentage/100);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(minHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMinHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMinHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursDaily>2*r.nHoursPerDay)
		minHoursDaily=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinRealDaysPerWeek::ConstraintTeacherMinRealDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_REAL_DAYS_PER_WEEK;
}

ConstraintTeacherMinRealDaysPerWeek::ConstraintTeacherMinRealDaysPerWeek(double wp, int mindays, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(mindays>0);
	this->minDaysPerWeek=mindays;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MIN_REAL_DAYS_PER_WEEK;
}

bool ConstraintTeacherMinRealDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMinRealDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinRealDaysPerWeek::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinRealDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Days_Per_Week>"+CustomFETString::number(this->minDaysPerWeek)+"</Minimum_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinRealDaysPerWeek>\n";
	return s;
}

QString ConstraintTeacherMinRealDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher min real days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mD:%1", "Minimum days per week").arg(this->minDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMinRealDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of real days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum days per week=%1").arg(this->minDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinRealDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	int i=this->teacher_ID;
	int nd=0;
	for(int d=0; d<r.nDaysPerWeek/2; d++){
		for(int h=0; h<r.nHoursPerDay; h++){
			if(teachersMatrix[i][2*d][h]>0 || teachersMatrix[i][2*d+1][h]>0){
				nd++;
				break;
			}
		}
	}

	if(nd<this->minDaysPerWeek){
		nbroken+=this->minDaysPerWeek-nd;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint teacher min %1 real days per week broken for teacher %2.")
			 .arg(CustomFETString::number(this->minDaysPerWeek))
			 .arg(r.internalTeachersList[i]->name)
			 )
			 +" "
			 +
			 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));

			dl.append(s);
			cl.append(double(nbroken)*weightPercentage/100);

			*conflictsString+= s+"\n";
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinRealDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinRealDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinRealDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRealDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRealDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRealDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minDaysPerWeek>r.nDaysPerWeek)
		return true;

	return false;
}

bool ConstraintTeacherMinRealDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMinRealDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minDaysPerWeek>r.nDaysPerWeek)
		minDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinRealDaysPerWeek::ConstraintTeachersMinRealDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_REAL_DAYS_PER_WEEK;
}

ConstraintTeachersMinRealDaysPerWeek::ConstraintTeachersMinRealDaysPerWeek(double wp, int mindays)
 : TimeConstraint(wp)
 {
	assert(mindays>0);
	this->minDaysPerWeek=mindays;

	this->type=CONSTRAINT_TEACHERS_MIN_REAL_DAYS_PER_WEEK;
}

bool ConstraintTeachersMinRealDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMinRealDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinRealDaysPerWeek::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinRealDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Days_Per_Week>"+CustomFETString::number(this->minDaysPerWeek)+"</Minimum_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinRealDaysPerWeek>\n";
	return s;
}

QString ConstraintTeachersMinRealDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers min real days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mD:%1", "Minimum days per week").arg(this->minDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMinRealDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of real days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum days per week=%1").arg(this->minDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinRealDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbrokentotal=0;
	for(int i=0; i<r.nInternalTeachers; i++){
		int nbroken;

		nbroken=0;
		//int i=this->teacher_ID;
		int nd=0;
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[i][2*d][h]>0 || teachersMatrix[i][2*d+1][h]>0){
					nd++;
					break;
				}
			}
		}

		if(nd<this->minDaysPerWeek){
			nbroken+=this->minDaysPerWeek-nd;
			nbrokentotal+=nbroken;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint teachers min %1 real days per week broken for teacher %2.")
				 .arg(CustomFETString::number(this->minDaysPerWeek))
				 .arg(r.internalTeachersList[i]->name)
				 )
				 +" "
				 +
				 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));

				dl.append(s);
				cl.append(double(nbroken)*weightPercentage/100);

				*conflictsString+= s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbrokentotal==0);

	return weightPercentage/100 * nbrokentotal;
}

bool ConstraintTeachersMinRealDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinRealDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersMinRealDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRealDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRealDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRealDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minDaysPerWeek>r.nDaysPerWeek)
		return true;

	return false;
}

bool ConstraintTeachersMinRealDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMinRealDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minDaysPerWeek>r.nDaysPerWeek)
		minDaysPerWeek=r.nDaysPerWeek;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

//morning

ConstraintTeacherMorningIntervalMaxDaysPerWeek::ConstraintTeacherMorningIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintTeacherMorningIntervalMaxDaysPerWeek::ConstraintTeacherMorningIntervalMaxDaysPerWeek(double wp, int maxnd, const QString& tn, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHER_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher morning interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher morning interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher morning interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	return true;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMorningIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMorningIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMorningIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeacherMorningIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher morning interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Abbreviation for teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMorningIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher respects working in an hourly morning interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMorningIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	int t=this->teacher_ID;

	nbroken=0;
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int d=0; d<r.nDaysPerWeek; d+=2){ //mornings
		ocDay[d]=false;
		for(int h=startHour; h<endHour; h++){
			if(teachersMatrix[t][d][h]>0){
				ocDay[d]=true;
			}
		}
	}
	int nOcDays=0;
	for(int d=0; d<r.nDaysPerWeek; d+=2) //mornings
		if(ocDay[d])
			nOcDays++;
	if(nOcDays > this->maxDaysPerWeek){
		nbroken+=nOcDays-this->maxDaysPerWeek;

		if(nbroken>0){
			QString s= tr("Time constraint teacher morning interval max days per week broken for teacher: %1, allowed %2 days, required %3 days.")
			 .arg(r.internalTeachersList[t]->name)
			 .arg(this->maxDaysPerWeek)
			 .arg(nOcDays);
			s+=" ";
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMorningIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

//morning

ConstraintTeachersMorningIntervalMaxDaysPerWeek::ConstraintTeachersMorningIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintTeachersMorningIntervalMaxDaysPerWeek::ConstraintTeachersMorningIntervalMaxDaysPerWeek(double wp, int maxnd, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHERS_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers morning interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers morning interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers morning interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	return true;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMorningIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMorningIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMorningIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeachersMorningIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers morning interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMorningIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers respect working in an hourly morning interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMorningIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int t=0; t<r.nInternalTeachers; t++){
		for(int d=0; d<r.nDaysPerWeek; d+=2){ //mornings
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(teachersMatrix[t][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2) //mornings
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if(nOcDays-this->maxDaysPerWeek>0){
				QString s= tr("Time constraint teachers morning interval max days per week broken for teacher: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalTeachersList[t]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMorningIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

//afternoon

ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::ConstraintTeacherAfternoonIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::ConstraintTeacherAfternoonIntervalMaxDaysPerWeek(double wp, int maxnd, const QString& tn, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHER_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher afternoon interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher afternoon interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher afternoon interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	return true;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherAfternoonIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherAfternoonIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher afternoon interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Abbreviation for teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher respects working in an hourly afternoon interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	int t=this->teacher_ID;

	nbroken=0;
	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int d=1; d<r.nDaysPerWeek; d+=2){ //afternoon
		ocDay[d]=false;
		for(int h=startHour; h<endHour; h++){
			if(teachersMatrix[t][d][h]>0){
				ocDay[d]=true;
			}
		}
	}
	int nOcDays=0;
	for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
		if(ocDay[d])
			nOcDays++;
	if(nOcDays > this->maxDaysPerWeek){
		nbroken+=nOcDays-this->maxDaysPerWeek;

		if(nbroken>0){
			QString s= tr("Time constraint teacher afternoon interval max days per week broken for teacher: %1, allowed %2 days, required %3 days.")
			 .arg(r.internalTeachersList[t]->name)
			 .arg(this->maxDaysPerWeek)
			 .arg(nOcDays);
			s+=" ";
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherAfternoonIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

//afternoon

ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::ConstraintTeachersAfternoonIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::ConstraintTeachersAfternoonIntervalMaxDaysPerWeek(double wp, int maxnd, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHERS_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers afternoon interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers afternoon interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers afternoon interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	return true;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersAfternoonIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersAfternoonIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers afternoon interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers respect working in an hourly afternoon interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int t=0; t<r.nInternalTeachers; t++){
		for(int d=1; d<r.nDaysPerWeek; d+=2){ //afternoon
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(teachersMatrix[t][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if(nOcDays-this->maxDaysPerWeek>0){
				QString s= tr("Time constraint teachers afternoon interval max days per week broken for teacher: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalTeachersList[t]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersAfternoonIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersActivityTagMaxHoursDailyRealDays::ConstraintTeachersActivityTagMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
}

ConstraintTeachersActivityTagMaxHoursDailyRealDays::ConstraintTeachersActivityTagMaxHoursDailyRealDays(double wp, int maxhours, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHERS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	this->canonicalTeachersList.clear();
	for(int i=0; i<r.nInternalTeachers; i++){
		bool found=false;

		Teacher* tch=r.internalTeachersList[i];
		for(int actIndex : std::as_const(tch->activitiesForTeacher)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}

		if(found)
			this->canonicalTeachersList.append(i);
	}

	return true;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersActivityTagMaxHoursDailyRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersActivityTagMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersActivityTagMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintTeachersActivityTagMaxHoursDailyRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers for activity tag %1 have max %2 hours daily per real day").arg(this->activityTagName).arg(this->maxHoursDaily);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersActivityTagMaxHoursDailyRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers, for an activity tag, must respect the maximum number of hours daily per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName); s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersActivityTagMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int d1=d*2;
			int d2=d*2+1;
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d1][h]==this->activityTagIndex)
					nd++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d2][h]==this->activityTagIndex)
					nd++;

			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr("Time constraint teachers activity tag %1 max %2 hours daily per real day broken for teacher %3, on real day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(d/*r.daysOfTheWeek[d]*/)
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));

					dl.append(s);
					cl.append(weightPercentage/100.0);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersActivityTagMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherActivityTagMaxHoursDailyRealDays::ConstraintTeacherActivityTagMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
}

ConstraintTeacherActivityTagMaxHoursDailyRealDays::ConstraintTeacherActivityTagMaxHoursDailyRealDays(double wp, int maxhours, const QString& teacher, const QString& activityTag)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->teacherName=teacher;
	this->activityTagName=activityTag;

	this->type=CONSTRAINT_TEACHER_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	this->canonicalTeachersList.clear();
	int i=this->teacher_ID;
	bool found=false;

	Teacher* tch=r.internalTeachersList[i];
	for(int actIndex : std::as_const(tch->activitiesForTeacher)){
		if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
			found=true;
			break;
		}
	}

	if(found)
		this->canonicalTeachersList.append(i);

	return true;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherActivityTagMaxHoursDailyRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherActivityTagMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherActivityTagMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintTeacherActivityTagMaxHoursDailyRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher %1 for activity tag %2 has max %3 hours daily per real day").arg(this->teacherName).arg(this->activityTagName).arg(this->maxHoursDaily);s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeacherActivityTagMaxHoursDailyRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher for an activity tag must respect the maximum number of hours daily per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherActivityTagMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int i : std::as_const(this->canonicalTeachersList)){
		Teacher* tch=r.internalTeachersList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtTeacherTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int d1=2*d;
			int d2=2*d+1;
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d1][h]==this->activityTagIndex)
					nd++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d2][h]==this->activityTagIndex)
					nd++;

			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr("Time constraint teacher activity tag %1 max %2 hours daily per real day broken for teacher %3, on real day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(d/*r.daysOfTheWeek[d]*/)
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));

					dl.append(s);
					cl.append(weightPercentage/100.0);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	return this->activityTagName==s->name;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherActivityTagMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsActivityTagMaxHoursDailyRealDays::ConstraintStudentsActivityTagMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
	this->maxHoursDaily = -1;
}

ConstraintStudentsActivityTagMaxHoursDailyRealDays::ConstraintStudentsActivityTagMaxHoursDailyRealDays(double wp, int maxnh, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	this->canonicalSubgroupsList.clear();
	for(int i=0; i<r.nInternalSubgroups; i++){
		bool found=false;

		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}

		if(found)
			this->canonicalSubgroupsList.append(i);
	}

	return true;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsActivityTagMaxHoursDailyRealDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsActivityTagMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";

	if(this->maxHoursDaily>=0)
		s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	else
		assert(0);
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsActivityTagMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintStudentsActivityTagMaxHoursDailyRealDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students for activity tag %1 have max %2 hours daily per real day")
		.arg(this->activityTagName).arg(this->maxHoursDaily); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsActivityTagMaxHoursDailyRealDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students, for an activity tag, must respect the maximum number of hours daily per real day"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsActivityTagMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int d1=d*2;
			int d2=d*2+1;
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d1][h]==this->activityTagIndex)
					nd++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d2][h]==this->activityTagIndex)
					nd++;

			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students, activity tag %1, max %2 hours daily per real day, broken for subgroup %3, on real day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(d/*r.daysOfTheWeek[d]*/)
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));

					dl.append(s);
					cl.append(weightPercentage/100);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	return s->name==this->activityTagName;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsActivityTagMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::ConstraintStudentsSetActivityTagMaxHoursDailyRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
	this->maxHoursDaily = -1;
}

ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::ConstraintStudentsSetActivityTagMaxHoursDailyRealDays(double wp, int maxnh, const QString& s, const QString& activityTag)
	: TimeConstraint(wp)
{
	this->maxHoursDaily = maxnh;
	this->students = s;
	this->activityTagName=activityTag;
	this->type = CONSTRAINT_STUDENTS_SET_ACTIVITY_TAG_MAX_HOURS_DAILY_REAL_DAYS;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetActivityTagMaxHoursDailyRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetActivityTagMaxHoursDailyRealDays>\n";
	return s;
}

QString ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students set %1 for activity tag %2 has max %3 hours daily per real day").arg(this->students).arg(this->activityTagName).arg(this->maxHoursDaily);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set, for an activity tag, must respect the maximum number of hours daily per real day"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Activity tag=%1").arg(this->activityTagName);s+="\n";
	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->activityTagIndex=r.searchActivityTag(this->activityTagName);
	activityTagIndex=r.activityTagsHash.value(activityTagName, -1);
	assert(this->activityTagIndex>=0);

	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours daily is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	/////////////
	this->canonicalSubgroupsList.clear();
	for(int i : std::as_const(this->iSubgroupsList)){
		bool found=false;

		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int actIndex : std::as_const(sbg->activitiesForSubgroup)){
			if(r.internalActivitiesList[actIndex].iActivityTagsSet.contains(this->activityTagIndex)){
				found=true;
				break;
			}
		}

		if(found)
			this->canonicalSubgroupsList.append(i);
	}


	return true;
}

double ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int i : std::as_const(this->canonicalSubgroupsList)){
		StudentsSubgroup* sbg=r.internalSubgroupsList[i];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;
		for(int ai : std::as_const(sbg->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				if(r.internalActivitiesList[ai].iActivityTagsSet.contains(this->activityTagIndex))
					crtSubgroupTimetableActivityTag[d][h+dur]=this->activityTagIndex;
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int d1=2*d;
			int d2=2*d+1;
			int nd=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d1][h]==this->activityTagIndex)
					nd++;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d2][h]==this->activityTagIndex)
					nd++;

			if(nd>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint students set, activity tag %1, max %2 hours daily per real day, broken for subgroup %3, on real day %4, length=%5.")
					 .arg(this->activityTagName)
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(d/*r.daysOfTheWeek[d]*/)
					 .arg(nd)
					 )
					 +
					 " "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100.0)));

					dl.append(s);
					cl.append(weightPercentage/100);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return weightPercentage/100.0 * nbroken;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursDaily>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetActivityTagMaxHoursDailyRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursDaily>2*r.nHoursPerDay)
		maxHoursDaily=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxGapsPerRealDay::ConstraintStudentsMaxGapsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_REAL_DAY;
}

ConstraintStudentsMaxGapsPerRealDay::ConstraintStudentsMaxGapsPerRealDay(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_REAL_DAY;
	this->maxGaps=mg;
}

bool ConstraintStudentsMaxGapsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxGapsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxGapsPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxGapsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxGapsPerRealDay>\n";
	return s;
}

QString ConstraintStudentsMaxGapsPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students max gaps per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per real day)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintStudentsMaxGapsPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of gaps per real day");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per real day=%1").arg(this->maxGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxGapsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nGaps;
	int tmp;
	int i;

	int tIllegalGaps=0;

	for(i=0; i<r.nInternalSubgroups; i++){
		for(int real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
			nGaps=0;

			int double_h;

			int k;
			tmp=0;
			for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			}
			for(; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
					if(subgroupsMatrix[i][j][k]>0){
						nGaps+=tmp;
						tmp=0;
					}
					else
						tmp++;
				}
			}

			int illegalGaps=nGaps-this->maxGaps;
			if(illegalGaps<0)
				illegalGaps=0;

			if(illegalGaps>0 && conflictsString!=nullptr){
				QString s=tr("Time constraint students max gaps per real day broken for subgroup: %1, it has %2 extra gaps, on real day number %3, conflicts increase=%4")
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(illegalGaps)
				 .arg(real_d)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(illegalGaps*weightPercentage/100));

				dl.append(s);
				cl.append(illegalGaps*weightPercentage/100);

				*conflictsString+= s+"\n";
			}

			tIllegalGaps+=illegalGaps;
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsMaxGapsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxGapsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxGapsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxGapsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMaxGapsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxGapsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>2*r.nHoursPerDay)
		maxGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxGapsPerRealDay::ConstraintStudentsSetMaxGapsPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_REAL_DAY;
}

ConstraintStudentsSetMaxGapsPerRealDay::ConstraintStudentsSetMaxGapsPerRealDay(double wp, int mg, const QString& st )
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_REAL_DAY;
	this->maxGaps=mg;
	this->students = st;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::computeInternalStructure(QWidget* parent, Rules& r){
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max gaps per real day is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxGapsPerRealDay::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxGapsPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxGapsPerRealDay>\n";
	return s;
}

QString ConstraintStudentsSetMaxGapsPerRealDay::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students set max gaps per real day"); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage)); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per real day)").arg(this->maxGaps);s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxGapsPerRealDay::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of gaps per real day");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per real day=%1").arg(this->maxGaps);s+="\n";
	s+=tr("Students=%1").arg(this->students); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxGapsPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//OLD COMMENT
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nGaps;
	int tmp;

	int tIllegalGaps=0;

	for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
		int i=this->iSubgroupsList.at(sg);
		for(int real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
			nGaps=0;

			tmp=0;

			int double_h;

			for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				int k=double_h%r.nHoursPerDay;
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			}
			for(; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				int k=double_h%r.nHoursPerDay;
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
					if(subgroupsMatrix[i][j][k]>0){
						nGaps+=tmp;
						tmp=0;
					}
					else
						tmp++;
				}
			}

			int illegalGaps=nGaps-this->maxGaps;
			if(illegalGaps<0)
				illegalGaps=0;

			if(illegalGaps>0 && conflictsString!=nullptr){
				QString s=tr("Time constraint students set max gaps per real day broken for subgroup: %1, extra gaps=%2, on real day number %3, conflicts increase=%4")
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(illegalGaps)
				 .arg(real_d)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*illegalGaps));

				dl.append(s);
				cl.append(weightPercentage/100*illegalGaps);

				*conflictsString+= s+"\n";
			}

			tIllegalGaps+=illegalGaps;
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)     //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxGapsPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxGapsPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>2*r.nHoursPerDay)
		maxGaps=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxRealDaysPerWeek::ConstraintStudentsSetMaxRealDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_REAL_DAYS_PER_WEEK;
}

ConstraintStudentsSetMaxRealDaysPerWeek::ConstraintStudentsSetMaxRealDaysPerWeek(double wp, int maxnd, const QString& sn)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_REAL_DAYS_PER_WEEK;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max real days per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxRealDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxRealDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxRealDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMaxRealDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set max real days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxRealDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of real days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxRealDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students set max real days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxRealDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxRealDaysPerWeek::ConstraintStudentsMaxRealDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_REAL_DAYS_PER_WEEK;
}

ConstraintStudentsMaxRealDaysPerWeek::ConstraintStudentsMaxRealDaysPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_MAX_REAL_DAYS_PER_WEEK;
}

bool ConstraintStudentsMaxRealDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxRealDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxRealDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxRealDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxRealDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsMaxRealDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students max real days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsMaxRealDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of real days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxRealDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students max real days per week broken for subgroup: %1, allowed %2 real days, required %3 real days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxRealDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxRealDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsMaxRealDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxRealDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxRealDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	return true;
}

bool ConstraintStudentsMaxRealDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsMaxRealDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxRealDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxSpanPerRealDay::ConstraintTeacherMaxSpanPerRealDay()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_SPAN_PER_REAL_DAY;
	this->maxSpanPerDay = -1;
	allowOneDayExceptionPlusOne=false;
}

ConstraintTeacherMaxSpanPerRealDay::ConstraintTeacherMaxSpanPerRealDay(double wp, int maxspan, bool except, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(maxspan>0);
	this->maxSpanPerDay=maxspan;
	this->teacherName=teacher;

	allowOneDayExceptionPlusOne=except;

	this->type=CONSTRAINT_TEACHER_MAX_SPAN_PER_REAL_DAY;
}

bool ConstraintTeacherMaxSpanPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxSpanPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxSpanPerRealDay::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxSpanPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Allow_One_Day_Exception_of_Plus_One>"+trueFalse(allowOneDayExceptionPlusOne)+"</Allow_One_Day_Exception_of_Plus_One>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxSpanPerRealDay>\n";
	return s;
}

QString ConstraintTeacherMaxSpanPerRealDay::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher max span per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MS:%1", "Maximum span (in hours, per real day)").arg(this->maxSpanPerDay);s+=translatedCommaSpace();
	s+=tr("ODE:%1", "One day exception (in which the teacher can have span+1)").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));

	return begin+s+end;
}

QString ConstraintTeacherMaxSpanPerRealDay::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of span (in hours) per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";
	s+=tr("Allow one day exception of plus one=%1").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxSpanPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	bool except;
	if(allowOneDayExceptionPlusOne)
		except=true;
	else
		except=false;

	for(int d=0; d<r.nDaysPerWeek/2; d++){
		int begin=-1;
		int end=-1;
		for(int h=0; h<2*r.nHoursPerDay; h++){
			int d3=d*2+(h<r.nHoursPerDay?0:1);
			int h3=h%r.nHoursPerDay;
			if(teachersMatrix[this->teacher_ID][d3][h3]>0){
				begin=h;
				break;
			}
		}
		for(int h=2*r.nHoursPerDay-1; h>=0; h--){
			int d3=d*2+(h<r.nHoursPerDay?0:1);
			int h3=h%r.nHoursPerDay;
			if(teachersMatrix[this->teacher_ID][d3][h3]>0){
				end=h;
				break;
			}
		}
		if(end>=0 && begin>=0 && end>=begin){
			int span=end-begin+1;
			if(span>this->maxSpanPerDay){
				if(except && span==maxSpanPerDay+1)
					except=false;
				else
					nbroken++;
			}
		}
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintTeacherMaxSpanPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxSpanPerRealDay::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxSpanPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSpanPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSpanPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSpanPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMaxSpanPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxSpanPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxSpanPerDay>2*r.nHoursPerDay)
		maxSpanPerDay=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxSpanPerRealDay::ConstraintTeachersMaxSpanPerRealDay()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_SPAN_PER_REAL_DAY;
	this->maxSpanPerDay = -1;
	allowOneDayExceptionPlusOne=false;
}

ConstraintTeachersMaxSpanPerRealDay::ConstraintTeachersMaxSpanPerRealDay(double wp, int maxspan, bool except)
 : TimeConstraint(wp)
 {
	assert(maxspan>0);
	this->maxSpanPerDay=maxspan;

	allowOneDayExceptionPlusOne=except;

	this->type=CONSTRAINT_TEACHERS_MAX_SPAN_PER_REAL_DAY;
}

bool ConstraintTeachersMaxSpanPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxSpanPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxSpanPerRealDay::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxSpanPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Allow_One_Day_Exception_of_Plus_One>"+trueFalse(allowOneDayExceptionPlusOne)+"</Allow_One_Day_Exception_of_Plus_One>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxSpanPerRealDay>\n";
	return s;
}

QString ConstraintTeachersMaxSpanPerRealDay::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers max span per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MS:%1", "Maximum span (in hours, per real day)").arg(this->maxSpanPerDay);s+=translatedCommaSpace();
	s+=tr("ODE:%1", "One day exception (in which the teachers can have span+1)").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));

	return begin+s+end;
}

QString ConstraintTeachersMaxSpanPerRealDay::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of span (in hours) per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";
	s+=tr("Allow one day exception of plus one=%1").arg(yesNoTranslated(this->allowOneDayExceptionPlusOne));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxSpanPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	for(int tch=0; tch<r.nInternalTeachers; tch++){
		bool except;
		if(allowOneDayExceptionPlusOne)
			except=true;
		else
			except=false;

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int begin=-1;
			int end=-1;
			for(int h=0; h<2*r.nHoursPerDay; h++){
				int d3=d*2+(h<r.nHoursPerDay?0:1);
				int h3=h%r.nHoursPerDay;
				if(teachersMatrix[tch][d3][h3]>0){
					begin=h;
					break;
				}
			}
			for(int h=2*r.nHoursPerDay-1; h>=0; h--){
				int d3=d*2+(h<r.nHoursPerDay?0:1);
				int h3=h%r.nHoursPerDay;
				if(teachersMatrix[tch][d3][h3]>0){
					end=h;
					break;
				}
			}
			if(end>=0 && begin>=0 && end>=begin){
				int span=end-begin+1;
				if(span>this->maxSpanPerDay){
					if(except && span==maxSpanPerDay+1)
						except=false;
					else
						nbroken++;
				}
			}
		}
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintTeachersMaxSpanPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxSpanPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxSpanPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSpanPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSpanPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSpanPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMaxSpanPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxSpanPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxSpanPerDay>2*r.nHoursPerDay)
		maxSpanPerDay=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxSpanPerRealDay::ConstraintStudentsSetMaxSpanPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_REAL_DAY;
	this->maxSpanPerDay = -1;
}

ConstraintStudentsSetMaxSpanPerRealDay::ConstraintStudentsSetMaxSpanPerRealDay(double wp, int maxspan, const QString& sn)
	: TimeConstraint(wp)
{
	this->maxSpanPerDay = maxspan;
	this->students = sn;
	this->type = CONSTRAINT_STUDENTS_SET_MAX_SPAN_PER_REAL_DAY;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxSpanPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxSpanPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxSpanPerRealDay>\n";
	return s;
}

QString ConstraintStudentsSetMaxSpanPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students set max span per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students); s+=translatedCommaSpace();
	s+=tr("MS:%1", "Max span (in hours, per real day)").arg(this->maxSpanPerDay);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxSpanPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of span (in hours) per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max span per real day is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

double ConstraintStudentsSetMaxSpanPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int begin=-1;
			int end=-1;
			for(int h=0; h<2*r.nHoursPerDay; h++){
				int d3=d*2+(h<r.nHoursPerDay?0:1);
				int h3=h%r.nHoursPerDay;
				if(subgroupsMatrix[sbg][d3][h3]>0){
					begin=h;
					break;
				}
			}
			for(int h=2*r.nHoursPerDay-1; h>=0; h--){
				int d3=d*2+(h<r.nHoursPerDay?0:1);
				int h3=h%r.nHoursPerDay;
				if(subgroupsMatrix[sbg][d3][h3]>0){
					end=h;
					break;
				}
			}
			if(end>=0 && begin>=0 && end>=begin){
				int span=end-begin+1;
				if(span>this->maxSpanPerDay)
					nbroken++;
			}
		}
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxSpanPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxSpanPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxSpanPerDay>2*r.nHoursPerDay)
		maxSpanPerDay=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxSpanPerRealDay::ConstraintStudentsMaxSpanPerRealDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_SPAN_PER_REAL_DAY;
	this->maxSpanPerDay = -1;
}

ConstraintStudentsMaxSpanPerRealDay::ConstraintStudentsMaxSpanPerRealDay(double wp, int maxspan)
	: TimeConstraint(wp)
{
	this->maxSpanPerDay = maxspan;
	this->type = CONSTRAINT_STUDENTS_MAX_SPAN_PER_REAL_DAY;
}

bool ConstraintStudentsMaxSpanPerRealDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxSpanPerRealDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxSpanPerRealDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Span>"+CustomFETString::number(this->maxSpanPerDay)+"</Max_Span>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxSpanPerRealDay>\n";
	return s;
}

QString ConstraintStudentsMaxSpanPerRealDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students max span per real day");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MS:%1", "Max span (in hours, per day)").arg(this->maxSpanPerDay);

	return begin+s+end;
}

QString ConstraintStudentsMaxSpanPerRealDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of span (in hours) per real day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum span per day=%1").arg(this->maxSpanPerDay);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMaxSpanPerRealDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

double ConstraintStudentsMaxSpanPerRealDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int begin=-1;
			int end=-1;
			for(int h=0; h<2*r.nHoursPerDay; h++){
				int d3=d*2+(h<r.nHoursPerDay?0:1);
				int h3=h%r.nHoursPerDay;
				if(subgroupsMatrix[sbg][d3][h3]>0){
					begin=h;
					break;
				}
			}
			for(int h=2*r.nHoursPerDay-1; h>=0; h--){
				int d3=d*2+(h<r.nHoursPerDay?0:1);
				int h3=h%r.nHoursPerDay;
				if(subgroupsMatrix[sbg][d3][h3]>0){
					end=h;
					break;
				}
			}
			if(end>=0 && begin>=0 && end>=begin){
				int span=end-begin+1;
				if(span>this->maxSpanPerDay)
					nbroken++;
			}
		}
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintStudentsMaxSpanPerRealDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxSpanPerRealDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxSpanPerRealDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxSpanPerRealDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxSpanPerRealDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxSpanPerRealDay::hasWrongDayOrHour(Rules& r)
{
	if(maxSpanPerDay>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMaxSpanPerRealDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxSpanPerRealDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxSpanPerDay>2*r.nHoursPerDay)
		maxSpanPerDay=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxAfternoonsPerWeek::ConstraintTeacherMaxAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_AFTERNOONS_PER_WEEK;
}

ConstraintTeacherMaxAfternoonsPerWeek::ConstraintTeacherMaxAfternoonsPerWeek(double wp, int maxnd, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxAfternoonsPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHER_MAX_AFTERNOONS_PER_WEEK;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxAfternoonsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Afternoons_Per_Week>"+CustomFETString::number(this->maxAfternoonsPerWeek)+"</Max_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintTeacherMaxAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MA:%1", "Max afternoons (per week)").arg(this->maxAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMaxAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum afternoons per week=%1").arg(this->maxAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		int nd[MAX_HOURS_PER_DAY + 1];
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{*/
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		//int nd[2*MAX_HOURS_PER_DAY + 1];
		int nOD=0; //n occupied days
		//for(int h=0; h<=2*r.nHoursPerDay; h++)
		//nd[h]=0;
		for(int d=1; d<r.nDaysPerWeek; d+=2){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			if(nh>0)
				nOD++;
			//nd[nh]++;
		}

		//return the minimum occupied days which do not respect this constraint
/*		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=2*r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}*/

		if(nOD>this->maxAfternoonsPerWeek)
			nbroken=1;

		if(nbroken>0 && conflictsString!=nullptr){
			QString s= tr("Time constraint teacher max afternoons per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}
	//}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		maxAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxAfternoonsPerWeek::ConstraintTeachersMaxAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_AFTERNOONS_PER_WEEK;
}

ConstraintTeachersMaxAfternoonsPerWeek::ConstraintTeachersMaxAfternoonsPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxAfternoonsPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHERS_MAX_AFTERNOONS_PER_WEEK;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxAfternoonsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Afternoons_Per_Week>"+CustomFETString::number(this->maxAfternoonsPerWeek)+"</Max_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintTeachersMaxAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MA:%1", "Max afternoons (per week)").arg(this->maxAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMaxAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum afternoons per week=%1").arg(this->maxAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort

		for(int t=0; t<r.nInternalTeachers; t++){
			int nd[MAX_HOURS_PER_DAY + 1];
			for(int h=0; h<=r.nHoursPerDay; h++)
				nd[h]=0;
			for(int d=0; d<r.nDaysPerWeek; d++){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
				nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						break;
					}
				}
			}

		}
	}
	//with logging
	else{*/
		nbroken=0;

		for(int t=0; t<r.nInternalTeachers; t++){
			int nbr=0;

			//count sort
			//int t=this->teacher_ID;
			//int nd[2*MAX_HOURS_PER_DAY + 1];
			//for(int h=0; h<=2*r.nHoursPerDay; h++)
			//	nd[h]=0;
			int nOD=0;
			for(int d=1; d<r.nDaysPerWeek; d+=2){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
				if(nh>0)
					nOD++;
				//nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
/*			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=2*r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
						nbr+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						nbr+=i*k;
						break;
					}
				}
			}*/

			if(nOD>this->maxAfternoonsPerWeek)
				 nbr=1;

			if(nbr>0 && conflictsString!=nullptr){
				QString s= tr("Time constraint teachers max afternoons per week broken for teacher: %1.")
				.arg(r.internalTeachersList[t]->name);
				s += tr("This increases the conflicts total by %1")
				.arg(CustomFETString::numberPlusTwoDigitsPrecision(nbr*weightPercentage/100));

				dl.append(s);
				cl.append(nbr*weightPercentage/100);

				*conflictsString += s+"\n";
			}

		}
//	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		maxAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxMorningsPerWeek::ConstraintTeacherMaxMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_MORNINGS_PER_WEEK;
}

ConstraintTeacherMaxMorningsPerWeek::ConstraintTeacherMaxMorningsPerWeek(double wp, int maxnd, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxMorningsPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHER_MAX_MORNINGS_PER_WEEK;
}

bool ConstraintTeacherMaxMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxMorningsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Mornings_Per_Week>"+CustomFETString::number(this->maxMorningsPerWeek)+"</Max_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxMorningsPerWeek>\n";
	return s;
}

QString ConstraintTeacherMaxMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MM:%1", "Max mornings (per week)").arg(this->maxMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMaxMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum mornings per week=%1").arg(this->maxMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		int nd[MAX_HOURS_PER_DAY + 1];
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{*/
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		//int nd[2*MAX_HOURS_PER_DAY + 1];
		int nOD=0; //n occupied days
		//for(int h=0; h<=2*r.nHoursPerDay; h++)
		//nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			if(nh>0)
				nOD++;
			//nd[nh]++;
		}

		//return the minimum occupied days which do not respect this constraint
/*		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=2*r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}*/

		if(nOD>this->maxMorningsPerWeek)
			nbroken=1;

		if(nbroken>0 && conflictsString!=nullptr){
			QString s= tr("Time constraint teacher max mornings per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}
	//}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherMaxMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxMorningsPerWeek>r.nDaysPerWeek/2)
		maxMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxMorningsPerWeek::ConstraintTeachersMaxMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_MORNINGS_PER_WEEK;
}

ConstraintTeachersMaxMorningsPerWeek::ConstraintTeachersMaxMorningsPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxMorningsPerWeek=maxnd;
	this->type=CONSTRAINT_TEACHERS_MAX_MORNINGS_PER_WEEK;
}

bool ConstraintTeachersMaxMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxMorningsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Mornings_Per_Week>"+CustomFETString::number(this->maxMorningsPerWeek)+"</Max_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxMorningsPerWeek>\n";
	return s;
}

QString ConstraintTeachersMaxMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MM:%1", "Max mornings (per week)").arg(this->maxMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMaxMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum mornings per week=%1").arg(this->maxMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort

		for(int t=0; t<r.nInternalTeachers; t++){
			int nd[MAX_HOURS_PER_DAY + 1];
			for(int h=0; h<=r.nHoursPerDay; h++)
				nd[h]=0;
			for(int d=0; d<r.nDaysPerWeek; d++){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
				nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						break;
					}
				}
			}

		}
	}
	//with logging
	else{*/
		nbroken=0;

		for(int t=0; t<r.nInternalTeachers; t++){
			int nbr=0;

			//count sort
			//int t=this->teacher_ID;
			//int nd[2*MAX_HOURS_PER_DAY + 1];
			//for(int h=0; h<=2*r.nHoursPerDay; h++)
			//	nd[h]=0;
			int nOD=0;
			for(int d=0; d<r.nDaysPerWeek; d+=2){
				int nh=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
				if(nh>0)
					nOD++;
				//nd[nh]++;
			}
			//return the minimum occupied days which do not respect this constraint
/*			int i = r.nDaysPerWeek - this->maxDaysPerWeek;
			for(int k=0; k<=2*r.nHoursPerDay; k++){
				if(nd[k]>0){
					if(i>nd[k]){
						i-=nd[k];
						nbroken+=nd[k]*k;
						nbr+=nd[k]*k;
					}
					else{
						nbroken+=i*k;
						nbr+=i*k;
						break;
					}
				}
			}*/

			if(nOD>this->maxMorningsPerWeek)
				 nbr=1;

			if(nbr>0 && conflictsString!=nullptr){
				QString s= tr("Time constraint teachers max mornings per week broken for teacher: %1.")
				.arg(r.internalTeachersList[t]->name);
				s += tr("This increases the conflicts total by %1")
				.arg(CustomFETString::numberPlusTwoDigitsPrecision(nbr*weightPercentage/100));

				dl.append(s);
				cl.append(nbr*weightPercentage/100);

				*conflictsString += s+"\n";
			}

		}
//	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(maxMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersMaxMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxMorningsPerWeek>r.nDaysPerWeek/2)
		maxMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxActivityTagsPerDayFromSet::ConstraintTeacherMaxActivityTagsPerDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
}

ConstraintTeacherMaxActivityTagsPerDayFromSet::ConstraintTeacherMaxActivityTagsPerDayFromSet(double wp, const QString& tn, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->type=CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	//Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	
	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);
		
		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}
		
		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxActivityTagsPerDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxActivityTagsPerDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxActivityTagsPerDayFromSet>\n";
	return s;
}

QString ConstraintTeacherMaxActivityTagsPerDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max activity tags per day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintTeacherMaxActivityTagsPerDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect a maximum number of activity tags per day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxActivityTagsPerDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Teacher* tch=r.internalTeachersList[teacher_ID];
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			crtTeacherTimetableActivityTag[d][h]=-1;

	for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
		QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
		ts.intersect(this->internalTagsSet);
		assert(ts.count()<=1);
		int at=-1;
		if(!ts.isEmpty())
			at=*ts.constBegin();
		
		int d=c.times[ai]%r.nDaysPerWeek;
		int h=c.times[ai]/r.nDaysPerWeek;
		for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
			assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
			crtTeacherTimetableActivityTag[d][h+dur]=at;
		}
	}

	for(int d=0; d<r.nDaysPerWeek; d++){
		QSet<int> usedTags;
		for(int h=0; h<r.nHoursPerDay; h++)
			if(crtTeacherTimetableActivityTag[d][h]>=0)
				usedTags.insert(crtTeacherTimetableActivityTag[d][h]);

		if(usedTags.count() > this->maxTags)
			nbroken++;
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>r.nHoursPerDay;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxActivityTagsPerDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>r.nHoursPerDay)
		this->maxTags=r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxActivityTagsPerDayFromSet::ConstraintTeachersMaxActivityTagsPerDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
}

ConstraintTeachersMaxActivityTagsPerDayFromSet::ConstraintTeachersMaxActivityTagsPerDayFromSet(double wp, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	//Q_UNUSED(parent);
	//Q_UNUSED(r);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	//teacher_ID=r.teachersHash.value(teacherName, -1);
	//assert(this->teacher_ID>=0);
	
	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);

		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}

		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxActivityTagsPerDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxActivityTagsPerDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxActivityTagsPerDayFromSet>\n";
	return s;
}

QString ConstraintTeachersMaxActivityTagsPerDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max activity tags per day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintTeachersMaxActivityTagsPerDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect a maximum number of activity tags per day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxActivityTagsPerDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int teacher_ID=0; teacher_ID<r.nInternalTeachers; teacher_ID++){
		Teacher* tch=r.internalTeachersList[teacher_ID];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
			ts.intersect(this->internalTagsSet);
			assert(ts.count()<=1);
			int at=-1;
			if(!ts.isEmpty())
				at=*ts.constBegin();

			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				crtTeacherTimetableActivityTag[d][h+dur]=at;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			QSet<int> usedTags;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtTeacherTimetableActivityTag[d][h]>=0)
					usedTags.insert(crtTeacherTimetableActivityTag[d][h]);

			if(usedTags.count() > this->maxTags)
				nbroken++;
		}
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>r.nHoursPerDay;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxActivityTagsPerDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>r.nHoursPerDay)
		this->maxTags=r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinMorningsPerWeek::ConstraintTeacherMinMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_MORNINGS_PER_WEEK;
}

ConstraintTeacherMinMorningsPerWeek::ConstraintTeacherMinMorningsPerWeek(double wp, int minmornings, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(minmornings>0);
	this->minMorningsPerWeek=minmornings;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MIN_MORNINGS_PER_WEEK;
}

bool ConstraintTeacherMinMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMinMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinMorningsPerWeek::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Mornings_Per_Week>"+CustomFETString::number(this->minMorningsPerWeek)+"</Minimum_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinMorningsPerWeek>\n";
	return s;
}

QString ConstraintTeacherMinMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher min mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mM:%1", "Minimum mornings per week").arg(this->minMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMinMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum mornings per week=%1").arg(this->minMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	int i=this->teacher_ID;
	int nd=0;
	for(int d=0; d<r.nDaysPerWeek; d++)if((d%2)==0){
		for(int h=0; h<r.nHoursPerDay; h++){
			if(teachersMatrix[i][d][h]>0){
				nd++;
				break;
			}
		}
	}

	if(nd<this->minMorningsPerWeek){
		nbroken+=this->minMorningsPerWeek-nd;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint teacher min %1 mornings per week broken for teacher %2.")
			 .arg(CustomFETString::number(this->minMorningsPerWeek))
			 .arg(r.internalTeachersList[i]->name)
			 )
			 +" "
			 +
			 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));

			dl.append(s);
			cl.append(double(nbroken)*weightPercentage/100);

			*conflictsString+= s+"\n";
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherMinMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMinMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minMorningsPerWeek>r.nDaysPerWeek/2)
		minMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinMorningsPerWeek::ConstraintTeachersMinMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_MORNINGS_PER_WEEK;
}

ConstraintTeachersMinMorningsPerWeek::ConstraintTeachersMinMorningsPerWeek(double wp, int minmornings)
 : TimeConstraint(wp)
 {
	assert(minmornings>0);
	this->minMorningsPerWeek=minmornings;

	this->type=CONSTRAINT_TEACHERS_MIN_MORNINGS_PER_WEEK;
}

bool ConstraintTeachersMinMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMinMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinMorningsPerWeek::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Mornings_Per_Week>"+CustomFETString::number(this->minMorningsPerWeek)+"</Minimum_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinMorningsPerWeek>\n";
	return s;
}

QString ConstraintTeachersMinMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers min mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mM:%1", "Minimum morning per week").arg(this->minMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMinMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum mornings per week=%1").arg(this->minMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbrokentotal=0;
	for(int i=0; i<r.nInternalTeachers; i++){
		int nbroken;

		nbroken=0;
		//int i=this->teacher_ID;
		int nd=0;
		for(int d=0; d<r.nDaysPerWeek; d++)if((d%2)==0){
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[i][d][h]>0){
					nd++;
					break;
				}
			}
		}

		if(nd<this->minMorningsPerWeek){
			nbroken+=this->minMorningsPerWeek-nd;
			nbrokentotal+=nbroken;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint teachers min %1 mornings per week broken for teacher %2.")
				 .arg(CustomFETString::number(this->minMorningsPerWeek))
				 .arg(r.internalTeachersList[i]->name)
				 )
				 +" "
				 +
				 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));

				dl.append(s);
				cl.append(double(nbroken)*weightPercentage/100);

				*conflictsString+= s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbrokentotal==0);

	return weightPercentage/100 * nbrokentotal;
}

bool ConstraintTeachersMinMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersMinMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersMinMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMinMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minMorningsPerWeek>r.nDaysPerWeek/2)
		minMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinAfternoonsPerWeek::ConstraintTeacherMinAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_AFTERNOONS_PER_WEEK;
}

ConstraintTeacherMinAfternoonsPerWeek::ConstraintTeacherMinAfternoonsPerWeek(double wp, int minafternoons, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(minafternoons>0);
	this->minAfternoonsPerWeek=minafternoons;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MIN_AFTERNOONS_PER_WEEK;
}

bool ConstraintTeacherMinAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMinAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinAfternoonsPerWeek::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Afternoons_Per_Week>"+CustomFETString::number(this->minAfternoonsPerWeek)+"</Minimum_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintTeacherMinAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher min afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mA:%1", "Minimum afternoons per week").arg(this->minAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintTeacherMinAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum afternoons per week=%1").arg(this->minAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;
	int i=this->teacher_ID;
	int nd=0;
	for(int d=0; d<r.nDaysPerWeek; d++)if((d%2)==1){
		for(int h=0; h<r.nHoursPerDay; h++){
			if(teachersMatrix[i][d][h]>0){
				nd++;
				break;
			}
		}
	}

	if(nd<this->minAfternoonsPerWeek){
		nbroken+=this->minAfternoonsPerWeek-nd;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint teacher min %1 afternoons per week broken for teacher %2.")
			 .arg(CustomFETString::number(this->minAfternoonsPerWeek))
			 .arg(r.internalTeachersList[i]->name)
			 )
			 +" "
			 +
			 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));

			dl.append(s);
			cl.append(double(nbroken)*weightPercentage/100);

			*conflictsString+= s+"\n";
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherMinAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMinAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minAfternoonsPerWeek>r.nDaysPerWeek/2)
		minAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinAfternoonsPerWeek::ConstraintTeachersMinAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_AFTERNOONS_PER_WEEK;
}

ConstraintTeachersMinAfternoonsPerWeek::ConstraintTeachersMinAfternoonsPerWeek(double wp, int minafternoons)
 : TimeConstraint(wp)
 {
	assert(minafternoons>0);
	this->minAfternoonsPerWeek=minafternoons;

	this->type=CONSTRAINT_TEACHERS_MIN_AFTERNOONS_PER_WEEK;
}

bool ConstraintTeachersMinAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMinAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinAfternoonsPerWeek::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Afternoons_Per_Week>"+CustomFETString::number(this->minAfternoonsPerWeek)+"</Minimum_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintTeachersMinAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers min afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mA:%1", "Minimum afternoons per week").arg(this->minAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintTeachersMinAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum afternoons per week=%1").arg(this->minAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbrokentotal=0;
	for(int i=0; i<r.nInternalTeachers; i++){
		int nbroken;

		nbroken=0;
		//int i=this->teacher_ID;
		int nd=0;
		for(int d=0; d<r.nDaysPerWeek; d++)if((d%2)==1){
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[i][d][h]>0){
					nd++;
					break;
				}
			}
		}

		if(nd<this->minAfternoonsPerWeek){
			nbroken+=this->minAfternoonsPerWeek-nd;
			nbrokentotal+=nbroken;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint teachers min %1 afternoons per week broken for teacher %2.")
				 .arg(CustomFETString::number(this->minAfternoonsPerWeek))
				 .arg(r.internalTeachersList[i]->name)
				 )
				 +" "
				 +
				 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(double(nbroken)*weightPercentage/100));

				dl.append(s);
				cl.append(double(nbroken)*weightPercentage/100);

				*conflictsString+= s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbrokentotal==0);

	return weightPercentage/100 * nbrokentotal;
}

bool ConstraintTeachersMinAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersMinAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(minAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersMinAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMinAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minAfternoonsPerWeek>r.nDaysPerWeek/2)
		minAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxTwoConsecutiveMornings::ConstraintTeacherMaxTwoConsecutiveMornings()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_TWO_CONSECUTIVE_MORNINGS;
}

ConstraintTeacherMaxTwoConsecutiveMornings::ConstraintTeacherMaxTwoConsecutiveMornings(double wp, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->type=CONSTRAINT_TEACHER_MAX_TWO_CONSECUTIVE_MORNINGS;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxTwoConsecutiveMornings::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxTwoConsecutiveMornings>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxTwoConsecutiveMornings>\n";
	return s;
}

QString ConstraintTeacherMaxTwoConsecutiveMornings::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max two consecutive mornings");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeacherMaxTwoConsecutiveMornings::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect maximum two consecutive mornings");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxTwoConsecutiveMornings::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	//int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		int nd[MAX_HOURS_PER_DAY + 1];
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{*/
	//	nbroken=0;
		//count sort
/*		int t=this->teacher_ID;
		//int nd[2*MAX_HOURS_PER_DAY + 1];
		int nOD=0; //n occupied days
		//for(int h=0; h<=2*r.nHoursPerDay; h++)
		//nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			if(nh>0)
				nOD++;
			//nd[nh]++;
		}*/

		//return the minimum occupied days which do not respect this constraint
/*		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=2*r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}*/

/*		if(nOD>this->maxMorningsPerWeek)
			nbroken=1;

		if(nbroken>0 && conflictsString!=nullptr){
			QString s= tr("Time constraint teacher max mornings per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}*/
	//}

/*	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;*/

	int tch=this->teacher_ID;
	Matrix1D<bool> occDay;
	occDay.resize(r.nDaysPerWeek);
//	for(int tch=0; tch<r.nInternalTeachers; tch++){
		for(int d=0; d<r.nDaysPerWeek; d+=2){
			occDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[tch][d][h]>0){
					occDay[d]=true;
					break;
				}
			}
		}
		for(int d=0; d+4<r.nDaysPerWeek; d+=2)
			if(occDay[d] && occDay[d+2] && occDay[d+4])
				assert(0);
//	}

	return 0.0;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxTwoConsecutiveMornings::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxTwoConsecutiveMornings::ConstraintTeachersMaxTwoConsecutiveMornings()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_TWO_CONSECUTIVE_MORNINGS;
}

ConstraintTeachersMaxTwoConsecutiveMornings::ConstraintTeachersMaxTwoConsecutiveMornings(double wp)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_TEACHERS_MAX_TWO_CONSECUTIVE_MORNINGS;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	//teacher_ID=r.teachersHash.value(teacherName, -1);
	//assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxTwoConsecutiveMornings::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxTwoConsecutiveMornings>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
//	s+="	<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxTwoConsecutiveMornings>\n";
	return s;
}

QString ConstraintTeachersMaxTwoConsecutiveMornings::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max two consecutive mornings");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));
//	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeachersMaxTwoConsecutiveMornings::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect maximum two consecutive mornings");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
//	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxTwoConsecutiveMornings::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	//int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		int nd[MAX_HOURS_PER_DAY + 1];
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{*/
//		nbroken=0;
		//count sort
/*		int t=this->teacher_ID;
		//int nd[2*MAX_HOURS_PER_DAY + 1];
		int nOD=0; //n occupied days
		//for(int h=0; h<=2*r.nHoursPerDay; h++)
		//nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			if(nh>0)
				nOD++;
			//nd[nh]++;
		}*/

		//return the minimum occupied days which do not respect this constraint
/*		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=2*r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}*/

/*		if(nOD>this->maxMorningsPerWeek)
			nbroken=1;

		if(nbroken>0 && conflictsString!=nullptr){
			QString s= tr("Time constraint teacher max mornings per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}*/
	//}

/*	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;*/

	Matrix1D<bool> occDay;
	occDay.resize(r.nDaysPerWeek);
	for(int tch=0; tch<r.nInternalTeachers; tch++){
		for(int d=0; d<r.nDaysPerWeek; d+=2){
			occDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[tch][d][h]>0){
					occDay[d]=true;
					break;
				}
			}
		}
		for(int d=0; d+4<r.nDaysPerWeek; d+=2)
			if(occDay[d] && occDay[d+2] && occDay[d+4])
				assert(0);
	}

	return 0.0;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	//if(this->teacherName==t->name)
	//	return true;
	//return false;
	return true;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxTwoConsecutiveMornings::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxTwoConsecutiveAfternoons::ConstraintTeacherMaxTwoConsecutiveAfternoons()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_TWO_CONSECUTIVE_AFTERNOONS;
}

ConstraintTeacherMaxTwoConsecutiveAfternoons::ConstraintTeacherMaxTwoConsecutiveAfternoons(double wp, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->type=CONSTRAINT_TEACHER_MAX_TWO_CONSECUTIVE_AFTERNOONS;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxTwoConsecutiveAfternoons::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxTwoConsecutiveAfternoons>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxTwoConsecutiveAfternoons>\n";
	return s;
}

QString ConstraintTeacherMaxTwoConsecutiveAfternoons::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max two consecutive afternoons");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeacherMaxTwoConsecutiveAfternoons::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect maximum two consecutive afternoons");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxTwoConsecutiveAfternoons::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	//int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		int nd[MAX_HOURS_PER_DAY + 1];
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{*/
//		nbroken=0;
		//count sort
/*		int t=this->teacher_ID;
		//int nd[2*MAX_HOURS_PER_DAY + 1];
		int nOD=0; //n occupied days
		//for(int h=0; h<=2*r.nHoursPerDay; h++)
		//nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			if(nh>0)
				nOD++;
			//nd[nh]++;
		}*/

		//return the minimum occupied days which do not respect this constraint
/*		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=2*r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}*/

/*		if(nOD>this->maxAfternoonsPerWeek)
			nbroken=1;

		if(nbroken>0 && conflictsString!=nullptr){
			QString s= tr("Time constraint teacher max afternoons per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}*/
	//}

/*	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;*/

	Matrix1D<bool> occDay;
	occDay.resize(r.nDaysPerWeek);
	int tch=this->teacher_ID;
//	for(int tch=0; tch<r.nInternalTeachers; tch++){
		for(int d=1; d<r.nDaysPerWeek; d+=2){
			occDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[tch][d][h]>0){
					occDay[d]=true;
					break;
				}
			}
		}
		for(int d=1; d+4<r.nDaysPerWeek; d+=2)
			if(occDay[d] && occDay[d+2] && occDay[d+4])
				assert(0);
//	}

	return 0.0;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxTwoConsecutiveAfternoons::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxTwoConsecutiveAfternoons::ConstraintTeachersMaxTwoConsecutiveAfternoons()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_TWO_CONSECUTIVE_AFTERNOONS;
}

ConstraintTeachersMaxTwoConsecutiveAfternoons::ConstraintTeachersMaxTwoConsecutiveAfternoons(double wp)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_TEACHERS_MAX_TWO_CONSECUTIVE_AFTERNOONS;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	//teacher_ID=r.teachersHash.value(teacherName, -1);
	//assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxTwoConsecutiveAfternoons::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxTwoConsecutiveAfternoons>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
//	s+="	<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxTwoConsecutiveAfternoons>\n";
	return s;
}

QString ConstraintTeachersMaxTwoConsecutiveAfternoons::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max two consecutive afternoons");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));
//	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeachersMaxTwoConsecutiveAfternoons::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect maximum two consecutive afternoons");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
//	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxTwoConsecutiveAfternoons::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

//	int nbroken;

	//without logging
	/*
	if(conflictsString==nullptr){
		nbroken=0;
		//count sort
		int t=this->teacher_ID;
		int nd[MAX_HOURS_PER_DAY + 1];
		for(int h=0; h<=r.nHoursPerDay; h++)
			nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			nd[nh]++;
		}
		//return the minimum occupied days which do not respect this constraint
		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}
	}
	//with logging
	else{*/
//		nbroken=0;
		//count sort
/*		int t=this->teacher_ID;
		//int nd[2*MAX_HOURS_PER_DAY + 1];
		int nOD=0; //n occupied days
		//for(int h=0; h<=2*r.nHoursPerDay; h++)
		//nd[h]=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;
			if(nh>0)
				nOD++;
			//nd[nh]++;
		}*/

		//return the minimum occupied days which do not respect this constraint
/*		int i = r.nDaysPerWeek - this->maxDaysPerWeek;
		for(int k=0; k<=2*r.nHoursPerDay; k++){
			if(nd[k]>0){
				if(i>nd[k]){
					i-=nd[k];
					nbroken+=nd[k]*k;
				}
				else{
					nbroken+=i*k;
					break;
				}
			}
		}*/

/*		if(nOD>this->maxAfternoonsPerWeek)
			nbroken=1;

		if(nbroken>0 && conflictsString!=nullptr){
			QString s= tr("Time constraint teacher max afternoons per week broken for teacher: %1.")
			 .arg(r.internalTeachersList[t]->name);
			s += tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));

			dl.append(s);
			cl.append(nbroken*weightPercentage/100);

			*conflictsString += s+"\n";
		}*/
	//}

/*	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;*/

	Matrix1D<bool> occDay;
	occDay.resize(r.nDaysPerWeek);
	for(int tch=0; tch<r.nInternalTeachers; tch++){
		for(int d=1; d<r.nDaysPerWeek; d+=2){
			occDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[tch][d][h]>0){
					occDay[d]=true;
					break;
				}
			}
		}
		for(int d=1; d+4<r.nDaysPerWeek; d+=2)
			if(occDay[d] && occDay[d+2] && occDay[d+4])
				assert(0);
	}

	return 0.0;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	//if(this->teacherName==t->name)
	//	return true;
	//return false;
	return true;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxTwoConsecutiveAfternoons::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers must begin afternoons early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must begin the afternoons early, respecting maximum %1 later beginnings, at second hour")
	 .arg(this->maxBeginningsAtSecondHour);s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of teachers begin as early as possible the afternoons

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	for(int i=0; i<r.nInternalTeachers; i++){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==0)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(teachersMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
						if(teachersMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint teachers afternoons early max %1 beginnings at second hour broken for teacher %2, on day %3,"
					 " because the teacher has an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities){
					assert(0);
				}
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint teachers afternoons early max %1 beginnings at second hour broken for teacher %2,"
				 " because the teacher has too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalTeachersList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities){
				assert(0);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersAfternoonsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH, const QString& teacher)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->teacherName=teacher;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);

	return true;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Teacher must begin afternoons early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";

	s+=tr("A teacher must begin his afternoons early, respecting a maximum number of later beginnings, at second hour"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";
	s+=tr("Maximum number of beginnings at the second hour=%1").arg(this->maxBeginningsAtSecondHour);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	if(true){
		int i=teacherIndex;

		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==0)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(teachersMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
						if(teachersMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint teacher afternoons early max %1 beginnings at second hour broken for teacher %2, on day %3,"
					 " because the teacher has an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities)
					assert(0);
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint teacher afternoons early max %1 beginnings at second hour broken for teacher %2,"
				 " because the teacher has too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalTeachersList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities)
				assert(0);
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	return this->teacherName==t->name;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherAfternoonsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

//2020-06-14
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinHoursPerMorning::ConstraintStudentsMinHoursPerMorning()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_HOURS_PER_MORNING;
	this->minHoursPerMorning = -1;

	this->allowEmptyMornings=false;
}

ConstraintStudentsMinHoursPerMorning::ConstraintStudentsMinHoursPerMorning(double wp, int minnh, bool _allowEmptyMornings)
	: TimeConstraint(wp)
{
	this->minHoursPerMorning = minnh;
	this->type = CONSTRAINT_STUDENTS_MIN_HOURS_PER_MORNING;

	this->allowEmptyMornings=_allowEmptyMornings;
}

bool ConstraintStudentsMinHoursPerMorning::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMinHoursPerMorning::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinHoursPerMorning::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinHoursPerMorning>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	if(this->minHoursPerMorning>=0)
		s+=IL3+"<Minimum_Hours_Per_Morning>"+CustomFETString::number(this->minHoursPerMorning)+"</Minimum_Hours_Per_Morning>\n";
	else
		assert(0);
	if(this->allowEmptyMornings)
		s+=IL3+"<Allow_Empty_Mornings>true</Allow_Empty_Mornings>\n";
	else
		s+=IL3+"<Allow_Empty_Mornings>false</Allow_Empty_Mornings>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinHoursPerMorning>\n";
	return s;
}

QString ConstraintStudentsMinHoursPerMorning::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Students min hours per morning");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (per morning)").arg(this->minHoursPerMorning);s+=translatedCommaSpace();
	s+=tr("AEM:%1", "Allow empty mornings").arg(yesNoTranslated(this->allowEmptyMornings));

	return begin+s+end;
}

QString ConstraintStudentsMinHoursPerMorning::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum number of hours per morning");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum hours per morning=%1").arg(this->minHoursPerMorning);s+="\n";
	s+=tr("Allow empty mornings=%1").arg(yesNoTranslated(this->allowEmptyMornings));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMinHoursPerMorning::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp1/*, tmp2*/;
	int too_little;

	assert(this->minHoursPerMorning>=0);

	too_little=0;
	for(int i=0; i<r.nInternalSubgroups; i++)
		for(int j=0; j<r.nDaysPerWeek/2; j++){
			tmp1=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j][k]>=1)
					tmp1++;
			}

			if(tmp1>0 && tmp1<this->minHoursPerMorning){
				too_little += - tmp1 + this->minHoursPerMorning;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students min hours per morning broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j])
					 .arg(CustomFETString::number(tmp1))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp1+this->minHoursPerMorning)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp1+this->minHoursPerMorning));

					*conflictsString+= s+"\n";
				}
			}

			/*tmp2=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j+1][k]>=1)
					tmp2++;
			}

			if(tmp2>0 && tmp2<this->minHoursDaily){
				too_little += - tmp2 + this->minHoursDaily;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j+1])
					 .arg(CustomFETString::number(tmp2))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp2+this->minHoursDaily)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp2+this->minHoursDaily));

					*conflictsString+= s+"\n";
				}
			}*/

			if(!this->allowEmptyMornings==true)
				if(tmp1/*+tmp2*/==0){
					too_little++;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students min hours per morning broken for subgroup: %1, day: %2, empty morning, but"
						 " the constraint does not allow empty mornings, conflicts increase=%3")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j])
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(1)));

						dl.append(s);
						cl.append(weightPercentage/100*1);

						*conflictsString+= s+"\n";
					}
				}
		}

	assert(too_little>=0);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100) //does not work for partial solutions
			assert(too_little==0);

	return too_little * weightPercentage/100;
}

bool ConstraintStudentsMinHoursPerMorning::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinHoursPerMorning::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinHoursPerMorning::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinHoursPerMorning::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinHoursPerMorning::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinHoursPerMorning::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerMorning>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMinHoursPerMorning::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMinHoursPerMorning::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerMorning>r.nHoursPerDay)
		minHoursPerMorning=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinHoursPerMorning::ConstraintStudentsSetMinHoursPerMorning()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_HOURS_PER_MORNING;
	this->minHoursPerMorning = -1;

	this->allowEmptyMornings=false;
}

ConstraintStudentsSetMinHoursPerMorning::ConstraintStudentsSetMinHoursPerMorning(double wp, int minnh, const QString& s, bool _allowEmptyMornings)
	: TimeConstraint(wp)
{
	this->minHoursPerMorning = minnh;
	this->students = s;
	this->type = CONSTRAINT_STUDENTS_SET_MIN_HOURS_PER_MORNING;

	this->allowEmptyMornings=_allowEmptyMornings;
}

bool ConstraintStudentsSetMinHoursPerMorning::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinHoursPerMorning::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinHoursPerMorning>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Hours_Per_Morning>"+CustomFETString::number(this->minHoursPerMorning)+"</Minimum_Hours_Per_Morning>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	if(this->allowEmptyMornings)
		s+=IL3+"<Allow_Empty_Mornings>true</Allow_Empty_Mornings>\n";
	else
		s+=IL3+"<Allow_Empty_Mornings>false</Allow_Empty_Mornings>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinHoursPerMorning>\n";
	return s;
}

QString ConstraintStudentsSetMinHoursPerMorning::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Students set min hours per morning");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (per morning)").arg(this->minHoursPerMorning);s+=translatedCommaSpace();
	s+=tr("AEM:%1", "Allow empty mornings").arg(yesNoTranslated(this->allowEmptyMornings));

	return begin+s+end;
}

QString ConstraintStudentsSetMinHoursPerMorning::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum number of hours per morning");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Minimum hours per morning=%1").arg(this->minHoursPerMorning);s+="\n";
	s+=tr("Allow empty mornings=%1").arg(yesNoTranslated(this->allowEmptyMornings));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinHoursPerMorning::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min hours per morning is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

double ConstraintStudentsSetMinHoursPerMorning::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp1/*, tmp2*/;
	int too_little;

	assert(this->minHoursPerMorning>=0);

	too_little=0;
	for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
		int i=iSubgroupsList.at(sg);
		for(int j=0; j<r.nDaysPerWeek/2; j++){
			tmp1=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j][k]>=1)
					tmp1++;
			}

			if(tmp1>0 && tmp1<this->minHoursPerMorning){
				too_little += - tmp1 + this->minHoursPerMorning;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students set min hours per morning broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j])
					 .arg(CustomFETString::number(tmp1))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp1+this->minHoursPerMorning)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp1+this->minHoursPerMorning));

					*conflictsString+= s+"\n";
				}
			}

			/*tmp2=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j+1][k]>=1)
					tmp2++;
			}

			if(tmp2>0 && tmp2<this->minHoursDaily){
				too_little += - tmp2 + this->minHoursDaily;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students set min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j+1])
					 .arg(CustomFETString::number(tmp2))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp2+this->minHoursDaily)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp2+this->minHoursDaily));

					*conflictsString+= s+"\n";
				}
			}*/

			if(!this->allowEmptyMornings==true)
				if(tmp1/*+tmp2*/==0){
					too_little++;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set min hours per morning broken for subgroup: %1, day: %2, empty morning, but"
						 " the constraint does not allow empty mornings, conflicts increase=%3")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j])
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(1)));

						dl.append(s);
						cl.append(weightPercentage/100*1);

						*conflictsString+= s+"\n";
					}
				}
		}
	}

	assert(too_little>=0);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100) //does not work for partial solutions
			assert(too_little==0);

	return too_little * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinHoursPerMorning::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinHoursPerMorning::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinHoursPerMorning::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinHoursPerMorning::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinHoursPerMorning::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinHoursPerMorning::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerMorning>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMinHoursPerMorning::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMinHoursPerMorning::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerMorning>r.nHoursPerDay)
		minHoursPerMorning=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxZeroGapsPerAfternoon::ConstraintTeacherMaxZeroGapsPerAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MAX_ZERO_GAPS_PER_AFTERNOON;
}

ConstraintTeacherMaxZeroGapsPerAfternoon::ConstraintTeacherMaxZeroGapsPerAfternoon(double wp, const QString& tn)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MAX_ZERO_GAPS_PER_AFTERNOON;
	this->teacherName=tn;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacherIndex=r.searchTeacher(this->teacherName);
	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);
	return true;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxZeroGapsPerAfternoon::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxZeroGapsPerAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxZeroGapsPerAfternoon>\n";
	return s;
}

QString ConstraintTeacherMaxZeroGapsPerAfternoon::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher max zero gaps per afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeacherMaxZeroGapsPerAfternoon::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("A teacher must respect a number of zero gaps per afternoon"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxZeroGapsPerAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;

	i=this->teacherIndex;

	for(j=0; j<r.nDaysPerWeek; j++){
		if(j%2==0)
			continue;
		tg=0;
		for(k=0; k<r.nHoursPerDay; k++)
			if(teachersMatrix[i][j][k]>0){
				assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
				break;
			}

		int cnt=0;
		for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
			if(teachersMatrix[i][j][k]>0){
				tg+=cnt;
				cnt=0;
			}
			else
				cnt++;
		}
		if(tg>0){
			totalGaps+=tg;
			//assert(this->weightPercentage<100); partial solutions might break this rule
			if(conflictsString!=nullptr){
				QString s=tr("Time constraint teacher max zero gaps per afternoon broken for teacher: %1, day: %2, conflicts factor increase=%3")
					.arg(r.internalTeachersList[i]->name)
					.arg(r.daysOfTheWeek[j])
					.arg(CustomFETString::numberPlusTwoDigitsPrecision(tg*weightPercentage/100));

				*conflictsString+= s+"\n";

				dl.append(s);
				cl.append(tg*weightPercentage/100);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxZeroGapsPerAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxZeroGapsPerAfternoon::ConstraintTeachersMaxZeroGapsPerAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MAX_ZERO_GAPS_PER_AFTERNOON;
}

ConstraintTeachersMaxZeroGapsPerAfternoon::ConstraintTeachersMaxZeroGapsPerAfternoon(double wp)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MAX_ZERO_GAPS_PER_AFTERNOON;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxZeroGapsPerAfternoon::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxZeroGapsPerAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxZeroGapsPerAfternoon>\n";
	return s;
}

QString ConstraintTeachersMaxZeroGapsPerAfternoon::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers max zero gaps per afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersMaxZeroGapsPerAfternoon::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("All teachers must respect a number of zero gaps per afternoon"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxZeroGapsPerAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tg;
	int i, j, k;
	int totalGaps;

	totalGaps=0;

	for(i=0; i<r.nInternalTeachers; i++){
		for(j=0; j<r.nDaysPerWeek; j++){
			if(j%2==0)
				continue;
			tg=0;
			for(k=0; k<r.nHoursPerDay; k++)
				if(teachersMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
					break;
				}

			int cnt=0;
			for(; k<r.nHoursPerDay; k++) if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
				if(teachersMatrix[i][j][k]>0){
					tg+=cnt;
					cnt=0;
				}
				else
					cnt++;
			}
			if(tg>0){
				totalGaps+=tg;
				//assert(this->weightPercentage<100); partial solutions might break this rule
				if(conflictsString!=nullptr){
					QString s=tr("Time constraint teachers max zero gaps per afternoon broken for teacher: %1, day: %2, conflicts factor increase=%3")
						.arg(r.internalTeachersList[i]->name)
						.arg(r.daysOfTheWeek[j])
						.arg(CustomFETString::numberPlusTwoDigitsPrecision(tg*weightPercentage/100));

					*conflictsString+= s+"\n";

					dl.append(s);
					cl.append(tg*weightPercentage/100);
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalGaps;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxZeroGapsPerAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

//2020-06-25
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxAfternoonsPerWeek::ConstraintStudentsSetMaxAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_AFTERNOONS_PER_WEEK;
}

ConstraintStudentsSetMaxAfternoonsPerWeek::ConstraintStudentsSetMaxAfternoonsPerWeek(double wp, int maxnd, const QString& sn)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->maxAfternoonsPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_AFTERNOONS_PER_WEEK;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max afternoons per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxAfternoonsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Max_Afternoons_Per_Week>"+CustomFETString::number(this->maxAfternoonsPerWeek)+"</Max_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMaxAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set max afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MA:%1", "Abbreviation for max afternoons").arg(this->maxAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("Maximum afternoons per week=%1").arg(this->maxAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;*/
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays > this->maxAfternoonsPerWeek){
			nbroken+=nOcDays-this->maxAfternoonsPerWeek;

			if((nOcDays-this->maxAfternoonsPerWeek)>0){
				QString s= tr("Time constraint students set max afternoons per week broken for subgroup: %1, allowed %2 afternoons, required %3 afternoons.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxAfternoonsPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxAfternoonsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxAfternoonsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		this->maxAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxAfternoonsPerWeek::ConstraintStudentsMaxAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_AFTERNOONS_PER_WEEK;
}

ConstraintStudentsMaxAfternoonsPerWeek::ConstraintStudentsMaxAfternoonsPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxAfternoonsPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_MAX_AFTERNOONS_PER_WEEK;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxAfternoonsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Afternoons_Per_Week>"+CustomFETString::number(this->maxAfternoonsPerWeek)+"</Max_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintStudentsMaxAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students max afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MA:%1", "Abbreviation for max afternoons").arg(this->maxAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsMaxAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum afternoons per week=%1").arg(this->maxAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;*/
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays > this->maxAfternoonsPerWeek){
			nbroken+=nOcDays-this->maxAfternoonsPerWeek;

			if((nOcDays-this->maxAfternoonsPerWeek)>0){
				QString s= tr("Time constraint students max afternoons per week broken for subgroup: %1, allowed %2 afternoons, required %3 afternoons.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxAfternoonsPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxAfternoonsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxAfternoonsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxAfternoonsPerWeek>r.nDaysPerWeek/2)
		this->maxAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxMorningsPerWeek::ConstraintStudentsSetMaxMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_MORNINGS_PER_WEEK;
}

ConstraintStudentsSetMaxMorningsPerWeek::ConstraintStudentsSetMaxMorningsPerWeek(double wp, int maxnd, const QString& sn)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->maxMorningsPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_MORNINGS_PER_WEEK;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max mornings per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxMorningsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Max_Mornings_Per_Week>"+CustomFETString::number(this->maxMorningsPerWeek)+"</Max_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxMorningsPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMaxMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set max mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MM:%1", "Abbreviation for max mornings").arg(this->maxMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("Maximum mornings per week=%1").arg(this->maxMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;*/
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays > this->maxMorningsPerWeek){
			nbroken+=nOcDays-this->maxMorningsPerWeek;

			if((nOcDays-this->maxMorningsPerWeek)>0){
				QString s= tr("Time constraint students set max mornings per week broken for subgroup: %1, allowed %2 mornings, required %3 mornings.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxMorningsPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxMorningsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxMorningsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxMorningsPerWeek>r.nDaysPerWeek/2)
		this->maxMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxMorningsPerWeek::ConstraintStudentsMaxMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_MORNINGS_PER_WEEK;
}

ConstraintStudentsMaxMorningsPerWeek::ConstraintStudentsMaxMorningsPerWeek(double wp, int maxnd)
	 : TimeConstraint(wp)
{
	this->maxMorningsPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_MAX_MORNINGS_PER_WEEK;
}

bool ConstraintStudentsMaxMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxMorningsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Mornings_Per_Week>"+CustomFETString::number(this->maxMorningsPerWeek)+"</Max_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxMorningsPerWeek>\n";
	return s;
}

QString ConstraintStudentsMaxMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students max mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MM:%1", "Abbreviation for max mornings").arg(this->maxMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsMaxMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum mornings per week=%1").arg(this->maxMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;*/
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays > this->maxMorningsPerWeek){
			nbroken+=nOcDays-this->maxMorningsPerWeek;

			if((nOcDays-this->maxMorningsPerWeek)>0){
				QString s= tr("Time constraint students max mornings per week broken for subgroup: %1, allowed %2 mornings, required %3 mornings.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxMorningsPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxMorningsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxMorningsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsMaxMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->maxMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsMaxMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxMorningsPerWeek>r.nDaysPerWeek/2)
		this->maxMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

//2020-06-26
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinAfternoonsPerWeek::ConstraintStudentsSetMinAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MIN_AFTERNOONS_PER_WEEK;
}

ConstraintStudentsSetMinAfternoonsPerWeek::ConstraintStudentsSetMinAfternoonsPerWeek(double wp, int minnd, const QString& sn)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->minAfternoonsPerWeek=minnd;
	this->type=CONSTRAINT_STUDENTS_SET_MIN_AFTERNOONS_PER_WEEK;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min afternoons per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinAfternoonsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Min_Afternoons_Per_Week>"+CustomFETString::number(this->minAfternoonsPerWeek)+"</Min_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMinAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set min afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("mA:%1", "Abbreviation for min afternoons").arg(this->minAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetMinAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("Minimum afternoons per week=%1").arg(this->minAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMinAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;*/
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays < this->minAfternoonsPerWeek){
			nbroken+=-nOcDays+this->minAfternoonsPerWeek;

			if((-nOcDays+this->minAfternoonsPerWeek)>0){
				QString s= tr("Time constraint students set min %1 afternoons per week broken for subgroup: %2.")
				 .arg(this->minAfternoonsPerWeek)
				 .arg(r.internalSubgroupsList[sbg]->name);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((-nOcDays+this->minAfternoonsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((-nOcDays+this->minAfternoonsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->minAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMinAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->minAfternoonsPerWeek>r.nDaysPerWeek/2)
		this->minAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinAfternoonsPerWeek::ConstraintStudentsMinAfternoonsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MIN_AFTERNOONS_PER_WEEK;
}

ConstraintStudentsMinAfternoonsPerWeek::ConstraintStudentsMinAfternoonsPerWeek(double wp, int minnd)
	 : TimeConstraint(wp)
{
	this->minAfternoonsPerWeek=minnd;
	this->type=CONSTRAINT_STUDENTS_MIN_AFTERNOONS_PER_WEEK;
}

bool ConstraintStudentsMinAfternoonsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMinAfternoonsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinAfternoonsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinAfternoonsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Min_Afternoons_Per_Week>"+CustomFETString::number(this->minAfternoonsPerWeek)+"</Min_Afternoons_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinAfternoonsPerWeek>\n";
	return s;
}

QString ConstraintStudentsMinAfternoonsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students min afternoons per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mA:%1", "Abbreviation for min afternoons").arg(this->minAfternoonsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsMinAfternoonsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum number of afternoons per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Minimum afternoons per week=%1").arg(this->minAfternoonsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMinAfternoonsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;*/
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays < this->minAfternoonsPerWeek){
			nbroken+=-nOcDays+this->minAfternoonsPerWeek;

			if((-nOcDays+this->minAfternoonsPerWeek)>0){
				QString s= tr("Time constraint students min %1 afternoons per week broken for subgroup: %2.")
				 .arg(this->minAfternoonsPerWeek)
				 .arg(r.internalSubgroupsList[sbg]->name);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((-nOcDays+this->minAfternoonsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((-nOcDays+this->minAfternoonsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMinAfternoonsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinAfternoonsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsMinAfternoonsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinAfternoonsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinAfternoonsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinAfternoonsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->minAfternoonsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsMinAfternoonsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMinAfternoonsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->minAfternoonsPerWeek>r.nDaysPerWeek/2)
		this->minAfternoonsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinMorningsPerWeek::ConstraintStudentsSetMinMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MIN_MORNINGS_PER_WEEK;
}

ConstraintStudentsSetMinMorningsPerWeek::ConstraintStudentsSetMinMorningsPerWeek(double wp, int minnd, const QString& sn)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->minMorningsPerWeek=minnd;
	this->type=CONSTRAINT_STUDENTS_SET_MIN_MORNINGS_PER_WEEK;
}

bool ConstraintStudentsSetMinMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min mornings per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMinMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinMorningsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Min_Mornings_Per_Week>"+CustomFETString::number(this->minMorningsPerWeek)+"</Min_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinMorningsPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMinMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set min mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("mM:%1", "Abbreviation for min mornings").arg(this->minMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetMinMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("Minimum mornings per week=%1").arg(this->minMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMinMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;*/
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays < this->minMorningsPerWeek){
			nbroken+=-nOcDays+this->minMorningsPerWeek;

			if((-nOcDays+this->minMorningsPerWeek)>0){
				QString s= tr("Time constraint students set min %1 mornings per week broken for subgroup: %2.")
				 .arg(this->minMorningsPerWeek)
				 .arg(r.internalSubgroupsList[sbg]->name);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((-nOcDays+this->minMorningsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((-nOcDays+this->minMorningsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMinMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetMinMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->minMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMinMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMinMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->minMorningsPerWeek>r.nDaysPerWeek/2)
		this->minMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinMorningsPerWeek::ConstraintStudentsMinMorningsPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MIN_MORNINGS_PER_WEEK;
}

ConstraintStudentsMinMorningsPerWeek::ConstraintStudentsMinMorningsPerWeek(double wp, int minnd)
	 : TimeConstraint(wp)
{
	this->minMorningsPerWeek=minnd;
	this->type=CONSTRAINT_STUDENTS_MIN_MORNINGS_PER_WEEK;
}

bool ConstraintStudentsMinMorningsPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMinMorningsPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinMorningsPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinMorningsPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Min_Mornings_Per_Week>"+CustomFETString::number(this->minMorningsPerWeek)+"</Min_Mornings_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinMorningsPerWeek>\n";
	return s;
}

QString ConstraintStudentsMinMorningsPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students min mornings per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mM:%1", "Abbreviation for min mornings").arg(this->minMorningsPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsMinMorningsPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum number of mornings per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Minimum mornings per week=%1").arg(this->minMorningsPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMinMorningsPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		/*bool ocDay[MAX_DAYS_PER_WEEK];
		for(int d=0; d<r.nDaysPerWeek; d++){
			ocDay[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}*/
		int nOcDays=0;
		/*for(int d=0; d<r.nDaysPerWeek; d++)
			if(ocDay[d])
				nOcDays++;*/
		for(int d=0; d<r.nDaysPerWeek/2; d++){
			int nh=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d][h]>=1 ? 1 : 0;
			/*for(int h=0; h<r.nHoursPerDay; h++)
				nh += subgroupsMatrix[sbg][2*d+1][h]>=1 ? 1 : 0;*/
			if(nh>0)
				nOcDays++;
		}
		if(nOcDays < this->minMorningsPerWeek){
			nbroken+=-nOcDays+this->minMorningsPerWeek;

			if((-nOcDays+this->minMorningsPerWeek)>0){
				QString s= tr("Time constraint students min %1 mornings per week broken for subgroup: %2.")
				 .arg(this->minMorningsPerWeek)
				 .arg(r.internalSubgroupsList[sbg]->name);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((-nOcDays+this->minMorningsPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((-nOcDays+this->minMorningsPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMinMorningsPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinMorningsPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsMinMorningsPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinMorningsPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinMorningsPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinMorningsPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->minMorningsPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsMinMorningsPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMinMorningsPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->minMorningsPerWeek>r.nDaysPerWeek/2)
		this->minMorningsPerWeek=r.nDaysPerWeek/2;

	return true;
}

//2020-06-26
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::ConstraintStudentsSetMorningIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::ConstraintStudentsSetMorningIntervalMaxDaysPerWeek(double wp, int maxnd, const QString& sn, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_SET_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set morning interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set morning interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set morning interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	/////////
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set morning interval max days per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMorningIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMorningIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set morning interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set respects working in an hourly morning interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<r.nDaysPerWeek; d+=2){ //morning
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2) //morning
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students set morning interval max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMorningIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMorningIntervalMaxDaysPerWeek::ConstraintStudentsMorningIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsMorningIntervalMaxDaysPerWeek::ConstraintStudentsMorningIntervalMaxDaysPerWeek(double wp, int maxnd, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_MORNING_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students morning interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students morning interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students morning interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	return true;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMorningIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMorningIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMorningIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsMorningIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students morning interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsMorningIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students respect working in an hourly morning interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMorningIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<r.nDaysPerWeek; d+=2){ //morning
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=0; d<r.nDaysPerWeek; d+=2) //morning
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students morning interval max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	return true;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMorningIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek(double wp, int maxnd, const QString& sn, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_SET_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set afternoon interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set afternoon interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set afternoon interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	/////////
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set afternoon interval max days per week is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set afternoon interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Abbreviation for students (sets)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set respects working in an hourly afternoon interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=1; d<r.nDaysPerWeek; d+=2){ //afternoon
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students set afternoon interval max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetAfternoonIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::ConstraintStudentsAfternoonIntervalMaxDaysPerWeek()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
}

ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::ConstraintStudentsAfternoonIntervalMaxDaysPerWeek(double wp, int maxnd, int sh, int eh)
	 : TimeConstraint(wp)
{
	this->maxDaysPerWeek=maxnd;
	this->type=CONSTRAINT_STUDENTS_AFTERNOON_INTERVAL_MAX_DAYS_PER_WEEK;
	this->startHour=sh;
	this->endHour=eh;
	assert(sh<eh);
	assert(sh>=0);
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->startHour>=this->endHour){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students afternoon interval max days per week is wrong because start hour >= end hour."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->startHour<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students afternoon interval max days per week is wrong because start hour < first hour of the day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}
	if(this->endHour>r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students afternoon interval max days per week is wrong because end hour > number of hours per day."
		 " Please correct it. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	return true;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsAfternoonIntervalMaxDaysPerWeek>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}
	s+=IL3+"<Max_Days_Per_Week>"+CustomFETString::number(this->maxDaysPerWeek)+"</Max_Days_Per_Week>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsAfternoonIntervalMaxDaysPerWeek>\n";
	return s;
}

QString ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students afternoon interval max days per week");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Abbreviation for weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("ISH:%1", "Abbreviation for interval start hour").arg(r.hoursOfTheDay[this->startHour]);
	s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour").arg(tr("End of the day"));
	s+=translatedCommaSpace();
	s+=tr("MD:%1", "Abbreviation for max days").arg(this->maxDaysPerWeek);

	return begin+s+end;
}

QString ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students respect working in an hourly afternoon interval a maximum number of days per week");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";

	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum days per week=%1").arg(this->maxDaysPerWeek);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	nbroken=0;

	Matrix1D<bool> ocDay;
	ocDay.resize(r.nDaysPerWeek);
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=1; d<r.nDaysPerWeek; d+=2){ //afternoon
			ocDay[d]=false;
			for(int h=startHour; h<endHour; h++){
				if(subgroupsMatrix[sbg][d][h]>0){
					ocDay[d]=true;
				}
			}
		}
		int nOcDays=0;
		for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
			if(ocDay[d])
				nOcDays++;
		if(nOcDays > this->maxDaysPerWeek){
			nbroken+=nOcDays-this->maxDaysPerWeek;

			if((nOcDays-this->maxDaysPerWeek)>0){
				QString s= tr("Time constraint students afternoon interval max days per week broken for subgroup: %1, allowed %2 days, required %3 days.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(this->maxDaysPerWeek)
				 .arg(nOcDays);
				s+=" ";
				s += tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nOcDays-this->maxDaysPerWeek)*weightPercentage/100));

				dl.append(s);
				cl.append((nOcDays-this->maxDaysPerWeek)*weightPercentage/100);

				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	return false;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	return true;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::hasWrongDayOrHour(Rules& r)
{
	if(this->startHour>=r.nHoursPerDay)
		return true;
	if(this->endHour>r.nHoursPerDay)
		return true;
	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsAfternoonIntervalMaxDaysPerWeek::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(this->startHour<r.nHoursPerDay && this->endHour<=r.nHoursPerDay);

	if(this->maxDaysPerWeek>r.nDaysPerWeek/2)
		this->maxDaysPerWeek=r.nDaysPerWeek/2;

	return true;
}

//2020-06-28
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxHoursPerAllAfternoons::ConstraintTeacherMaxHoursPerAllAfternoons()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_HOURS_PER_ALL_AFTERNOONS;
}

ConstraintTeacherMaxHoursPerAllAfternoons::ConstraintTeacherMaxHoursPerAllAfternoons(double wp, int maxhours, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursPerAllAfternoons=maxhours;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MAX_HOURS_PER_ALL_AFTERNOONS;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	return true;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxHoursPerAllAfternoons::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxHoursPerAllAfternoons>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Maximum_Hours_Per_All_Afternoons>"+CustomFETString::number(this->maxHoursPerAllAfternoons)+"</Maximum_Hours_Per_All_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxHoursPerAllAfternoons>\n";
	return s;
}

QString ConstraintTeacherMaxHoursPerAllAfternoons::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher max hours per all afternoons");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MHAA:%1", "Maximum hours per all afternoons").arg(this->maxHoursPerAllAfternoons);

	return begin+s+end;
}

QString ConstraintTeacherMaxHoursPerAllAfternoons::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of hours per all afternoons");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum hours per all afternoons=%1").arg(this->maxHoursPerAllAfternoons);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxHoursPerAllAfternoons::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	int i=this->teacher_ID;
	int n_hours=0;
	for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
		for(int h=0; h<r.nHoursPerDay; h++)
			if(teachersMatrix[i][d][h]>0)
				n_hours++;

	if(n_hours>this->maxHoursPerAllAfternoons)
		nbroken++;

	assert(weightPercentage==100);
	if(weightPercentage==100)
		assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		return true;

	return false;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxHoursPerAllAfternoons::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		maxHoursPerAllAfternoons=r.nDaysPerWeek*r.nHoursPerDay/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxHoursPerAllAfternoons::ConstraintTeachersMaxHoursPerAllAfternoons()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_PER_ALL_AFTERNOONS;
}

ConstraintTeachersMaxHoursPerAllAfternoons::ConstraintTeachersMaxHoursPerAllAfternoons(double wp, int maxhours)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursPerAllAfternoons=maxhours;

	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_PER_ALL_AFTERNOONS;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxHoursPerAllAfternoons::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxHoursPerAllAfternoons>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Per_All_Afternoons>"+CustomFETString::number(this->maxHoursPerAllAfternoons)+"</Maximum_Hours_Per_All_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxHoursPerAllAfternoons>\n";
	return s;
}

QString ConstraintTeachersMaxHoursPerAllAfternoons::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers max hours per all afternoons");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MHAA:%1", "Maximum hours per all afternoons").arg(this->maxHoursPerAllAfternoons);

	return begin+s+end;
}

QString ConstraintTeachersMaxHoursPerAllAfternoons::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of hours per all afternoons");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours per all afternoons=%1").arg(this->maxHoursPerAllAfternoons);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxHoursPerAllAfternoons::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i=0; i<r.nInternalTeachers; i++){
		int n_hours=0;
		for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours++;

		if(n_hours>this->maxHoursPerAllAfternoons)
			nbroken++;
	}

	assert(weightPercentage==100);
	if(weightPercentage==100)
		assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		return true;

	return false;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxHoursPerAllAfternoons::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		maxHoursPerAllAfternoons=r.nDaysPerWeek*r.nHoursPerDay/2;

	return true;
}

//2020-06-28
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxHoursPerAllAfternoons::ConstraintStudentsSetMaxHoursPerAllAfternoons()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_HOURS_PER_ALL_AFTERNOONS;
}

ConstraintStudentsSetMaxHoursPerAllAfternoons::ConstraintStudentsSetMaxHoursPerAllAfternoons(double wp, int maxhours, const QString& st)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursPerAllAfternoons=maxhours;
	this->students=st;

	this->type=CONSTRAINT_STUDENTS_SET_MAX_HOURS_PER_ALL_AFTERNOONS;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours per all afternoons is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxHoursPerAllAfternoons::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxHoursPerAllAfternoons>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Maximum_Hours_Per_All_Afternoons>"+CustomFETString::number(this->maxHoursPerAllAfternoons)+"</Maximum_Hours_Per_All_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxHoursPerAllAfternoons>\n";
	return s;
}

QString ConstraintStudentsSetMaxHoursPerAllAfternoons::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students set max hours per all afternoons");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MHAA:%1", "Maximum hours per all afternoons").arg(this->maxHoursPerAllAfternoons);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxHoursPerAllAfternoons::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of hours per all afternoons");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students=%1").arg(this->students);s+="\n";
	s+=tr("Maximum hours per all afternoons=%1").arg(this->maxHoursPerAllAfternoons);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxHoursPerAllAfternoons::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i : std::as_const(this->iSubgroupsList)){
		int n_hours=0;
		for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(subgroupsMatrix[i][d][h]>0)
					n_hours++;

		if(n_hours>this->maxHoursPerAllAfternoons)
			nbroken++;
	}

	assert(weightPercentage==100);
	if(weightPercentage==100)
		assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxHoursPerAllAfternoons::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		maxHoursPerAllAfternoons=r.nDaysPerWeek*r.nHoursPerDay/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxHoursPerAllAfternoons::ConstraintStudentsMaxHoursPerAllAfternoons()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_HOURS_PER_ALL_AFTERNOONS;
}

ConstraintStudentsMaxHoursPerAllAfternoons::ConstraintStudentsMaxHoursPerAllAfternoons(double wp, int maxhours)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursPerAllAfternoons=maxhours;

	this->type=CONSTRAINT_STUDENTS_MAX_HOURS_PER_ALL_AFTERNOONS;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxHoursPerAllAfternoons::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxHoursPerAllAfternoons>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Maximum_Hours_Per_All_Afternoons>"+CustomFETString::number(this->maxHoursPerAllAfternoons)+"</Maximum_Hours_Per_All_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxHoursPerAllAfternoons>\n";
	return s;
}

QString ConstraintStudentsMaxHoursPerAllAfternoons::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students max hours per all afternoons");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MHAA:%1", "Maximum hours per all afternoons").arg(this->maxHoursPerAllAfternoons);

	return begin+s+end;
}

QString ConstraintStudentsMaxHoursPerAllAfternoons::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of hours per all afternoons");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours per all afternoons=%1").arg(this->maxHoursPerAllAfternoons);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxHoursPerAllAfternoons::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i=0; i<r.nInternalSubgroups; i++){
		int n_hours=0;
		for(int d=1; d<r.nDaysPerWeek; d+=2) //afternoon
			for(int h=0; h<r.nHoursPerDay; h++)
				if(subgroupsMatrix[i][d][h]>0)
					n_hours++;

		if(n_hours>this->maxHoursPerAllAfternoons)
			nbroken++;
	}

	assert(weightPercentage==100);
	if(weightPercentage==100)
		assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		return true;

	return false;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxHoursPerAllAfternoons::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxHoursPerAllAfternoons>r.nDaysPerWeek*r.nHoursPerDay/2)
		maxHoursPerAllAfternoons=r.nDaysPerWeek*r.nHoursPerDay/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
	this->minRestingHours=-1;
}

ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon(double wp, int minrestinghours, const QString& teacher)
 : TimeConstraint(wp)
 {
	assert(minrestinghours>0);
	this->minRestingHours=minrestinghours;
	this->teacherName=teacher;

	this->type=CONSTRAINT_TEACHER_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher min resting hours between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);

	return begin+s+end;
}

QString ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum resting hours (between morning and afternoon)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	for(int d=0; d<r.nDaysPerWeek; d+=2){ //morning
		int cnt=0;
		for(int h=r.nHoursPerDay-1; h>=0; h--){
			if(teachersMatrix[this->teacher_ID][d][h]>0) //morning
				break;
			else
				cnt++;
		}
		for(int h=0; h<r.nHoursPerDay; h++){
			if(teachersMatrix[this->teacher_ID][d+1][h]>0) //afternoon
				break;
			else
				cnt++;
		}
		if(cnt < this->minRestingHours)
			nbroken++;
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMinRestingHoursBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minRestingHours>2*r.nHoursPerDay)
		minRestingHours=2*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
	this->minRestingHours=-1;
}

ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon(double wp, int minrestinghours)
 : TimeConstraint(wp)
 {
	assert(minrestinghours>0);
	this->minRestingHours=minrestinghours;

	this->type=CONSTRAINT_TEACHERS_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers min resting hours between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);

	return begin+s+end;
}

QString ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum resting hours (between morning and afternoon)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	for(int tch=0; tch<r.nInternalTeachers; tch++){
		for(int d=0; d<r.nDaysPerWeek; d+=2){ //morning
			int cnt=0;
			for(int h=r.nHoursPerDay-1; h>=0; h--){
				if(teachersMatrix[tch][d][h]>0) //morning
					break;
				else
					cnt++;
			}
			for(int h=0; h<r.nHoursPerDay; h++){
				if(teachersMatrix[tch][d+1][h]>0) //afternoon
					break;
				else
					cnt++;
			}
			if(cnt < this->minRestingHours)
				nbroken++;
		}
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMinRestingHoursBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minRestingHours>2*r.nHoursPerDay)
		minRestingHours=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
	this->minRestingHours = -1;
}

ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon(double wp, int minrestinghours, const QString& sn)
	: TimeConstraint(wp)
{
	this->minRestingHours = minrestinghours;
	this->students = sn;
	this->type = CONSTRAINT_STUDENTS_SET_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students set min resting hours between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students); s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);

	return begin+s+end;
}

QString ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum resting hours (between morning and afternoon)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min resting hours between morning and afternoon is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

double ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		for(int d=0; d<r.nDaysPerWeek; d+=2){ //morning
			int cnt=0;
			for(int h=r.nHoursPerDay-1; h>=0; h--){
				if(subgroupsMatrix[sbg][d][h]>0) //morning
					break;
				else
					cnt++;
			}
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d+1][h]>0) //afternoon
					break;
				else
					cnt++;
			}
			if(cnt < this->minRestingHours)
				nbroken++;
		}
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMinRestingHoursBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minRestingHours>2*r.nHoursPerDay)
		minRestingHours=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
	this->minRestingHours = -1;
}

ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon(double wp, int minrestinghours)
	: TimeConstraint(wp)
{
	this->minRestingHours = minrestinghours;
	this->type = CONSTRAINT_STUDENTS_MIN_RESTING_HOURS_BETWEEN_MORNING_AND_AFTERNOON;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Resting_Hours>"+CustomFETString::number(this->minRestingHours)+"</Minimum_Resting_Hours>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon>\n";
	return s;
}

QString ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students min resting hours between morning and afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mRH:%1", "Minimum resting hours").arg(this->minRestingHours);

	return begin+s+end;
}

QString ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum resting hours (between morning and afternoon)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum resting hours=%1").arg(this->minRestingHours);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

double ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	assert(this->weightPercentage==100.0);

	int nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<r.nDaysPerWeek; d+=2){ //morning
			int cnt=0;
			for(int h=r.nHoursPerDay-1; h>=0; h--){
				if(subgroupsMatrix[sbg][d][h]>0) //morning
					break;
				else
					cnt++;
			}
			for(int h=0; h<r.nHoursPerDay; h++){
				if(subgroupsMatrix[sbg][d+1][h]>0) //afternoon
					break;
				else
					cnt++;
			}
			if(cnt < this->minRestingHours)
				nbroken++;
		}
	}

	assert(nbroken==0);

	return nbroken;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minRestingHours>2*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMinRestingHoursBetweenMorningAndAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minRestingHours>2*r.nHoursPerDay)
		minRestingHours=2*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students must begin afternoons early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must begin the afternoons early, respecting maximum %1 later beginnings, at second hour")
	 .arg(this->maxBeginningsAtSecondHour);s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	for(int i=0; i<r.nInternalSubgroups; i++){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==0)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(subgroupsMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
						if(subgroupsMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint students afternoons early max %1 beginnings at second hour broken for subgroup %2, on day %3,"
					 " because students have an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities){
					assert(0);
				}
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint students afternoons early max %1 beginnings at second hour broken for subgroup %2,"
				 " because students have too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities){
				assert(0);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsAfternoonsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH, const QString& students)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_AFTERNOONS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->students=students;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set afternoons early is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
	return true;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Students set must begin the afternoons early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students set").arg(this->students);

	return begin+s+end;
}

QString ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";

	s+=tr("A students set must begin the afternoons early, respecting a maximum number of later beginnings, at second hour"); s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students); s+="\n";
	s+=tr("Maximum number of beginnings at the second hour=%1").arg(this->maxBeginningsAtSecondHour);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	for(int i : std::as_const(this->iSubgroupsList)){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==0)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(subgroupsMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
						if(subgroupsMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint students set afternoons early max %1 beginnings at second hour broken for subgroup %2, on day %3,"
					 " because students have an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities)
					assert(0);
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint students set afternoons early max %1 beginnings at second hour broken for subgroup %2,"
				 " because students have too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities)
				assert(0);
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetAfternoonsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

//2020-07-29
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxGapsPerWeekForRealDays::ConstraintTeachersMaxGapsPerWeekForRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
	this->maxGaps=-1;
}

ConstraintTeachersMaxGapsPerWeekForRealDays::ConstraintTeachersMaxGapsPerWeekForRealDays(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
	this->maxGaps=mg;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxGapsPerWeekForRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxGapsPerWeekForRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxGapsPerWeekForRealDays>\n";
	return s;
}

QString ConstraintTeachersMaxGapsPerWeekForRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers max gaps per week for real days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week for real days)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeachersMaxGapsPerWeekForRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum gaps per week for real days");s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per week for real days=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxGapsPerWeekForRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tg;
	int i, j, k;

	int real_d, double_h;

	int totalExtraGaps=0;

	for(i=0; i<r.nInternalTeachers; i++){
		tg=0;
		for(real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
			for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(teachersMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
					break;
				}
			}

			int cnt=0;
			for(; double_h<2*r.nHoursPerDay; double_h++){
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
					if(teachersMatrix[i][j][k]>0){
						tg+=cnt;
						cnt=0;
					}
					else{
						cnt++;
					}
				}
			}
		}
		if(tg>this->maxGaps){
			//assert(this->weightPercentage<100); partial solutions might break this rule

			if(conflictsString!=nullptr){
				QString s=tr("Time constraint teachers max gaps per week for real days broken for teacher %1, conflicts factor increase=%2")
					.arg(r.internalTeachersList[i]->name)
					.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));

				*conflictsString+= s+"\n";

				dl.append(s);
				cl.append((tg-maxGaps)*weightPercentage/100);
			}

			totalExtraGaps+=tg-maxGaps;
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalExtraGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalExtraGaps;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxGapsPerWeekForRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxGapsPerWeekForRealDays::ConstraintTeacherMaxGapsPerWeekForRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
	this->maxGaps = -1;
}

ConstraintTeacherMaxGapsPerWeekForRealDays::ConstraintTeacherMaxGapsPerWeekForRealDays(double wp, const QString& tn, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
	this->teacherName=tn;
	this->maxGaps=mg;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacherIndex=r.searchTeacher(this->teacherName);
	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);
	return true;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxGapsPerWeekForRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxGapsPerWeekForRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxGapsPerWeekForRealDays>\n";
	return s;
}

QString ConstraintTeacherMaxGapsPerWeekForRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher max gaps per week for real days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week for real days)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintTeacherMaxGapsPerWeekForRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("A teacher must respect the maximum number of gaps per week for real days"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";
	s+=tr("Maximum gaps per week for real days=%1").arg(this->maxGaps); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxGapsPerWeekForRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tg;
	int i, j, k;

	i=this->teacherIndex;

	int real_d, double_h;

	int totalExtraGaps=0;

	tg=0;
	for(real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
		for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
			if(double_h<r.nHoursPerDay)
				j=2*real_d;
			else
				j=2*real_d+1;
			k=double_h%r.nHoursPerDay;
			if(teachersMatrix[i][j][k]>0){
				assert(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]);
				break;
			}
		}

		int cnt=0;
		for(; double_h<2*r.nHoursPerDay; double_h++){
			if(double_h<r.nHoursPerDay)
				j=2*real_d;
			else
				j=2*real_d+1;
			k=double_h%r.nHoursPerDay;
			if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
				if(teachersMatrix[i][j][k]>0){
					tg+=cnt;
					cnt=0;
				}
				else
					cnt++;
			}
		}
	}
	if(tg>this->maxGaps){
		//assert(this->weightPercentage<100); partial solutions might break this rule
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint teacher max gaps per week for real days broken for teacher: %1, conflicts factor increase=%2")
				.arg(r.internalTeachersList[i]->name)
				.arg(CustomFETString::numberPlusTwoDigitsPrecision((tg-maxGaps)*weightPercentage/100));

			*conflictsString+= s+"\n";

			dl.append(s);
			cl.append((tg-maxGaps)*weightPercentage/100);

			totalExtraGaps+=tg-maxGaps;
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(totalExtraGaps==0); //for partial solutions this rule might be broken
	return weightPercentage/100 * totalExtraGaps;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxGapsPerWeekForRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxGapsPerWeekForRealDays::ConstraintStudentsMaxGapsPerWeekForRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
}

ConstraintStudentsMaxGapsPerWeekForRealDays::ConstraintStudentsMaxGapsPerWeekForRealDays(double wp, int mg)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
	this->maxGaps=mg;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxGapsPerWeekForRealDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxGapsPerWeekForRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxGapsPerWeekForRealDays>\n";
	return s;
}

QString ConstraintStudentsMaxGapsPerWeekForRealDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students max gaps per week for real days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week for real days)").arg(this->maxGaps);

	return begin+s+end;
}

QString ConstraintStudentsMaxGapsPerWeekForRealDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of gaps per week for real days");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per week for real days=%1").arg(this->maxGaps);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxGapsPerWeekForRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nGaps;
	int tmp;
	int i;

	int tIllegalGaps=0;

	for(i=0; i<r.nInternalSubgroups; i++){
		nGaps=0;
		for(int real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
			int double_h;

			int k;
			tmp=0;
			for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			}
			for(; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				k=double_h%r.nHoursPerDay;
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
					if(subgroupsMatrix[i][j][k]>0){
						nGaps+=tmp;
						tmp=0;
					}
					else
						tmp++;
				}
			}
		}

		int illegalGaps=nGaps-this->maxGaps;
		if(illegalGaps<0)
			illegalGaps=0;

		if(illegalGaps>0 && conflictsString!=nullptr){
			QString s=tr("Time constraint students max gaps per week for real days broken for subgroup: %1, it has %2 extra gaps, conflicts increase=%3")
			 .arg(r.internalSubgroupsList[i]->name)
			 .arg(illegalGaps)
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(illegalGaps*weightPercentage/100));

			dl.append(s);
			cl.append(illegalGaps*weightPercentage/100);

			*conflictsString+= s+"\n";

			tIllegalGaps+=illegalGaps;
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxGapsPerWeekForRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxGapsPerWeekForRealDays::ConstraintStudentsSetMaxGapsPerWeekForRealDays()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
}

ConstraintStudentsSetMaxGapsPerWeekForRealDays::ConstraintStudentsSetMaxGapsPerWeekForRealDays(double wp, int mg, const QString& st )
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_GAPS_PER_WEEK_FOR_REAL_DAYS;
	this->maxGaps=mg;
	this->students = st;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::computeInternalStructure(QWidget* parent, Rules& r){
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max gaps per week for real days is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxGapsPerWeekForRealDays::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxGapsPerWeekForRealDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Gaps>"+CustomFETString::number(this->maxGaps)+"</Max_Gaps>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxGapsPerWeekForRealDays>\n";
	return s;
}

QString ConstraintStudentsSetMaxGapsPerWeekForRealDays::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students set max gaps per week for real days"); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage)); s+=translatedCommaSpace();
	s+=tr("MG:%1", "Max gaps (per week for real days)").arg(this->maxGaps);s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxGapsPerWeekForRealDays::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of gaps per week for real days");s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum gaps per week for real days=%1").arg(this->maxGaps);s+="\n";
	s+=tr("Students=%1").arg(this->students); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxGapsPerWeekForRealDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//OLD COMMENT
	//returns a number equal to the number of gaps of the subgroups (in hours)

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nGaps;
	int tmp;

	int tIllegalGaps=0;

	for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
		int i=this->iSubgroupsList.at(sg);
		nGaps=0;
		for(int real_d=0; real_d<r.nDaysPerWeek/2; real_d++){
			tmp=0;

			int double_h;

			for(double_h=0; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				int k=double_h%r.nHoursPerDay;
				if(subgroupsMatrix[i][j][k]>0){
					assert(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]);
					break;
				}
			}
			for(; double_h<2*r.nHoursPerDay; double_h++){
				int j;
				if(double_h<r.nHoursPerDay)
					j=2*real_d;
				else
					j=2*real_d+1;
				int k=double_h%r.nHoursPerDay;
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
					if(subgroupsMatrix[i][j][k]>0){
						nGaps+=tmp;
						tmp=0;
					}
					else
						tmp++;
				}
			}
		}

		int illegalGaps=nGaps-this->maxGaps;
		if(illegalGaps<0)
			illegalGaps=0;

		if(illegalGaps>0 && conflictsString!=nullptr){
			QString s=tr("Time constraint students set max gaps per week for real days broken for subgroup: %1, extra gaps=%2, conflicts increase=%3")
			 .arg(r.internalSubgroupsList[i]->name)
			 .arg(illegalGaps)
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*illegalGaps));

			dl.append(s);
			cl.append(weightPercentage/100*illegalGaps);

			*conflictsString+= s+"\n";

			tIllegalGaps+=illegalGaps;
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)     //for partial solutions it might be broken
			assert(tIllegalGaps==0);
	return weightPercentage/100 * tIllegalGaps;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::hasWrongDayOrHour(Rules& r)
{
	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxGapsPerWeekForRealDays::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxGaps=r.nDaysPerWeek*r.nHoursPerDay;

	return true;
}

//2021-08-12
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHERS_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHERS_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers must begin mornings early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must begin the mornings early, respecting maximum %1 later beginnings, at second hour")
	 .arg(this->maxBeginningsAtSecondHour);s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of teachers begin as early as possible the mornings

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	for(int i=0; i<r.nInternalTeachers; i++){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==1)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(teachersMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
						if(teachersMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint teachers mornings early max %1 beginnings at second hour broken for teacher %2, on day %3,"
					 " because the teacher has an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities){
					assert(0);
				}
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint teachers mornings early max %1 beginnings at second hour broken for teacher %2,"
				 " because the teacher has too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalTeachersList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities){
				assert(0);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMorningsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TEACHER_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH, const QString& teacher)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_TEACHER_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->teacherName=teacher;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	teacherIndex=r.teachersHash.value(teacherName, -1);
	assert(this->teacherIndex>=0);

	return true;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Teacher must begin mornings early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";

	s+=tr("A teacher must begin his mornings early, respecting a maximum number of later beginnings, at second hour"); s+="\n";
	s+=tr("(breaks and teacher not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName); s+="\n";
	s+=tr("Maximum number of beginnings at the second hour=%1").arg(this->maxBeginningsAtSecondHour);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	if(true){
		int i=teacherIndex;

		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==1)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(teachersMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !teacherNotAvailableDayHour[i][j][k]){
						if(teachersMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint teacher mornings early max %1 beginnings at second hour broken for teacher %2, on day %3,"
					 " because the teacher has an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities)
					assert(0);
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint teacher mornings early max %1 beginnings at second hour broken for teacher %2,"
				 " because the teacher has too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalTeachersList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities)
				assert(0);
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	return this->teacherName==t->name;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMorningsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Students must begin mornings early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour);
	s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must begin the mornings early, respecting maximum %1 later beginnings, at second hour")
	 .arg(this->maxBeginningsAtSecondHour);s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	for(int i=0; i<r.nInternalSubgroups; i++){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==1)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(subgroupsMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
						if(subgroupsMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint students mornings early max %1 beginnings at second hour broken for subgroup %2, on day %3,"
					 " because students have an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities){
					assert(0);
				}
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint students mornings early max %1 beginnings at second hour broken for subgroup %2,"
				 " because students have too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities){
				assert(0);
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMorningsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
}

ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour(double wp, int mBSH, const QString& students)
	: TimeConstraint(wp)
{
	this->type = CONSTRAINT_STUDENTS_SET_MORNINGS_EARLY_MAX_BEGINNINGS_AT_SECOND_HOUR;
	this->students=students;
	this->maxBeginningsAtSecondHour=mBSH;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set mornings early is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
	return true;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Beginnings_At_Second_Hour>"+CustomFETString::number(this->maxBeginningsAtSecondHour)+"</Max_Beginnings_At_Second_Hour>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour>\n";
	return s;
}

QString ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Students set must begin the mornings early, respecting maximum %1 beginnings at second hour")
	 .arg(this->maxBeginningsAtSecondHour); s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students set").arg(this->students);

	return begin+s+end;
}

QString ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";

	s+=tr("A students set must begin the mornings early, respecting a maximum number of later beginnings, at second hour"); s+="\n";
	s+=tr("(breaks and students set not available not counted)");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students); s+="\n";
	s+=tr("Maximum number of beginnings at the second hour=%1").arg(this->maxBeginningsAtSecondHour);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//considers the condition that the hours of subgroups begin as early as possible

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int conflTotal=0;

	for(int i : std::as_const(this->iSubgroupsList)){
		int nGapsFirstHour=0;
		for(int j=0; j<r.nDaysPerWeek; j++){
			if(j%2==1)
				continue;

			int k;
			for(k=0; k<r.nHoursPerDay; k++)
				if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k])
					break;

			bool firstHourOccupied=false;
			if(k<r.nHoursPerDay)
				if(subgroupsMatrix[i][j][k]>0)
					firstHourOccupied=true;

			bool dayOccupied=firstHourOccupied;

			bool illegalGap=false;

			if(!dayOccupied){
				for(k++; k<r.nHoursPerDay; k++){
					if(!breakDayHour[j][k] && !subgroupNotAvailableDayHour[i][j][k]){
						if(subgroupsMatrix[i][j][k]>0){
							dayOccupied=true;
							break;
						}
						else{
							illegalGap=true;
						}
					}
				}
			}

			if(dayOccupied && illegalGap){
				if(conflictsString!=nullptr){
					QString s=tr("Constraint students set mornings early max %1 beginnings at second hour broken for subgroup %2, on day %3,"
					 " because students have an illegal gap, increases conflicts total by %4")
					 .arg(this->maxBeginningsAtSecondHour)
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[j])
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(1*weightPercentage/100));

					dl.append(s);
					cl.append(1*weightPercentage/100);

					*conflictsString+= s+"\n";

					conflTotal+=1;
				}

				if(c.nPlacedActivities==r.nInternalActivities)
					assert(0);
			}

			if(dayOccupied && !firstHourOccupied)
				nGapsFirstHour++;
		}

		if(nGapsFirstHour>this->maxBeginningsAtSecondHour){
			if(conflictsString!=nullptr){
				QString s=tr("Constraint students set mornings early max %1 beginnings at second hour broken for subgroup %2,"
				 " because students have too many beginnings at second hour, increases conflicts total by %3")
				 .arg(this->maxBeginningsAtSecondHour)
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100));

				dl.append(s);
				cl.append((nGapsFirstHour-this->maxBeginningsAtSecondHour)*weightPercentage/100);

				*conflictsString+= s+"\n";

				conflTotal+=(nGapsFirstHour-this->maxBeginningsAtSecondHour);
			}

			if(c.nPlacedActivities==r.nInternalActivities)
				assert(0);
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)    //might be broken for partial solutions
			assert(conflTotal==0);
	return weightPercentage/100 * conflTotal;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::hasWrongDayOrHour(Rules& r)
{
	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		return true;

	return false;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMorningsEarlyMaxBeginningsAtSecondHour::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(maxBeginningsAtSecondHour>r.nDaysPerWeek/2)
		maxBeginningsAtSecondHour=r.nDaysPerWeek/2;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxThreeConsecutiveDays::ConstraintTeacherMaxThreeConsecutiveDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_THREE_CONSECUTIVE_DAYS;
}

ConstraintTeacherMaxThreeConsecutiveDays::ConstraintTeacherMaxThreeConsecutiveDays(double wp, bool ae, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->allowAMAMException=ae;
	this->type=CONSTRAINT_TEACHER_MAX_THREE_CONSECUTIVE_DAYS;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxThreeConsecutiveDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxThreeConsecutiveDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Allow_Afternoon_Morning_Afternoon_Morning_Exception>"+trueFalse(this->allowAMAMException)
	 +"</Allow_Afternoon_Morning_Afternoon_Morning_Exception>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxThreeConsecutiveDays>\n";
	return s;
}

QString ConstraintTeacherMaxThreeConsecutiveDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teacher max three consecutive days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("A-AMAM-E:%1", "Allow afternoon-morning-afternoon-morning exception").arg(yesNoTranslated(this->allowAMAMException));

	return begin+s+end;
}

QString ConstraintTeacherMaxThreeConsecutiveDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect a maximum of three consecutive working days");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Allow afternoon-morning-afternoon-morning exception=%1").arg(yesNoTranslated(this->allowAMAMException));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxThreeConsecutiveDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;
	
	Matrix1D<bool> tm;
	tm.resize(r.nDaysPerWeek);
	//Teacher* tch=r.internalTeachersList[this->teacher_ID];
	for(int d=0; d<r.nDaysPerWeek; d++){
		tm[d]=false;
		for(int h=0; h<r.nHoursPerDay; h++)
			if(teachersMatrix[this->teacher_ID][d][h]>0){
				tm[d]=true;
				break;
			}
	}
	
	for(int d=0; d<r.nDaysPerWeek; d++){
		if(d%2==1 && this->allowAMAMException)
			continue;
		if(d+3>=r.nDaysPerWeek)
			break;
		if(tm[d] && tm[d+1] && tm[d+2] && tm[d+3]){
			nbroken++;
		}
	}

	if(conflictsString!=nullptr){
		if(nbroken>0){
			QString s= tr("Time constraint teacher max three consecutive days broken for teacher: %1.")
			 .arg(r.internalTeachersList[this->teacher_ID]->name);
			s += QString(" ")+tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			
			dl.append(s);
			cl.append(nbroken*weightPercentage/100);
	
			*conflictsString += s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTeacherMaxThreeConsecutiveDays::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxThreeConsecutiveDays::ConstraintTeachersMaxThreeConsecutiveDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_THREE_CONSECUTIVE_DAYS;
}

ConstraintTeachersMaxThreeConsecutiveDays::ConstraintTeachersMaxThreeConsecutiveDays(double wp, bool ae)
	 : TimeConstraint(wp)
{
	this->allowAMAMException=ae;
	this->type=CONSTRAINT_TEACHERS_MAX_THREE_CONSECUTIVE_DAYS;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxThreeConsecutiveDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxThreeConsecutiveDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Allow_Afternoon_Morning_Afternoon_Morning_Exception>"+trueFalse(this->allowAMAMException)
	 +"</Allow_Afternoon_Morning_Afternoon_Morning_Exception>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxThreeConsecutiveDays>\n";
	return s;
}

QString ConstraintTeachersMaxThreeConsecutiveDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teachers max three consecutive days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("A-AMAM-E:%1", "Allow afternoon-morning-afternoon-morning exception").arg(yesNoTranslated(this->allowAMAMException));

	return begin+s+end;
}

QString ConstraintTeachersMaxThreeConsecutiveDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect a maximum of three consecutive working days");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Allow afternoon-morning-afternoon-morning exception=%1").arg(yesNoTranslated(this->allowAMAMException));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxThreeConsecutiveDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix1D<bool> tm;
	tm.resize(r.nDaysPerWeek);
	for(int t=0; t<r.nInternalTeachers; t++){
		//Teacher* tch=r.internalTeachersList[this->teacher_ID];
		for(int d=0; d<r.nDaysPerWeek; d++){
			tm[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[t][d][h]>0){
					tm[d]=true;
					break;
				}
		}
		
		int partialnbroken=0;
	
		for(int d=0; d<r.nDaysPerWeek; d++){
			if(d%2==1 && this->allowAMAMException)
				continue;
			if(d+3>=r.nDaysPerWeek)
				break;
			if(tm[d] && tm[d+1] && tm[d+2] && tm[d+3]){
				nbroken++;
				partialnbroken++;
			}
		}

		if(conflictsString!=nullptr){
			if(partialnbroken>0){
				QString s= tr("Time constraint teacher max three consecutive days broken for teacher: %1.")
				 .arg(r.internalTeachersList[t]->name);
				s += QString(" ")+tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			
				dl.append(s);
				cl.append(partialnbroken*weightPercentage/100);
		
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTeachersMaxThreeConsecutiveDays::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxThreeConsecutiveDays::ConstraintStudentsSetMaxThreeConsecutiveDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_THREE_CONSECUTIVE_DAYS;
}

ConstraintStudentsSetMaxThreeConsecutiveDays::ConstraintStudentsSetMaxThreeConsecutiveDays(double wp, bool ae, const QString& sn)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->allowAMAMException=ae;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_THREE_CONSECUTIVE_DAYS;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max three consecutive days is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxThreeConsecutiveDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxThreeConsecutiveDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	s+=IL3+"<Allow_Afternoon_Morning_Afternoon_Morning_Exception>"+trueFalse(this->allowAMAMException)
	 +"</Allow_Afternoon_Morning_Afternoon_Morning_Exception>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxThreeConsecutiveDays>\n";
	return s;
}

QString ConstraintStudentsSetMaxThreeConsecutiveDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Students set max three consecutive days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();
	s+=tr("A-AMAM-E:%1", "Allow afternoon-morning-afternoon-morning exception").arg(yesNoTranslated(this->allowAMAMException));

	return begin+s+end;
}

QString ConstraintStudentsSetMaxThreeConsecutiveDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect a maximum of three consecutive working days");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students=%1").arg(this->students);s+="\n";
	s+=tr("Allow afternoon-morning-afternoon-morning exception=%1").arg(yesNoTranslated(this->allowAMAMException));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxThreeConsecutiveDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int q=0; q<this->iSubgroupsList.count(); q++){
		int sbg=this->iSubgroupsList.at(q);
		int partialnbroken=0;
		
		Matrix1D<bool> sm;
		sm.resize(r.nDaysPerWeek);
		for(int d=0; d<r.nDaysPerWeek; d++){
			sm[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(subgroupsMatrix[sbg][d][h]>0){
					sm[d]=true;
					break;
				}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++){
			if(d%2==1 && this->allowAMAMException)
				continue;
			if(d+3>=r.nDaysPerWeek)
				break;
			if(sm[d] && sm[d+1] && sm[d+2] && sm[d+3]){
				partialnbroken++;
			}
		}
		
		if(conflictsString!=nullptr){
			if(partialnbroken>0){
				QString s= tr("Time constraint students set max three consecutive days broken for subgroup: %1.")
				 .arg(r.internalSubgroupsList[sbg]->name);
				s += QString(" ")+tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(partialnbroken*weightPercentage/100));
				
				dl.append(s);
				cl.append(partialnbroken*weightPercentage/100);
				
				*conflictsString += s+"\n";
			}
		}
		
		nbroken+=partialnbroken;
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintStudentsSetMaxThreeConsecutiveDays::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxThreeConsecutiveDays::ConstraintStudentsMaxThreeConsecutiveDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_THREE_CONSECUTIVE_DAYS;
}

ConstraintStudentsMaxThreeConsecutiveDays::ConstraintStudentsMaxThreeConsecutiveDays(double wp, bool ae)
	 : TimeConstraint(wp)
{
	this->allowAMAMException=ae;
	this->type=CONSTRAINT_STUDENTS_MAX_THREE_CONSECUTIVE_DAYS;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxThreeConsecutiveDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxThreeConsecutiveDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Allow_Afternoon_Morning_Afternoon_Morning_Exception>"+trueFalse(this->allowAMAMException)
	 +"</Allow_Afternoon_Morning_Afternoon_Morning_Exception>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxThreeConsecutiveDays>\n";
	return s;
}

QString ConstraintStudentsMaxThreeConsecutiveDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Students max three consecutive days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("A-AMAM-E:%1", "Allow afternoon-morning-afternoon-morning exception").arg(yesNoTranslated(this->allowAMAMException));

	return begin+s+end;
}

QString ConstraintStudentsMaxThreeConsecutiveDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect a maximum of three consecutive working days");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Allow afternoon-morning-afternoon-morning exception=%1").arg(yesNoTranslated(this->allowAMAMException));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxThreeConsecutiveDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix1D<bool> sm;
	sm.resize(r.nDaysPerWeek);
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		for(int d=0; d<r.nDaysPerWeek; d++){
			sm[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(subgroupsMatrix[sbg][d][h]>0){
					sm[d]=true;
					break;
				}
		}
		
		int partialnbroken=0;
	
		for(int d=0; d<r.nDaysPerWeek; d++){
			if(d%2==1 && this->allowAMAMException)
				continue;
			if(d+3>=r.nDaysPerWeek)
				break;
			if(sm[d] && sm[d+1] && sm[d+2] && sm[d+3]){
				nbroken++;
				partialnbroken++;
			}
		}

		if(conflictsString!=nullptr){
			if(partialnbroken>0){
				QString s= tr("Time constraint students max three consecutive days broken for subgroup: %1.")
				 .arg(r.internalSubgroupsList[sbg]->name);
				s += QString(" ")+tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			
				dl.append(s);
				cl.append(partialnbroken*weightPercentage/100);
		
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return false;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintStudentsMaxThreeConsecutiveDays::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintMinHalfDaysBetweenActivities::ConstraintMinHalfDaysBetweenActivities()
	: TimeConstraint()
{
	type=CONSTRAINT_MIN_HALF_DAYS_BETWEEN_ACTIVITIES;
}

ConstraintMinHalfDaysBetweenActivities::ConstraintMinHalfDaysBetweenActivities(double wp, bool cisd, int nact, const QList<int>& act, int _minHalfDays)
 : TimeConstraint(wp)
{
	this->consecutiveIfSameDay=cisd;

	assert(nact>=2);
	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	assert(_minHalfDays>0);
	this->minDays=_minHalfDays;

	this->type=CONSTRAINT_MIN_HALF_DAYS_BETWEEN_ACTIVITIES;
}

bool ConstraintMinHalfDaysBetweenActivities::operator==(ConstraintMinHalfDaysBetweenActivities& c){
	assert(this->n_activities==this->activitiesIds.count());
	assert(c.n_activities==c.activitiesIds.count());

	if(this->n_activities!=c.n_activities)
		return false;
	for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]!=c.activitiesIds[i])
			return false;
	if(this->minDays!=c.minDays)
		return false;
	if(this->weightPercentage!=c.weightPercentage)
		return false;
	if(this->consecutiveIfSameDay!=c.consecutiveIfSameDay)
		return false;
	return true;
}

bool ConstraintMinHalfDaysBetweenActivities::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintMinHalfDaysBetweenActivities::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintMinHalfDaysBetweenActivities::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMinHalfDaysBetweenActivities::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintMinHalfDaysBetweenActivities::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintMinHalfDaysBetweenActivities>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Consecutive_If_Same_Day>";s+=trueFalse(this->consecutiveIfSameDay);s+="</Consecutive_If_Same_Day>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MinDays>"+CustomFETString::number(this->minDays)+"</MinDays>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMinHalfDaysBetweenActivities>\n";
	return s;
}

QString ConstraintMinHalfDaysBetweenActivities::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Min half days between activities");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("mD:%1", "Min days").arg(this->minDays);s+=translatedCommaSpace();
	s+=tr("CSD:%1", "Consecutive if on the same day").arg(yesNoTranslated(this->consecutiveIfSameDay));

	return begin+s+end;
}

QString ConstraintMinHalfDaysBetweenActivities::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Minimum number of half days between activities");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Minimum number of days=%1").arg(this->minDays);s+="\n";
	s+=tr("Consecutive if on the same day=%1").arg(yesNoTranslated(this->consecutiveIfSameDay));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMinHalfDaysBetweenActivities::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int dist = abs(day1-day2);
						if(dist<minDays){
							tt=minDays-dist;
							
							if(this->consecutiveIfSameDay && day1==day2)
								assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}
						
						tmp=tt;
	
						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int hour1=t1/r.nDaysPerWeek;
				int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int hour2=t2/r.nDaysPerWeek;
						int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int dist = abs(day1-day2);

						if(dist<minDays){
							tt=minDays-dist;
							
							if(this->consecutiveIfSameDay && day1==day2)
								assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}

						tmp=tt;
	
						nbroken+=tmp;

						if(tt>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint min half days between activities broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), being %5 days too close, on days %6 and %7",
							 "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr. Close here means near")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
							 .arg(tt)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.daysOfTheWeek[day2]);
							 ;

							s+=translatedCommaSpace();
							s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							s+=translatedDot();
							
							if(this->consecutiveIfSameDay && day1==day2){
								s+=" ";
								s+=tr("The activities are placed consecutively in the timetable, because you selected this option"
								 " in case the activities are on the same day");
							}
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(true && minDays>=1 /*!this->consecutiveIfSameDay*/){ //from version 6.4.0, not allowed more than two activities on the same half day
	//The test minDays>=1 was added in FET-6.9.6, after the crash report by Rouge Ros on 2023-09-17. If minDays was 0, FET crashed if there were
	//more than two activities from this constraint on the same day. It is possible to have minDays==0 is the .fet file is created manually or
	//with another tool, or if the user decreases the number of days to 1 after adding one or more constraint(s) of type min days between activities.
		Matrix1D<int> na;
		na.resize(r.nDaysPerWeek);
		for(int d=0; d<r.nDaysPerWeek; d++)
			na[d]=0;
		
		for(int i=0; i<this->_n_activities; i++){
			int t=c.times[this->_activities[i]];
			if(t!=UNALLOCATED_TIME){
				int day=t%r.nDaysPerWeek;
				na[day]++;
			}
		}
		
		for(int d=0; d<r.nDaysPerWeek; d++)
			assert(na[d]<=2);
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintMinHalfDaysBetweenActivities::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintMinHalfDaysBetweenActivities::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMinHalfDaysBetweenActivities::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinHalfDaysBetweenActivities::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinHalfDaysBetweenActivities::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMinHalfDaysBetweenActivities::hasWrongDayOrHour(Rules& r)
{
	if(minDays>=r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintMinHalfDaysBetweenActivities::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintMinHalfDaysBetweenActivities::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(minDays>=r.nDaysPerWeek)
		minDays=r.nDaysPerWeek-1;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityPreferredDay::ConstraintActivityPreferredDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_PREFERRED_DAY;
}

ConstraintActivityPreferredDay::ConstraintActivityPreferredDay(double wp, int actId, int d/*, bool perm*/)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->day = d;
	this->type = CONSTRAINT_ACTIVITY_PREFERRED_DAY;
	//this->permanentlyLocked=perm;
}

bool ConstraintActivityPreferredDay::operator==(const ConstraintActivityPreferredDay& c){
	if(this->day!=c.day)
		return false;
	if(this->activityId!=c.activityId)
		return false;
	if(this->weightPercentage!=c.weightPercentage)
		return false;
	if(this->active!=c.active)
		return false;
	//no need to care about permanently locked
	return true;
}

bool ConstraintActivityPreferredDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	if(this->day >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
		 tr("Constraint activity preferred starting time is wrong because it refers to removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityPreferredDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityPreferredDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityPreferredDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	if(this->day>=0)
		s+=IL3+"<Day>"+protect(r.daysOfTheWeek[this->day])+"</Day>\n";
	//s+="	<Permanently_Locked>";s+=trueFalse(this->permanentlyLocked);s+="</Permanently_Locked>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityPreferredDay>\n";
	return s;
}

QString ConstraintActivityPreferredDay::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) has a preferred day: %3", "%1 is the id, %2 is the detailed description of the activity. %3 is day")
	 .arg(getActivityDescription(r, this->activityId))
	 .arg(getActivityDetailedDescription(r, this->activityId))
	 .arg(r.daysOfTheWeek[this->day]);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));
	//s+=translatedCommaSpace();
	//s+=tr("PL:%1", "Abbreviation for permanently locked").arg(yesNoTranslated(this->permanentlyLocked));

	return begin+s+end;
}

QString ConstraintActivityPreferredDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+="\n";

	s+=tr("has a preferred day:");
	s+="\n";
	s+=tr("Day=%1").arg(r.daysOfTheWeek[this->day]);
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	/*if(this->permanentlyLocked){
		s+=tr("This activity is permanently locked, which means you cannot unlock it from the 'Timetable' menu"
		" (you can unlock this activity by removing the constraint from the constraints dialog or by setting the 'permanently"
		" locked' attribute false when editing this constraint)");
	}
	else{
		s+=tr("This activity is not permanently locked, which means you can unlock it from the 'Timetable' menu");
	}
	s+="\n";*/

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityPreferredDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		//int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		if(this->day>=0)
			nbroken+=abs(this->day-d);
		//if(this->hour>=0)
		//	nbroken+=abs(this->hour-h);
	}
	if(nbroken>0)
		nbroken=1;

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity preferred day broken for activity with id=%1 (%2), increases conflicts total by %3",
			"%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activityId)
			.arg(getActivityDetailedDescription(r, this->activityId))
			.arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityPreferredDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityPreferredDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityPreferredDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityPreferredDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityPreferredDay::hasWrongDayOrHour(Rules& r)
{
	if(day<0 || day>=r.nDaysPerWeek)
		return true;
	return false;
}

bool ConstraintActivityPreferredDay::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return false;
}

bool ConstraintActivityPreferredDay::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return false;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesMinInATerm::ConstraintActivitiesMinInATerm()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_MIN_IN_A_TERM;
}

ConstraintActivitiesMinInATerm::ConstraintActivitiesMinInATerm(double wp,
	const QList<int>& a_L, int min_acts, bool allow_empty_terms)
	: TimeConstraint(wp)
{
	this->activitiesIds=a_L;
	this->minActivitiesInATerm=min_acts;
	this->allowEmptyTerms=allow_empty_terms;

	this->type=CONSTRAINT_ACTIVITIES_MIN_IN_A_TERM;
}

bool ConstraintActivitiesMinInATerm::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();

	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());

	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/

	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesMinInATerm::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive

	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesMinInATerm::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesMinInATerm>\n";

	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";

	s+=IL3+"<Min_Number_of_Activities_in_A_Term>"+CustomFETString::number(this->minActivitiesInATerm)+"</Min_Number_of_Activities_in_A_Term>\n";

	if(this->allowEmptyTerms)
		s+=IL3+"<Allow_Empty_Terms>true</Allow_Empty_Terms>\n";
	else
		s+=IL3+"<Allow_Empty_Terms>false</Allow_Empty_Terms>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesMinInATerm>\n";
	return s;
}

QString ConstraintActivitiesMinInATerm::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());

	QString s=tr("Activities min in a term, WP:%1%, NA:%2, A: %3, mAIAT:%4, AET:%5", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, mAIAT means min activities in a term, AET means allow empty terms")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(CustomFETString::number(this->minActivitiesInATerm))
	 .arg(yesNoTranslated(this->allowEmptyTerms));

	return begin+s+end;
}

QString ConstraintActivitiesMinInATerm::getDetailedDescription(Rules& r)
{
	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities min in a term"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Minimum number of activities in a term=%1").arg(CustomFETString::number(this->minActivitiesInATerm)); s+="\n";

	s+=tr("Allow empty terms=%1").arg(yesNoTranslated(this->allowEmptyTerms));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesMinInATerm::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	Matrix1D<int> cnt;
	cnt.resize(r.nTerms);
	for(int i=0; i<r.nTerms; i++)
		cnt[i]=0;
	for(int ai : std::as_const(this->_activitiesIndices))
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek;
			int term=d/r.nDaysPerTerm;
			cnt[term]++;
		}

	nbroken=0;

	for(int i=0; i<r.nTerms; i++){
		if(!this->allowEmptyTerms){
			if(cnt[i]<minActivitiesInATerm){
				nbroken++;
			}
		}
		else{
			if(cnt[i]<minActivitiesInATerm && cnt[i]>0){
				nbroken++;
			}
		}
	}

	if(nbroken>0){
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));

			dl.append(s);
			cl.append(weightPercentage/100.0);

			*conflictsString+= s+"\n";
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100.0)
			assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesMinInATerm::removeUseless(Rules& r)
{
	QList<int> newActs;

	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}

	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesMinInATerm::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesMinInATerm::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesMinInATerm::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesMinInATerm::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMinInATerm::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMinInATerm::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMinInATerm::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintActivitiesMinInATerm::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintActivitiesMinInATerm::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintMaxTermsBetweenActivities::ConstraintMaxTermsBetweenActivities()
	: TimeConstraint()
{
	type=CONSTRAINT_MAX_TERMS_BETWEEN_ACTIVITIES;
}

ConstraintMaxTermsBetweenActivities::ConstraintMaxTermsBetweenActivities(double wp, int nact, const QList<int>& act, int _maxTerms)
 : TimeConstraint(wp)
 {
  	assert(nact>=2);
  	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	assert(_maxTerms>=0);
	this->maxTerms=_maxTerms;

	this->type=CONSTRAINT_MAX_TERMS_BETWEEN_ACTIVITIES;
}

bool ConstraintMaxTermsBetweenActivities::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintMaxTermsBetweenActivities::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintMaxTermsBetweenActivities::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMaxTermsBetweenActivities::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintMaxTermsBetweenActivities::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintMaxTermsBetweenActivities>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MaxTerms>"+CustomFETString::number(this->maxTerms)+"</MaxTerms>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMaxTermsBetweenActivities>\n";
	return s;
}

QString ConstraintMaxTermsBetweenActivities::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Max terms between activities");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("MT:%1", "Abbreviation for maximum terms").arg(this->maxTerms);

	return begin+s+end;
}

QString ConstraintMaxTermsBetweenActivities::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Maximum number of terms between activities");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Maximum number of terms=%1").arg(this->maxTerms);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMaxTermsBetweenActivities::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int term1=day1/r.nDaysPerTerm;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int term2=day2/r.nDaysPerTerm;
					
						int tmp;
						int tt=0;
						int dist = abs(term1-term2);
						if(dist>maxTerms)
							tt=dist-maxTerms;
						
						tmp=tt;
	
						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				int term1=day1/r.nDaysPerTerm;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						int term2=day2/r.nDaysPerTerm;
					
						int tmp;
						int tt=0;
						int dist = abs(term1-term2);

						if(dist>maxTerms)
							tt=dist-maxTerms;

						tmp=tt;
	
						nbroken+=tmp;

						if(tt>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint max terms between activities broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), being %5 terms too far away"
							 ", on terms %6 and %7", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
							 .arg(tt)
							 .arg(term1)
							 .arg(term2);
							
							s+=translatedCommaSpace();
							s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							s+=translatedDot();
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintMaxTermsBetweenActivities::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintMaxTermsBetweenActivities::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMaxTermsBetweenActivities::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxTermsBetweenActivities::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxTermsBetweenActivities::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxTermsBetweenActivities::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

bool ConstraintMaxTermsBetweenActivities::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintMaxTermsBetweenActivities::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxActivityTagsPerDayFromSet::ConstraintStudentsSetMaxActivityTagsPerDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
}

ConstraintStudentsSetMaxActivityTagsPerDayFromSet::ConstraintStudentsSetMaxActivityTagsPerDayFromSet(double wp, const QString& sn, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max activity tags per day from a set is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);

	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);

		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}

		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxActivityTagsPerDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxActivityTagsPerDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxActivityTagsPerDayFromSet>\n";
	return s;
}

QString ConstraintStudentsSetMaxActivityTagsPerDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set max activity tags per day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintStudentsSetMaxActivityTagsPerDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect a maximum number of activity tags per day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students=%1").arg(this->students);s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxActivityTagsPerDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int sbg : std::as_const(this->iSubgroupsList)){
		StudentsSubgroup* ss=r.internalSubgroupsList[sbg];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(ss->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
			ts.intersect(this->internalTagsSet);
			assert(ts.count()<=1);
			int at=-1;
			if(!ts.isEmpty())
				at=*ts.constBegin();

			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				crtSubgroupTimetableActivityTag[d][h+dur]=at;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			QSet<int> usedTags;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d][h]>=0)
					usedTags.insert(crtSubgroupTimetableActivityTag[d][h]);

			if(usedTags.count() > this->maxTags)
				nbroken++;
		}
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>r.nHoursPerDay;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxActivityTagsPerDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>r.nHoursPerDay)
		this->maxTags=r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxActivityTagsPerDayFromSet::ConstraintStudentsMaxActivityTagsPerDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
}

ConstraintStudentsMaxActivityTagsPerDayFromSet::ConstraintStudentsMaxActivityTagsPerDayFromSet(double wp, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	//Q_UNUSED(parent);
	//Q_UNUSED(r);
	
	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);

		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}

		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

QString ConstraintStudentsMaxActivityTagsPerDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxActivityTagsPerDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxActivityTagsPerDayFromSet>\n";
	return s;
}

QString ConstraintStudentsMaxActivityTagsPerDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students max activity tags per day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintStudentsMaxActivityTagsPerDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect a maximum number of activity tags per day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxActivityTagsPerDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		StudentsSubgroup* ss=r.internalSubgroupsList[sbg];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(ss->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
			ts.intersect(this->internalTagsSet);
			assert(ts.count()<=1);
			int at=-1;
			if(!ts.isEmpty())
				at=*ts.constBegin();
			
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				crtSubgroupTimetableActivityTag[d][h+dur]=at;
			}
		}

		for(int d=0; d<r.nDaysPerWeek; d++){
			QSet<int> usedTags;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(crtSubgroupTimetableActivityTag[d][h]>=0)
					usedTags.insert(crtSubgroupTimetableActivityTag[d][h]);

			if(usedTags.count() > this->maxTags)
				nbroken++;
		}
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return true;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>r.nHoursPerDay;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxActivityTagsPerDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>r.nHoursPerDay)
		this->maxTags=r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxActivityTagsPerRealDayFromSet::ConstraintTeacherMaxActivityTagsPerRealDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
}

ConstraintTeacherMaxActivityTagsPerRealDayFromSet::ConstraintTeacherMaxActivityTagsPerRealDayFromSet(double wp, const QString& tn, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->type=CONSTRAINT_TEACHER_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	//Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	
	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);

		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}

		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxActivityTagsPerRealDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxActivityTagsPerRealDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxActivityTagsPerRealDayFromSet>\n";
	return s;
}

QString ConstraintTeacherMaxActivityTagsPerRealDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max activity tags per real day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintTeacherMaxActivityTagsPerRealDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect a maximum number of activity tags per real day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxActivityTagsPerRealDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Teacher* tch=r.internalTeachersList[teacher_ID];
	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			crtTeacherTimetableActivityTag[d][h]=-1;

	for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
		QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
		ts.intersect(this->internalTagsSet);
		assert(ts.count()<=1);
		int at=-1;
		if(!ts.isEmpty())
			at=*ts.constBegin();

		int d=c.times[ai]%r.nDaysPerWeek;
		int h=c.times[ai]/r.nDaysPerWeek;
		for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
			assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
			crtTeacherTimetableActivityTag[d][h+dur]=at;
		}
	}

	for(int d=0; d<r.nDaysPerWeek/2; d++){
		QSet<int> usedTags;
		for(int h=0; h<r.nHoursPerDay; h++){
			if(crtTeacherTimetableActivityTag[2*d][h]>=0)
				usedTags.insert(crtTeacherTimetableActivityTag[2*d][h]);
			if(crtTeacherTimetableActivityTag[2*d+1][h]>=0)
				usedTags.insert(crtTeacherTimetableActivityTag[2*d+1][h]);
		}

		if(usedTags.count() > this->maxTags)
			nbroken++;
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>2*r.nHoursPerDay;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMaxActivityTagsPerRealDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>2*r.nHoursPerDay)
		this->maxTags=2*r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxActivityTagsPerRealDayFromSet::ConstraintTeachersMaxActivityTagsPerRealDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
}

ConstraintTeachersMaxActivityTagsPerRealDayFromSet::ConstraintTeachersMaxActivityTagsPerRealDayFromSet(double wp, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_TEACHERS_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	//Q_UNUSED(parent);
	//Q_UNUSED(r);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	//teacher_ID=r.teachersHash.value(teacherName, -1);
	//assert(this->teacher_ID>=0);
	
	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);

		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}

		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxActivityTagsPerRealDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxActivityTagsPerRealDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxActivityTagsPerRealDayFromSet>\n";
	return s;
}

QString ConstraintTeachersMaxActivityTagsPerRealDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max activity tags per real day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintTeachersMaxActivityTagsPerRealDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect a maximum number of activity tags per real day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxActivityTagsPerRealDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix2D<int> crtTeacherTimetableActivityTag;
	crtTeacherTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int teacher_ID=0; teacher_ID<r.nInternalTeachers; teacher_ID++){
		Teacher* tch=r.internalTeachersList[teacher_ID];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtTeacherTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(tch->activitiesForTeacher)) if(c.times[ai]!=UNALLOCATED_TIME){
			QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
			ts.intersect(this->internalTagsSet);
			assert(ts.count()<=1);
			int at=-1;
			if(!ts.isEmpty())
				at=*ts.constBegin();

			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(crtTeacherTimetableActivityTag[d][h+dur]==-1);
				crtTeacherTimetableActivityTag[d][h+dur]=at;
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			QSet<int> usedTags;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(crtTeacherTimetableActivityTag[2*d][h]>=0)
					usedTags.insert(crtTeacherTimetableActivityTag[2*d][h]);
				if(crtTeacherTimetableActivityTag[2*d+1][h]>=0)
					usedTags.insert(crtTeacherTimetableActivityTag[2*d+1][h]);
			}

			if(usedTags.count() > this->maxTags)
				nbroken++;
		}
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>2*r.nHoursPerDay;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMaxActivityTagsPerRealDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>2*r.nHoursPerDay)
		this->maxTags=2*r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
}

ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet(double wp, const QString& sn, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max activity tags per real day from a set is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	
	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);

		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}

		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet>\n";
	return s;
}

QString ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set max activity tags per real day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect a maximum number of activity tags per real day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students=%1").arg(this->students);s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int sbg : std::as_const(this->iSubgroupsList)){
		StudentsSubgroup* ss=r.internalSubgroupsList[sbg];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(ss->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
			ts.intersect(this->internalTagsSet);
			assert(ts.count()<=1);
			int at=-1;
			if(!ts.isEmpty())
				at=*ts.constBegin();

			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				crtSubgroupTimetableActivityTag[d][h+dur]=at;
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			QSet<int> usedTags;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[2*d][h]>=0)
					usedTags.insert(crtSubgroupTimetableActivityTag[2*d][h]);
				if(crtSubgroupTimetableActivityTag[2*d+1][h]>=0)
					usedTags.insert(crtSubgroupTimetableActivityTag[2*d+1][h]);
			}

			if(usedTags.count() > this->maxTags)
				nbroken++;
		}
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>2*r.nHoursPerDay;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMaxActivityTagsPerRealDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>2*r.nHoursPerDay)
		this->maxTags=2*r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxActivityTagsPerRealDayFromSet::ConstraintStudentsMaxActivityTagsPerRealDayFromSet()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
}

ConstraintStudentsMaxActivityTagsPerRealDayFromSet::ConstraintStudentsMaxActivityTagsPerRealDayFromSet(double wp, int mtg, const QList<QString>& tgl)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_STUDENTS_MAX_ACTIVITY_TAGS_PER_REAL_DAY_FROM_SET;
	
	this->maxTags=mtg;
	this->tagsList=tgl;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::computeInternalStructure(QWidget* parent, Rules& r)
{
	//Q_UNUSED(parent);
	//Q_UNUSED(r);
	
	internalTagsSet.clear();
	for(const QString& at : tagsList){
		int tgi=r.activityTagsHash.value(at, -1);

		if(tgi==-1){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Activity tag %1 is not existing in the following constraint. Please edit or remove the constraint. Constraint is:\n%2").arg(at).arg(this->getDetailedDescription(r)));
			
			return false;
		}

		assert(tgi>=0);
		internalTagsSet.insert(tgi);
	}
	
	return true;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);

	return false;
}

QString ConstraintStudentsMaxActivityTagsPerRealDayFromSet::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxActivityTagsPerRealDayFromSet>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Maximum_Allowed_Activity_Tags>"+QString::number(maxTags)+"</Maximum_Allowed_Activity_Tags>\n";
	s+=IL3+"<Number_of_Activity_Tags>"+QString::number(tagsList.count())+"</Number_of_Activity_Tags>\n";
	for(const QString& atn : std::as_const(tagsList))
		s+=IL3+"<Activity_Tag>"+protect(atn)+"</Activity_Tag>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxActivityTagsPerRealDayFromSet>\n";
	return s;
}

QString ConstraintStudentsMaxActivityTagsPerRealDayFromSet::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students max activity tags per real day from a set");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MT:%1", "Max number of tags").arg(maxTags);s+=translatedCommaSpace();
	s+=tr("SAt:%1", "Set of activity tags").arg(tagsList.join(translatedCommaSpace()));

	return begin+s+end;
}

QString ConstraintStudentsMaxActivityTagsPerRealDayFromSet::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect a maximum number of activity tags per real day from a set");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum number of activity tags=%1").arg(maxTags);s+="\n";
	s+=tr("Set of activity tags=%1").arg(tagsList.join(translatedCommaSpace()));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxActivityTagsPerRealDayFromSet::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix2D<int> crtSubgroupTimetableActivityTag;
	crtSubgroupTimetableActivityTag.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		StudentsSubgroup* ss=r.internalSubgroupsList[sbg];
		for(int d=0; d<r.nDaysPerWeek; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				crtSubgroupTimetableActivityTag[d][h]=-1;

		for(int ai : std::as_const(ss->activitiesForSubgroup)) if(c.times[ai]!=UNALLOCATED_TIME){
			QSet<int> ts=r.internalActivitiesList[ai].iActivityTagsSet;
			ts.intersect(this->internalTagsSet);
			assert(ts.count()<=1);
			int at=-1;
			if(!ts.isEmpty())
				at=*ts.constBegin();
			
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<r.internalActivitiesList[ai].duration; dur++){
				assert(crtSubgroupTimetableActivityTag[d][h+dur]==-1);
				crtSubgroupTimetableActivityTag[d][h+dur]=at;
			}
		}

		for(int d=0; d<r.nDaysPerWeek/2; d++){
			QSet<int> usedTags;
			for(int h=0; h<r.nHoursPerDay; h++){
				if(crtSubgroupTimetableActivityTag[2*d][h]>=0)
					usedTags.insert(crtSubgroupTimetableActivityTag[2*d][h]);
				if(crtSubgroupTimetableActivityTag[2*d+1][h]>=0)
					usedTags.insert(crtSubgroupTimetableActivityTag[2*d+1][h]);
			}

			if(usedTags.count() > this->maxTags)
				nbroken++;
		}
	}

	assert(weightPercentage==100);

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::isRelatedToActivityTag(ActivityTag* s)
{
	return tagsList.contains(s->name);
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return true;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::hasWrongDayOrHour(Rules& r)
{
	return this->maxTags>2*r.nHoursPerDay;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMaxActivityTagsPerRealDayFromSet::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(this->maxTags>2*r.nHoursPerDay)
		this->maxTags=2*r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintMaxHalfDaysBetweenActivities::ConstraintMaxHalfDaysBetweenActivities()
	: TimeConstraint()
{
	type=CONSTRAINT_MAX_HALF_DAYS_BETWEEN_ACTIVITIES;
}

ConstraintMaxHalfDaysBetweenActivities::ConstraintMaxHalfDaysBetweenActivities(double wp, int nact, const QList<int>& act, int _maxHalfDays)
 : TimeConstraint(wp)
 {
  	assert(nact>=2);
  	assert(act.count()==nact);
	this->n_activities=nact;
	this->activitiesIds.clear();
	for(int i=0; i<nact; i++)
		this->activitiesIds.append(act.at(i));

	assert(_maxHalfDays>=0);
	this->maxDays=_maxHalfDays;

	this->type=CONSTRAINT_MAX_HALF_DAYS_BETWEEN_ACTIVITIES;
}

bool ConstraintMaxHalfDaysBetweenActivities::computeInternalStructure(QWidget* parent, Rules& r)
{
	//compute the indices of the activities,
	//based on their unique ID

	assert(this->n_activities==this->activitiesIds.count());

	this->_activities.clear();
	for(int i=0; i<this->n_activities; i++){
		int j=r.activitiesHash.value(activitiesIds.at(i), -1);
		//assert(j>=0);
		if(j>=0)
			_activities.append(j);
		/*int j;
		Activity* act;
		for(j=0; j<r.nInternalActivities; j++){
			act=&r.internalActivitiesList[j];
			if(act->id==this->activitiesIds[i]){
				this->_activities.append(j);
				break;
			}
		}*/
	}
	this->_n_activities=this->_activities.count();
	
	if(this->_n_activities<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		//assert(0);
		return false;
	}

	return true;
}

void ConstraintMaxHalfDaysBetweenActivities::removeUseless(Rules& r)
{
	//remove the activitiesIds which no longer exist (used after the deletion of an activity)
	
	assert(this->n_activities==this->activitiesIds.count());

	QList<int> tmpList;

	for(int i=0; i<this->n_activities; i++){
		Activity* act=r.activitiesPointerHash.value(activitiesIds[i], nullptr);
		if(act!=nullptr)
			tmpList.append(act->id);
		/*for(int k=0; k<r.activitiesList.size(); k++){
			Activity* act=r.activitiesList[k];
			if(act->id==this->activitiesIds[i]){
				tmpList.append(act->id);
				break;
			}
		}*/
	}
	
	this->activitiesIds=tmpList;
	this->n_activities=this->activitiesIds.count();

	r.internalStructureComputed=false;
}

void ConstraintMaxHalfDaysBetweenActivities::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintMaxHalfDaysBetweenActivities::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int i=0; i<this->n_activities; i++)
		if(r.inactiveActivities.contains(this->activitiesIds[i]))
			count++;

	if(this->n_activities-count<=1)
		return true;
	else
		return false;
}

QString ConstraintMaxHalfDaysBetweenActivities::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintMaxHalfDaysBetweenActivities>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Number_of_Activities>"+CustomFETString::number(this->n_activities)+"</Number_of_Activities>\n";
	for(int i=0; i<this->n_activities; i++)
		s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activitiesIds[i])+"</Activity_Id>\n";
	s+=IL3+"<MaxDays>"+CustomFETString::number(this->maxDays)+"</MaxDays>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintMaxHalfDaysBetweenActivities>\n";
	return s;
}

QString ConstraintMaxHalfDaysBetweenActivities::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Max half days between activities");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("NA:%1", "Number of activities").arg(this->n_activities);s+=translatedCommaSpace();
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Id:%1", "Id of activity").arg(getActivityDescription(r, this->activitiesIds[i]));s+=translatedCommaSpace();
	}
	s+=tr("MD:%1", "Abbreviation for maximum days").arg(this->maxDays);

	return begin+s+end;
}

QString ConstraintMaxHalfDaysBetweenActivities::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Maximum number of half days between activities");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(this->n_activities);s+="\n";
	for(int i=0; i<this->n_activities; i++){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
			.arg(this->activitiesIds[i])
			.arg(getActivityDetailedDescription(r, this->activitiesIds[i]));
		s+="\n";
	}
	s+=tr("Maximum number of days=%1").arg(this->maxDays);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintMaxHalfDaysBetweenActivities::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	assert(r.internalStructureComputed);

	int nbroken;

	//We do not use the matrices 'subgroupsMatrix' nor 'teachersMatrix'.

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				//int hour1=t1/r.nDaysPerWeek;
				//int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						//int hour2=t2/r.nDaysPerWeek;
						//int duration2=r.internalActivitiesList[this->_activities[j]].duration;
						
						int tmp;
						int tt=0;
						int dist = abs(day1-day2);
						if(dist>maxDays){
							tt=dist-maxDays;
							
							//if(this->consecutiveIfSameDay && day1==day2)
							//	assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}
						
						tmp=tt;
	
						nbroken+=tmp;
					}
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=1; i<this->_n_activities; i++){
			int t1=c.times[this->_activities[i]];
			if(t1!=UNALLOCATED_TIME){
				int day1=t1%r.nDaysPerWeek;
				//int hour1=t1/r.nDaysPerWeek;
				//int duration1=r.internalActivitiesList[this->_activities[i]].duration;

				for(int j=0; j<i; j++){
					int t2=c.times[this->_activities[j]];
					if(t2!=UNALLOCATED_TIME){
						int day2=t2%r.nDaysPerWeek;
						//int hour2=t2/r.nDaysPerWeek;
						//int duration2=r.internalActivitiesList[this->_activities[j]].duration;
					
						int tmp;
						int tt=0;
						int dist = abs(day1-day2);
						if(dist>maxDays){
							tt=dist-maxDays;
							
							//if(this->consecutiveIfSameDay && day1==day2)
							//	assert( day1==day2 && (hour1+duration1==hour2 || hour2+duration2==hour1) );
						}

						tmp=tt;

						nbroken+=tmp;

						if(tt>0 && conflictsString!=nullptr){
							QString s=tr("Time constraint max half days between activities broken: activity with id=%1 (%2) conflicts with activity with id=%3 (%4), being %5 days too far away"
							 ", on days %6 and %7", "%1 is the id, %2 is the detailed description of the activity, %3 id, %4 det. descr.")
							 .arg(r.internalActivitiesList[this->_activities[i]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[i]].id))
							 .arg(r.internalActivitiesList[this->_activities[j]].id)
							 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[this->_activities[j]].id))
							 .arg(tt)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.daysOfTheWeek[day2]);
							
							s+=translatedCommaSpace();
							s+=tr("conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(tmp*weightPercentage/100));
							s+=translatedDot();
							
							dl.append(s);
							cl.append(tmp*weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintMaxHalfDaysBetweenActivities::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	/*for(int i=0; i<this->n_activities; i++)
		if(this->activitiesIds[i]==a->id)
			return true;
	return false;*/
}

bool ConstraintMaxHalfDaysBetweenActivities::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintMaxHalfDaysBetweenActivities::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxHalfDaysBetweenActivities::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxHalfDaysBetweenActivities::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintMaxHalfDaysBetweenActivities::hasWrongDayOrHour(Rules& r)
{
	if(maxDays>=r.nDaysPerWeek)
		return true;
	
	return false;
}

bool ConstraintMaxHalfDaysBetweenActivities::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintMaxHalfDaysBetweenActivities::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxDays>=r.nDaysPerWeek)
		maxDays=r.nDaysPerWeek-1;
	
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityBeginsStudentsDay::ConstraintActivityBeginsStudentsDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_BEGINS_STUDENTS_DAY;
}

ConstraintActivityBeginsStudentsDay::ConstraintActivityBeginsStudentsDay(double wp, int actId)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->type = CONSTRAINT_ACTIVITY_BEGINS_STUDENTS_DAY;
}

bool ConstraintActivityBeginsStudentsDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityBeginsStudentsDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityBeginsStudentsDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityBeginsStudentsDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityBeginsStudentsDay>\n";
	return s;
}

QString ConstraintActivityBeginsStudentsDay::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) must begin students' day",
		"%1 is the id, %2 is the detailed description of the activity.")
		.arg(getActivityDescription(r, this->activityId))
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityBeginsStudentsDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity must begin students' day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityBeginsStudentsDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		
		int i=this->activityIndex;
		for(int j=0; j<r.internalActivitiesList[i].iSubgroupsList.count(); j++){
			int sb=r.internalActivitiesList[i].iSubgroupsList.at(j);
			for(int hh=h-1; hh>=0; hh--)
				if(subgroupsMatrix[sb][d][hh]>0){
					nbroken=1;
					break;
				}
			if(nbroken>0)
				break;
		}
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity begins students' day broken for activity with id=%1 (%2), increases conflicts total by %3",
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(this->activityId)
		 .arg(getActivityDetailedDescription(r, this->activityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityBeginsStudentsDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityBeginsStudentsDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityBeginsStudentsDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsStudentsDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsStudentsDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityBeginsStudentsDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivityBeginsStudentsDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivityBeginsStudentsDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesBeginStudentsDay::ConstraintActivitiesBeginStudentsDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_BEGIN_STUDENTS_DAY;
}

ConstraintActivitiesBeginStudentsDay::ConstraintActivitiesBeginStudentsDay(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut)
	: TimeConstraint(wp)
{
	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->type=CONSTRAINT_ACTIVITIES_BEGIN_STUDENTS_DAY;
}

bool ConstraintActivitiesBeginStudentsDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		assert(this->nActivities < r.nInternalActivities);
		this->nActivities++;
		this->activitiesIndices.append(i);
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesBeginStudentsDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintActivitiesBeginStudentsDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesBeginStudentsDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesBeginStudentsDay>\n";
	return s;
}

QString ConstraintActivitiesBeginStudentsDay::getDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString tc, st, su, at;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");
	
	QString s;
	s+=tr("Activities with %1, %2, %3, %4, must begin students' day", "%1...%4 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Abbreviation for Weight Percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesBeginStudentsDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
		
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	s+=tr("must begin students' day");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesBeginStudentsDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	for(int kk=0; kk<this->nActivities; kk++){
		int tmp=0;
		int ai=this->activitiesIndices[kk];
	
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
		
			for(int j=0; j<r.internalActivitiesList[ai].iSubgroupsList.count(); j++){
				int sb=r.internalActivitiesList[ai].iSubgroupsList.at(j);
				for(int hh=h-1; hh>=0; hh--)
					if(subgroupsMatrix[sb][d][hh]>0){
						nbroken++;
						tmp=1;
						break;
					}
				if(tmp>0)
					break;
			}

			if(conflictsString!=nullptr && tmp>0){
				QString s=tr("Time constraint activities begin students' day broken for activity with id=%1 (%2), increases conflicts total by %3",
				 "%1 is the id, %2 is the detailed description of the activity")
				 .arg(r.internalActivitiesList[ai].id)
				 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

				dl.append(s);
				cl.append(weightPercentage/100*tmp);
	
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivitiesBeginStudentsDay::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	return true;
}

bool ConstraintActivitiesBeginStudentsDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesBeginStudentsDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginStudentsDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginStudentsDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesBeginStudentsDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesBeginStudentsDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesBeginStudentsDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityBeginsTeachersDay::ConstraintActivityBeginsTeachersDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_BEGINS_TEACHERS_DAY;
}

ConstraintActivityBeginsTeachersDay::ConstraintActivityBeginsTeachersDay(double wp, int actId)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->type = CONSTRAINT_ACTIVITY_BEGINS_TEACHERS_DAY;
}

bool ConstraintActivityBeginsTeachersDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"), 
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityBeginsTeachersDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityBeginsTeachersDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityBeginsTeachersDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityBeginsTeachersDay>\n";
	return s;
}

QString ConstraintActivityBeginsTeachersDay::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) must begin teachers' day",
		"%1 is the id, %2 is the detailed description of the activity.")
		.arg(getActivityDescription(r, this->activityId))
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityBeginsTeachersDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity must begin teachers' day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityBeginsTeachersDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString> &dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		
		int i=this->activityIndex;
		for(int j=0; j<r.internalActivitiesList[i].iTeachersList.count(); j++){
			int tch=r.internalActivitiesList[i].iTeachersList.at(j);
			for(int hh=h-1; hh>=0; hh--)
				if(teachersMatrix[tch][d][hh]>0){
					nbroken=1;
					break;
				}
			if(nbroken>0)
				break;
		}
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity begins teachers' day broken for activity with id=%1 (%2), increases conflicts total by %3",
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(this->activityId)
		 .arg(getActivityDetailedDescription(r, this->activityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityBeginsTeachersDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityBeginsTeachersDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityBeginsTeachersDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsTeachersDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsTeachersDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityBeginsTeachersDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivityBeginsTeachersDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivityBeginsTeachersDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesBeginTeachersDay::ConstraintActivitiesBeginTeachersDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_BEGIN_TEACHERS_DAY;
}

ConstraintActivitiesBeginTeachersDay::ConstraintActivitiesBeginTeachersDay(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut)
	: TimeConstraint(wp)
{
	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->type=CONSTRAINT_ACTIVITIES_BEGIN_TEACHERS_DAY;
}

bool ConstraintActivitiesBeginTeachersDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		assert(this->nActivities < MAX_ACTIVITIES);
		this->nActivities++;
		this->activitiesIndices.append(i);
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesBeginTeachersDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintActivitiesBeginTeachersDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesBeginTeachersDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesBeginTeachersDay>\n";
	return s;
}

QString ConstraintActivitiesBeginTeachersDay::getDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString tc, st, su, at;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");
	
	QString s;
	s+=tr("Activities with %1, %2, %3, %4, must begin teachers' day", "%1...%4 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Abbreviation for Weight Percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesBeginTeachersDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
		
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	s+=tr("must begin teachers' day");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesBeginTeachersDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString> &dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	for(int kk=0; kk<this->nActivities; kk++){
		int tmp=0;
		int ai=this->activitiesIndices[kk];
	
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
		
			for(int j=0; j<r.internalActivitiesList[ai].iTeachersList.count(); j++){
				int tch=r.internalActivitiesList[ai].iTeachersList.at(j);
				for(int hh=h-1; hh>=0; hh--)
					if(teachersMatrix[tch][d][hh]>0){
						nbroken++;
						tmp=1;
						break;
					}
				if(tmp>0)
					break;
			}

			if(conflictsString!=nullptr && tmp>0){
				QString s=tr("Time constraint activities begin teachers' day broken for activity with id=%1 (%2), increases conflicts total by %3",
				 "%1 is the id, %2 is the detailed description of the activity")
				 .arg(r.internalActivitiesList[ai].id)
				 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

				dl.append(s);
				cl.append(weightPercentage/100*tmp);
	
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivitiesBeginTeachersDay::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	return true;
}

bool ConstraintActivitiesBeginTeachersDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesBeginTeachersDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginTeachersDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginTeachersDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesBeginTeachersDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesBeginTeachersDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesBeginTeachersDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

//2022-09-10
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMinHoursPerAfternoon::ConstraintTeachersMinHoursPerAfternoon()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_PER_AFTERNOON;

	this->allowEmptyAfternoons=true;
}

ConstraintTeachersMinHoursPerAfternoon::ConstraintTeachersMinHoursPerAfternoon(double wp, int minhours, bool _allowEmptyAfternoons)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursPerAfternoon=minhours;

	this->allowEmptyAfternoons=_allowEmptyAfternoons;

	this->type=CONSTRAINT_TEACHERS_MIN_HOURS_PER_AFTERNOON;
}

bool ConstraintTeachersMinHoursPerAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(r);

	if(allowEmptyAfternoons==false){
		QString s=tr("Cannot generate a timetable with a constraint teachers min hours per afternoon with allow empty afternoons=false. Please modify it,"
			" so that it allows empty afternoons. If you need a facility like that, please use constraint teachers min afternoons per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);

		return false;
	}

	return true;
}

bool ConstraintTeachersMinHoursPerAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMinHoursPerAfternoon::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMinHoursPerAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Hours_Per_Afternoon>"+CustomFETString::number(this->minHoursPerAfternoon)+"</Minimum_Hours_Per_Afternoon>\n";
	if(this->allowEmptyAfternoons)
		s+=IL3+"<Allow_Empty_Afternoons>true</Allow_Empty_Afternoons>\n";
	else
		s+=IL3+"<Allow_Empty_Afternoons>false</Allow_Empty_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMinHoursPerAfternoon>\n";
	return s;
}

QString ConstraintTeachersMinHoursPerAfternoon::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teachers min hours per afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (per afternoon)").arg(this->minHoursPerAfternoon);s+=translatedCommaSpace();
	s+=tr("AEA:%1", "Allow empty afternoons").arg(yesNoTranslated(this->allowEmptyAfternoons));

	return begin+s+end;
}

QString ConstraintTeachersMinHoursPerAfternoon::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the minimum number of hours per afternoon"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum hours per afternoon=%1").arg(this->minHoursPerAfternoon);s+="\n";
	s+=tr("Allow empty afternoons=%1").arg(yesNoTranslated(this->allowEmptyAfternoons));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMinHoursPerAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	assert(this->allowEmptyAfternoons==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				if(d%2==0)
					continue;
				int n_hours_per_afternoon=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_per_afternoon++;

				if(n_hours_per_afternoon>0 && n_hours_per_afternoon<this->minHoursPerAfternoon){
					nbroken++;
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				if(d%2==0)
					continue;
				int n_hours_per_afternoon=0;
				for(int h=0; h<r.nHoursPerDay; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_per_afternoon++;

				if(n_hours_per_afternoon>0 && n_hours_per_afternoon<this->minHoursPerAfternoon){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr("Time constraint teachers min %1 hours per afternoon broken for teacher %2, on day %3, length=%4.")
						 .arg(CustomFETString::number(this->minHoursPerAfternoon))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(r.daysOfTheWeek[d])
						 .arg(n_hours_per_afternoon)
						 )
						 +
						 " "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));

						dl.append(s);
						cl.append(weightPercentage/100);

						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMinHoursPerAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(a);
	Q_UNUSED(r);

	return false;
}

bool ConstraintTeachersMinHoursPerAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMinHoursPerAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursPerAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursPerAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMinHoursPerAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerAfternoon>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMinHoursPerAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeachersMinHoursPerAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerAfternoon>r.nHoursPerDay)
		minHoursPerAfternoon=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMinHoursPerAfternoon::ConstraintTeacherMinHoursPerAfternoon()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MIN_HOURS_PER_AFTERNOON;

	this->allowEmptyAfternoons=true;
}

ConstraintTeacherMinHoursPerAfternoon::ConstraintTeacherMinHoursPerAfternoon(double wp, int minhours, const QString& teacher, bool _allowEmptyAfternoons)
 : TimeConstraint(wp)
 {
	assert(minhours>0);
	this->minHoursPerAfternoon=minhours;
	this->teacherName=teacher;

	this->allowEmptyAfternoons=_allowEmptyAfternoons;

	this->type=CONSTRAINT_TEACHER_MIN_HOURS_PER_AFTERNOON;
}

bool ConstraintTeacherMinHoursPerAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	if(allowEmptyAfternoons==false){
		QString s=tr("Cannot generate a timetable with a constraint teacher min hours per afternoon with allow empty afternoons=false. Please modify it,"
			" so that it allows empty afternoons. If you need a facility like that, please use constraint teacher min afternoons per week");
		s+="\n\n";
		s+=tr("Constraint is:")+"\n"+this->getDetailedDescription(r);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"), s);

		return false;
	}

	return true;
}

bool ConstraintTeacherMinHoursPerAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMinHoursPerAfternoon::getXmlDescription(Rules& r){
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMinHoursPerAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Minimum_Hours_Per_Afternoon>"+CustomFETString::number(this->minHoursPerAfternoon)+"</Minimum_Hours_Per_Afternoon>\n";
	if(this->allowEmptyAfternoons)
		s+=IL3+"<Allow_Empty_Afternoons>true</Allow_Empty_Afternoons>\n";
	else
		s+=IL3+"<Allow_Empty_Afternoons>false</Allow_Empty_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMinHoursPerAfternoon>\n";
	return s;
}

QString ConstraintTeacherMinHoursPerAfternoon::getDescription(Rules& r){
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;
	s+=tr("Teacher min hours per afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("mH:%1", "Minimum hours (per afternoon)").arg(this->minHoursPerAfternoon);s+=translatedCommaSpace();
	s+=tr("AEA:%1", "Allow empty afternoons").arg(yesNoTranslated(this->allowEmptyAfternoons));

	return begin+s+end;
}

QString ConstraintTeacherMinHoursPerAfternoon::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the minimum number of hours per afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Minimum hours per afternoon=%1").arg(this->minHoursPerAfternoon);s+="\n";
	s+=tr("Allow empty afternoons=%1").arg(yesNoTranslated(this->allowEmptyAfternoons));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMinHoursPerAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	assert(this->allowEmptyAfternoons==true);

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			if(d%2==0)
				continue;
			int n_hours_per_afternoon=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_per_afternoon++;

			if(n_hours_per_afternoon>0 && n_hours_per_afternoon<this->minHoursPerAfternoon){
				nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			if(d%2==0)
				continue;
			int n_hours_per_afternoon=0;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_per_afternoon++;

			if(n_hours_per_afternoon>0 && n_hours_per_afternoon<this->minHoursPerAfternoon){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher min %1 hours per afternoon broken for teacher %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->minHoursPerAfternoon))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(n_hours_per_afternoon)
					 )
					 +" "
					 +
					 tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100));

					dl.append(s);
					cl.append(weightPercentage/100);

					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);

	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMinHoursPerAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMinHoursPerAfternoon::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMinHoursPerAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursPerAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursPerAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMinHoursPerAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerAfternoon>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMinHoursPerAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTeacherMinHoursPerAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerAfternoon>r.nHoursPerDay)
		minHoursPerAfternoon=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMinHoursPerAfternoon::ConstraintStudentsMinHoursPerAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MIN_HOURS_PER_AFTERNOON;
	this->minHoursPerAfternoon = -1;

	this->allowEmptyAfternoons=false;
}

ConstraintStudentsMinHoursPerAfternoon::ConstraintStudentsMinHoursPerAfternoon(double wp, int minnh, bool _allowEmptyAfternoons)
	: TimeConstraint(wp)
{
	this->minHoursPerAfternoon = minnh;
	this->type = CONSTRAINT_STUDENTS_MIN_HOURS_PER_AFTERNOON;

	this->allowEmptyAfternoons=_allowEmptyAfternoons;
}

bool ConstraintStudentsMinHoursPerAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintStudentsMinHoursPerAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMinHoursPerAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMinHoursPerAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	if(this->minHoursPerAfternoon>=0)
		s+=IL3+"<Minimum_Hours_Per_Afternoon>"+CustomFETString::number(this->minHoursPerAfternoon)+"</Minimum_Hours_Per_Afternoon>\n";
	else
		assert(0);
	if(this->allowEmptyAfternoons)
		s+=IL3+"<Allow_Empty_Afternoons>true</Allow_Empty_Afternoons>\n";
	else
		s+=IL3+"<Allow_Empty_Afternoons>false</Allow_Empty_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMinHoursPerAfternoon>\n";
	return s;
}

QString ConstraintStudentsMinHoursPerAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Students min hours per afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (per afternoon)").arg(this->minHoursPerAfternoon);s+=translatedCommaSpace();
	s+=tr("AEA:%1", "Allow empty afternoons").arg(yesNoTranslated(this->allowEmptyAfternoons));

	return begin+s+end;
}

QString ConstraintStudentsMinHoursPerAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the minimum number of hours per afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Minimum hours per afternoon=%1").arg(this->minHoursPerAfternoon);s+="\n";
	s+=tr("Allow empty afternoons=%1").arg(yesNoTranslated(this->allowEmptyAfternoons));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMinHoursPerAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp1/*, tmp2*/;
	int too_little;

	assert(this->minHoursPerAfternoon>=0);

	too_little=0;
	for(int i=0; i<r.nInternalSubgroups; i++)
		for(int j=0; j<r.nDaysPerWeek/2; j++){
			tmp1=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j+1][k]>=1)
					tmp1++;
			}

			if(tmp1>0 && tmp1<this->minHoursPerAfternoon){
				too_little += - tmp1 + this->minHoursPerAfternoon;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students min hours per afternoon broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j+1])
					 .arg(CustomFETString::number(tmp1))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp1+this->minHoursPerAfternoon)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp1+this->minHoursPerAfternoon));

					*conflictsString+= s+"\n";
				}
			}

			/*tmp2=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j+1][k]>=1)
					tmp2++;
			}

			if(tmp2>0 && tmp2<this->minHoursDaily){
				too_little += - tmp2 + this->minHoursDaily;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j+1])
					 .arg(CustomFETString::number(tmp2))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp2+this->minHoursDaily)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp2+this->minHoursDaily));

					*conflictsString+= s+"\n";
				}
			}*/

			if(!this->allowEmptyAfternoons==true)
				if(tmp1/*+tmp2*/==0){
					too_little++;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students min hours per afternoon broken for subgroup: %1, day: %2, empty afternoon, but"
						 " the constraint does not allow empty afternoons, conflicts increase=%3")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j+1])
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(1)));

						dl.append(s);
						cl.append(weightPercentage/100*1);

						*conflictsString+= s+"\n";
					}
				}
		}

	assert(too_little>=0);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100) //does not work for partial solutions
			assert(too_little==0);

	return too_little * weightPercentage/100;
}

bool ConstraintStudentsMinHoursPerAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMinHoursPerAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMinHoursPerAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinHoursPerAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMinHoursPerAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMinHoursPerAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerAfternoon>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMinHoursPerAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsMinHoursPerAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerAfternoon>r.nHoursPerDay)
		minHoursPerAfternoon=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMinHoursPerAfternoon::ConstraintStudentsSetMinHoursPerAfternoon()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MIN_HOURS_PER_AFTERNOON;
	this->minHoursPerAfternoon = -1;

	this->allowEmptyAfternoons=false;
}

ConstraintStudentsSetMinHoursPerAfternoon::ConstraintStudentsSetMinHoursPerAfternoon(double wp, int minnh, const QString& s, bool _allowEmptyAfternoons)
	: TimeConstraint(wp)
{
	this->minHoursPerAfternoon = minnh;
	this->students = s;
	this->type = CONSTRAINT_STUDENTS_SET_MIN_HOURS_PER_AFTERNOON;

	this->allowEmptyAfternoons=_allowEmptyAfternoons;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMinHoursPerAfternoon::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMinHoursPerAfternoon>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Minimum_Hours_Per_Afternoon>"+CustomFETString::number(this->minHoursPerAfternoon)+"</Minimum_Hours_Per_Afternoon>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";
	if(this->allowEmptyAfternoons)
		s+=IL3+"<Allow_Empty_Afternoons>true</Allow_Empty_Afternoons>\n";
	else
		s+=IL3+"<Allow_Empty_Afternoons>false</Allow_Empty_Afternoons>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMinHoursPerAfternoon>\n";
	return s;
}

QString ConstraintStudentsSetMinHoursPerAfternoon::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s;

	s+=tr("Students set min hours per afternoon");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students);s+=translatedCommaSpace();
	s+=tr("mH:%1", "Min hours (per afternoon)").arg(this->minHoursPerAfternoon);s+=translatedCommaSpace();
	s+=tr("AEA:%1", "Allow empty afternoons").arg(yesNoTranslated(this->allowEmptyAfternoons));

	return begin+s+end;
}

QString ConstraintStudentsSetMinHoursPerAfternoon::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the minimum number of hours per afternoon");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";
	s+=tr("Minimum hours per afternoon=%1").arg(this->minHoursPerAfternoon);s+="\n";
	s+=tr("Allow empty afternoons=%1").arg(yesNoTranslated(this->allowEmptyAfternoons));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set min hours per afternoon is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/

	return true;
}

double ConstraintStudentsSetMinHoursPerAfternoon::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp1/*, tmp2*/;
	int too_little;

	assert(this->minHoursPerAfternoon>=0);

	too_little=0;
	for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
		int i=iSubgroupsList.at(sg);
		for(int j=0; j<r.nDaysPerWeek/2; j++){
			tmp1=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j+1][k]>=1)
					tmp1++;
			}

			if(tmp1>0 && tmp1<this->minHoursPerAfternoon){
				too_little += - tmp1 + this->minHoursPerAfternoon;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students set min hours per afternoon broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j+1])
					 .arg(CustomFETString::number(tmp1))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp1+this->minHoursPerAfternoon)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp1+this->minHoursPerAfternoon));

					*conflictsString+= s+"\n";
				}
			}

			/*tmp2=0;
			for(int k=0; k<r.nHoursPerDay; k++){
				if(subgroupsMatrix[i][2*j+1][k]>=1)
					tmp2++;
			}

			if(tmp2>0 && tmp2<this->minHoursDaily){
				too_little += - tmp2 + this->minHoursDaily;

				if(conflictsString!=nullptr){
					QString s=tr("Time constraint students set min hours daily broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
					 .arg(r.internalSubgroupsList[i]->name)
					 .arg(r.daysOfTheWeek[2*j+1])
					 .arg(CustomFETString::number(tmp2))
					 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(-tmp2+this->minHoursDaily)));

					dl.append(s);
					cl.append(weightPercentage/100*(-tmp2+this->minHoursDaily));

					*conflictsString+= s+"\n";
				}
			}*/

			if(!this->allowEmptyAfternoons==true)
				if(tmp1/*+tmp2*/==0){
					too_little++;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set min hours per afternoon broken for subgroup: %1, day: %2, empty afternoon, but"
						 " the constraint does not allow empty afternoons, conflicts increase=%3")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[2*j+1])
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*(1)));

						dl.append(s);
						cl.append(weightPercentage/100*1);

						*conflictsString+= s+"\n";
					}
				}
		}
	}

	assert(too_little>=0);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100) //does not work for partial solutions
			assert(too_little==0);

	return too_little * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMinHoursPerAfternoon::hasWrongDayOrHour(Rules& r)
{
	if(minHoursPerAfternoon>r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintStudentsSetMinHoursPerAfternoon::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	if(minHoursPerAfternoon>r.nHoursPerDay)
		minHoursPerAfternoon=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxHoursDailyInInterval::ConstraintTeacherMaxHoursDailyInInterval()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_HOURS_DAILY_IN_INTERVAL;
}

ConstraintTeacherMaxHoursDailyInInterval::ConstraintTeacherMaxHoursDailyInInterval(double wp, int maxhours, const QString& teacher, int sh, int eh)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->teacherName=teacher;
	this->startHour=sh;
	this->endHour=eh;

	this->type=CONSTRAINT_TEACHER_MAX_HOURS_DAILY_IN_INTERVAL;
}

bool ConstraintTeacherMaxHoursDailyInInterval::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxHoursDailyInInterval::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxHoursDailyInInterval::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxHoursDailyInInterval>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";

	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}

	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxHoursDailyInInterval>\n";
	return s;
}

QString ConstraintTeacherMaxHoursDailyInInterval::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teacher max hours daily in hourly interval");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();

	s+=tr("ISH:%1", "Abbreviation for interval start hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->startHour]);s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(tr("End of the day"));
	s+=translatedCommaSpace();

	s+=tr("MH:%1", "Maximum hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintTeacherMaxHoursDailyInInterval::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of hours daily in an hourly interval");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";
	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxHoursDailyInInterval::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int n_hours_daily=0;
			for(int h=this->startHour; h<this->endHour; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_daily++;

			if(n_hours_daily>this->maxHoursDaily){
				nbroken++;
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		int i=this->teacher_ID;
		for(int d=0; d<r.nDaysPerWeek; d++){
			int n_hours_daily=0;
			for(int h=this->startHour; h<this->endHour; h++)
				if(teachersMatrix[i][d][h]>0)
					n_hours_daily++;

			if(n_hours_daily>this->maxHoursDaily){
				nbroken++;

				if(conflictsString!=nullptr){
					QString s=(tr(
					 "Time constraint teacher max %1 hours daily in hourly interval broken for teacher %2, on day %3, length=%4.")
					 .arg(CustomFETString::number(this->maxHoursDaily))
					 .arg(r.internalTeachersList[i]->name)
					 .arg(r.daysOfTheWeek[d])
					 .arg(n_hours_daily)
					 )
					 +" "
					 +
					 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
					
					dl.append(s);
					cl.append(weightPercentage/100);
				
					*conflictsString+= s+"\n";
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxHoursDailyInInterval::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxHoursDailyInInterval::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxHoursDailyInInterval::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDailyInInterval::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDailyInInterval::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursDailyInInterval::hasWrongDayOrHour(Rules& r)
{
	if(startHour>=r.nHoursPerDay)
		return true;
	if(endHour>r.nHoursPerDay)
		return true;
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherMaxHoursDailyInInterval::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMaxHoursDailyInInterval::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay);
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxHoursDailyInInterval::ConstraintTeachersMaxHoursDailyInInterval()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_IN_INTERVAL;
}

ConstraintTeachersMaxHoursDailyInInterval::ConstraintTeachersMaxHoursDailyInInterval(double wp, int maxhours, int sh, int eh)
 : TimeConstraint(wp)
 {
	assert(maxhours>0);
	this->maxHoursDaily=maxhours;
	this->startHour=sh;
	this->endHour=eh;

	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_DAILY_IN_INTERVAL;
}

bool ConstraintTeachersMaxHoursDailyInInterval::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxHoursDailyInInterval::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxHoursDailyInInterval::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxHoursDailyInInterval>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}

	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxHoursDailyInInterval>\n";
	return s;
}

QString ConstraintTeachersMaxHoursDailyInInterval::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teachers max hours daily in hourly interval");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("ISH:%1", "Abbreviation for interval start hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->startHour]);s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(tr("End of the day"));
	s+=translatedCommaSpace();

	s+=tr("MH:%1", "Maximum hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintTeachersMaxHoursDailyInInterval::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of hours daily in an hourly interval");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";
	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxHoursDailyInInterval::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	//without logging
	if(conflictsString==nullptr){
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				int n_hours_daily=0;
				for(int h=this->startHour; h<this->endHour; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_daily++;

				if(n_hours_daily>this->maxHoursDaily){
					nbroken++;
				}
			}
		}
	}
	//with logging
	else{
		nbroken=0;
		for(int i=0; i<r.nInternalTeachers; i++){
			for(int d=0; d<r.nDaysPerWeek; d++){
				int n_hours_daily=0;
				for(int h=this->startHour; h<this->endHour; h++)
					if(teachersMatrix[i][d][h]>0)
						n_hours_daily++;

				if(n_hours_daily>this->maxHoursDaily){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr(
						 "Time constraint teachers max %1 hours daily in hourly interval broken for teacher %2, on day %3, length=%4.")
						 .arg(CustomFETString::number(this->maxHoursDaily))
						 .arg(r.internalTeachersList[i]->name)
						 .arg(r.daysOfTheWeek[d])
						 .arg(n_hours_daily)
						 )
						 +" "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
						
						dl.append(s);
						cl.append(weightPercentage/100);
						
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxHoursDailyInInterval::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxHoursDailyInInterval::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxHoursDailyInInterval::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDailyInInterval::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDailyInInterval::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursDailyInInterval::hasWrongDayOrHour(Rules& r)
{
	if(startHour>=r.nHoursPerDay)
		return true;
	if(endHour>r.nHoursPerDay)
		return true;
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersMaxHoursDailyInInterval::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMaxHoursDailyInInterval::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay);
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxHoursDailyInInterval::ConstraintStudentsSetMaxHoursDailyInInterval()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_IN_INTERVAL;
	this->maxHoursDaily = -1;
}

ConstraintStudentsSetMaxHoursDailyInInterval::ConstraintStudentsSetMaxHoursDailyInInterval(double wp, int maxnh, const QString& s, int sh, int eh)
	: TimeConstraint(wp)
{
	assert(maxnh>0);
	this->maxHoursDaily = maxnh;
	this->students = s;
	this->startHour = sh;
	this->endHour = eh;
	this->type = CONSTRAINT_STUDENTS_SET_MAX_HOURS_DAILY_IN_INTERVAL;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxHoursDailyInInterval::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetMaxHoursDailyInInterval>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}

	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxHoursDailyInInterval>\n";
	return s;
}

QString ConstraintStudentsSetMaxHoursDailyInInterval::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students set max hours daily in hourly interval");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students (set)").arg(this->students); s+=translatedCommaSpace();

	s+=tr("ISH:%1", "Abbreviation for interval start hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->startHour]);s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(tr("End of the day"));
	s+=translatedCommaSpace();

	s+=tr("MH:%1", "Max hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxHoursDailyInInterval::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect the maximum number of hours daily in an hourly interval");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";
	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::computeInternalStructure(QWidget* parent, Rules& r)
{
	//StudentsSet* ss=r.searchAugmentedStudentsSet(this->students);
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max hours daily in hourly interval is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);
	/*this->iSubgroupsList.clear();
	if(ss->type==STUDENTS_SUBGROUP){
		int tmp;
		tmp=((StudentsSubgroup*)ss)->indexInInternalSubgroupsList;
		assert(tmp>=0);
		assert(tmp<r.nInternalSubgroups);
		if(!this->iSubgroupsList.contains(tmp))
			this->iSubgroupsList.append(tmp);
	}
	else if(ss->type==STUDENTS_GROUP){
		StudentsGroup* stg=(StudentsGroup*)ss;
		for(int i=0; i<stg->subgroupsList.size(); i++){
			StudentsSubgroup* sts=stg->subgroupsList[i];
			int tmp;
			tmp=sts->indexInInternalSubgroupsList;
			assert(tmp>=0);
			assert(tmp<r.nInternalSubgroups);
			if(!this->iSubgroupsList.contains(tmp))
				this->iSubgroupsList.append(tmp);
		}
	}
	else if(ss->type==STUDENTS_YEAR){
		StudentsYear* sty=(StudentsYear*)ss;
		for(int i=0; i<sty->groupsList.size(); i++){
			StudentsGroup* stg=sty->groupsList[i];
			for(int j=0; j<stg->subgroupsList.size(); j++){
				StudentsSubgroup* sts=stg->subgroupsList[j];
				int tmp;
				tmp=sts->indexInInternalSubgroupsList;
				assert(tmp>=0);
				assert(tmp<r.nInternalSubgroups);
				if(!this->iSubgroupsList.contains(tmp))
					this->iSubgroupsList.append(tmp);
			}
		}
	}
	else
		assert(0);*/
		
	return true;
}

double ConstraintStudentsSetMaxHoursDailyInInterval::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp;
	int too_much;

	assert(this->maxHoursDaily>=0);

	if(true){
		too_much=0;
		for(int sg=0; sg<this->iSubgroupsList.count(); sg++){
			int i=iSubgroupsList.at(sg);
			for(int j=0; j<r.nDaysPerWeek; j++){
				tmp=0;
				for(int k=this->startHour; k<this->endHour; k++){
					//Here we want to see if we have a weekly activity or a 2 weeks activity
					//We don't do tmp+=subgroupsMatrix[i][j][k] because we already counted this as a hard hitness
					if(subgroupsMatrix[i][j][k]>=1)
						tmp++;
				}
				if(this->maxHoursDaily>=0 && tmp > this->maxHoursDaily){ //we would like no more than max_hours_daily hours per day.
					too_much += 1; //tmp - this->maxHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students set max hours daily in hourly interval broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[j])
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision( 1 *weightPercentage/100));
						
						dl.append(s);
						cl.append( 1 *weightPercentage/100);
					
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}
	
	assert(too_much>=0);
	if(weightPercentage==100)
		assert(too_much==0);
	return too_much * weightPercentage / 100.0;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::hasWrongDayOrHour(Rules& r)
{
	if(startHour>=r.nHoursPerDay)
		return true;
	if(endHour>r.nHoursPerDay)
		return true;
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxHoursDailyInInterval::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay);
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxHoursDailyInInterval::ConstraintStudentsMaxHoursDailyInInterval()
	: TimeConstraint()
{
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_IN_INTERVAL;
	this->maxHoursDaily = -1;
}

ConstraintStudentsMaxHoursDailyInInterval::ConstraintStudentsMaxHoursDailyInInterval(double wp, int maxnh, int sh, int eh)
	: TimeConstraint(wp)
{
	assert(maxnh>0);
	this->maxHoursDaily = maxnh;
	this->startHour = sh;
	this->endHour = eh;
	this->type = CONSTRAINT_STUDENTS_MAX_HOURS_DAILY_IN_INTERVAL;
}

bool ConstraintStudentsMaxHoursDailyInInterval::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxHoursDailyInInterval::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsMaxHoursDailyInInterval>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Interval_Start_Hour>"+protect(r.hoursOfTheDay[this->startHour])+"</Interval_Start_Hour>\n";
	if(this->endHour < r.nHoursPerDay){
		s+=IL3+"<Interval_End_Hour>"+protect(r.hoursOfTheDay[this->endHour])+"</Interval_End_Hour>\n";
	}
	else{
		s+=IL3+"<Interval_End_Hour></Interval_End_Hour>\n";
		s+=IL3+"<!-- Interval_End_Hour void means the end of the day (which has no name) -->\n";
	}

	s+=IL3+"<Maximum_Hours_Daily>"+CustomFETString::number(this->maxHoursDaily)+"</Maximum_Hours_Daily>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxHoursDailyInInterval>\n";
	return s;
}

QString ConstraintStudentsMaxHoursDailyInInterval::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Students max hours daily in hourly interval");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("ISH:%1", "Abbreviation for interval start hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->startHour]);s+=translatedCommaSpace();
	if(this->endHour<r.nHoursPerDay)
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("IEH:%1", "Abbreviation for interval end hour. Please use different abbreviations for interval start hour and interval end hour.").arg(tr("End of the day"));
	s+=translatedCommaSpace();

	s+=tr("MH:%1", "Max hours (daily)").arg(this->maxHoursDaily);

	return begin+s+end;
}

QString ConstraintStudentsMaxHoursDailyInInterval::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect the maximum number of hours daily in an hourly interval");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Interval start hour=%1").arg(r.hoursOfTheDay[this->startHour]);s+="\n";
	if(this->endHour<r.nHoursPerDay)
		s+=tr("Interval end hour=%1").arg(r.hoursOfTheDay[this->endHour]);
	else
		s+=tr("Interval end hour=%1").arg(tr("End of the day"));
	s+="\n";

	s+=tr("Maximum hours daily=%1").arg(this->maxHoursDaily);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

bool ConstraintStudentsMaxHoursDailyInInterval::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);
	
	return true;
}

double ConstraintStudentsMaxHoursDailyInInterval::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int tmp;
	int too_much;

	assert(this->maxHoursDaily>=0);

	if(true){
		too_much=0;
		for(int i=0; i<r.nInternalSubgroups; i++){
			for(int j=0; j<r.nDaysPerWeek; j++){
				tmp=0;
				for(int k=this->startHour; k<this->endHour; k++){
					//Here we want to see if we have a weekly activity or a 2 weeks activity
					//We don't do tmp+=subgroupsMatrix[i][j][k] because we already counted this as a hard hitness
					if(subgroupsMatrix[i][j][k]>=1)
						tmp++;
				}
				if(this->maxHoursDaily>=0 && tmp > this->maxHoursDaily){ //we would like no more than max_hours_daily hours per day.
					too_much += 1; //tmp - this->maxHoursDaily;

					if(conflictsString!=nullptr){
						QString s=tr("Time constraint students max hours daily in hourly interval broken for subgroup: %1, day: %2, length=%3, conflicts increase=%4")
						 .arg(r.internalSubgroupsList[i]->name)
						 .arg(r.daysOfTheWeek[j])
						 .arg(CustomFETString::number(tmp))
						 .arg(CustomFETString::numberPlusTwoDigitsPrecision( 1 *weightPercentage/100));
						
						dl.append(s);
						cl.append( 1 *weightPercentage/100);
					
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}
	
	assert(too_much>=0);
	if(weightPercentage==100)
		assert(too_much==0);
	return too_much * weightPercentage / 100.0;
}

bool ConstraintStudentsMaxHoursDailyInInterval::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxHoursDailyInInterval::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxHoursDailyInInterval::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursDailyInInterval::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxHoursDailyInInterval::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return true;
}

bool ConstraintStudentsMaxHoursDailyInInterval::hasWrongDayOrHour(Rules& r)
{
	if(startHour>=r.nHoursPerDay)
		return true;
	if(endHour>r.nHoursPerDay)
		return true;
	if(maxHoursDaily>r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsMaxHoursDailyInInterval::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMaxHoursDailyInInterval::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(startHour<r.nHoursPerDay && endHour<=r.nHoursPerDay);
	
	if(maxHoursDaily>r.nHoursPerDay)
		maxHoursDaily=r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherNoTwoConsecutiveDays::ConstraintTeacherNoTwoConsecutiveDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_NO_TWO_CONSECUTIVE_DAYS;
}

ConstraintTeacherNoTwoConsecutiveDays::ConstraintTeacherNoTwoConsecutiveDays(double wp, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->type=CONSTRAINT_TEACHER_NO_TWO_CONSECUTIVE_DAYS;
}

bool ConstraintTeacherNoTwoConsecutiveDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherNoTwoConsecutiveDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherNoTwoConsecutiveDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherNoTwoConsecutiveDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherNoTwoConsecutiveDays>\n";
	return s;
}

QString ConstraintTeacherNoTwoConsecutiveDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teacher no two consecutive days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);

	return begin+s+end;
}

QString ConstraintTeacherNoTwoConsecutiveDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must not work two consecutive days");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherNoTwoConsecutiveDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;
	
	Matrix1D<bool> tm;
	tm.resize(r.nDaysPerWeek);
	//Teacher* tch=r.internalTeachersList[this->teacher_ID];
	for(int d=0; d<r.nDaysPerWeek; d++){
		tm[d]=false;
		for(int h=0; h<r.nHoursPerDay; h++)
			if(teachersMatrix[this->teacher_ID][d][h]>0){
				tm[d]=true;
				break;
			}
	}
	
	for(int d=0; d<r.nDaysPerWeek-1; d++){
		if(tm[d] && tm[d+1]){
			nbroken++;
		}
	}

	if(conflictsString!=nullptr){
		if(nbroken>0){
			QString s= tr("Time constraint teacher no two consecutive days broken for teacher: %1.")
			 .arg(r.internalTeachersList[this->teacher_ID]->name);
			s += QString(" ")+tr("This increases the conflicts total by %1")
			 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			
			dl.append(s);
			cl.append(nbroken*weightPercentage/100);
	
			*conflictsString += s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherNoTwoConsecutiveDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherNoTwoConsecutiveDays::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherNoTwoConsecutiveDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherNoTwoConsecutiveDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherNoTwoConsecutiveDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherNoTwoConsecutiveDays::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTeacherNoTwoConsecutiveDays::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTeacherNoTwoConsecutiveDays::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersNoTwoConsecutiveDays::ConstraintTeachersNoTwoConsecutiveDays()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_NO_TWO_CONSECUTIVE_DAYS;
}

ConstraintTeachersNoTwoConsecutiveDays::ConstraintTeachersNoTwoConsecutiveDays(double wp)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_TEACHERS_NO_TWO_CONSECUTIVE_DAYS;
}

bool ConstraintTeachersNoTwoConsecutiveDays::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersNoTwoConsecutiveDays::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersNoTwoConsecutiveDays::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersNoTwoConsecutiveDays>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersNoTwoConsecutiveDays>\n";
	return s;
}

QString ConstraintTeachersNoTwoConsecutiveDays::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teachers no two consecutive days");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintTeachersNoTwoConsecutiveDays::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must not work two consecutive days");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersNoTwoConsecutiveDays::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	Matrix1D<bool> tm;
	tm.resize(r.nDaysPerWeek);
	for(int t=0; t<r.nInternalTeachers; t++){
		//Teacher* tch=r.internalTeachersList[this->teacher_ID];
		for(int d=0; d<r.nDaysPerWeek; d++){
			tm[d]=false;
			for(int h=0; h<r.nHoursPerDay; h++)
				if(teachersMatrix[t][d][h]>0){
					tm[d]=true;
					break;
				}
		}
		
		int partialnbroken=0;
	
		for(int d=0; d<r.nDaysPerWeek-1; d++){
			if(tm[d] && tm[d+1]){
				nbroken++;
				partialnbroken++;
			}
		}

		if(conflictsString!=nullptr){
			if(partialnbroken>0){
				QString s= tr("Time constraint teachers no two consecutive days broken for teacher: %1.")
				 .arg(r.internalTeachersList[t]->name);
				s += QString(" ")+tr("This increases the conflicts total by %1")
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
			
				dl.append(s);
				cl.append(partialnbroken*weightPercentage/100);
		
				*conflictsString += s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersNoTwoConsecutiveDays::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersNoTwoConsecutiveDays::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersNoTwoConsecutiveDays::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersNoTwoConsecutiveDays::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersNoTwoConsecutiveDays::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersNoTwoConsecutiveDays::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintTeachersNoTwoConsecutiveDays::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintTeachersNoTwoConsecutiveDays::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::ConstraintTeacherPairOfMutuallyExclusiveTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::ConstraintTeacherPairOfMutuallyExclusiveTimeSlots(double wp, const QString& teacher, int d1, int h1, int d2, int h2)
 : TimeConstraint(wp)
 {
	this->teacherName=teacher;
	this->day1=d1;
	this->hour1=h1;
	this->day2=d2;
	this->hour2=h2;

	this->type=CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	if(this->day1 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive time slots is wrong because the first time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour1 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive time slots is wrong because the first time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->day2 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive time slots is wrong because the second time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour2 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive time slots is wrong because the second time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	if(this->day1==this->day2 && this->hour1==this->hour2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive time slots is wrong because the two time slots are the same. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	return true;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherPairOfMutuallyExclusiveTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";

	s+=IL3+"<First_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day1])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour1])+"</Hour>\n";
	s+=IL3+"</First_Time_Slot>\n";

	s+=IL3+"<Second_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day2])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour2])+"</Hour>\n";
	s+=IL3+"</Second_Time_Slot>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherPairOfMutuallyExclusiveTimeSlots>\n";
	return s;
}

QString ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teacher pair of mutually exclusive time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();

	s+=tr("FTS:%1", "First time slot").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+=translatedCommaSpace();
	s+=tr("STS:%1", "Second time slot").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);

	return begin+s+end;
}

QString ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher has a pair of mutually exclusive time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	s+=tr("First time slot=%1").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+="\n";
	s+=tr("Second time slot=%1").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	int i=this->teacher_ID;

	if(teachersMatrix[i][this->day1][this->hour1]>0 && teachersMatrix[i][this->day2][this->hour2]>0){
		nbroken++;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint teacher pair of mutually exclusive time slots broken for teacher %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
			 .arg(r.internalTeachersList[i]->name)
			 .arg(r.daysOfTheWeek[day1])
			 .arg(r.hoursOfTheDay[hour1])
			 .arg(r.daysOfTheWeek[day2])
			 .arg(r.hoursOfTheDay[hour2])
			 )
			 +" "
			 +
			 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
			
			dl.append(s);
			cl.append(weightPercentage/100);
			
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::hasWrongDayOrHour(Rules& r)
{
	if(day1>=r.nDaysPerWeek)
		return true;
	if(hour1>=r.nHoursPerDay)
		return true;
	if(day2>=r.nDaysPerWeek)
		return true;
	if(hour2>=r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveTimeSlots::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::ConstraintTeachersPairOfMutuallyExclusiveTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::ConstraintTeachersPairOfMutuallyExclusiveTimeSlots(double wp, int d1, int h1, int d2, int h2)
 : TimeConstraint(wp)
 {
	this->day1=d1;
	this->hour1=h1;
	this->day2=d2;
	this->hour2=h2;

	this->type=CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->day1 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive time slots is wrong because the first time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour1 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive time slots is wrong because the first time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->day2 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive time slots is wrong because the second time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour2 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive time slots is wrong because the second time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	if(this->day1==this->day2 && this->hour1==this->hour2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive time slots is wrong because the two time slots are the same. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	return true;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersPairOfMutuallyExclusiveTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<First_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day1])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour1])+"</Hour>\n";
	s+=IL3+"</First_Time_Slot>\n";

	s+=IL3+"<Second_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day2])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour2])+"</Hour>\n";
	s+=IL3+"</Second_Time_Slot>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersPairOfMutuallyExclusiveTimeSlots>\n";
	return s;
}

QString ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teachers pair of mutually exclusive time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("FTS:%1", "First time slot").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+=translatedCommaSpace();
	s+=tr("STS:%1", "Second time slot").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);

	return begin+s+end;
}

QString ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers have a pair of mutually exclusive time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("First time slot=%1").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+="\n";
	s+=tr("Second time slot=%1").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i=0; i<r.nInternalTeachers; i++){
		if(teachersMatrix[i][this->day1][this->hour1]>0 && teachersMatrix[i][this->day2][this->hour2]>0){
			nbroken++;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint teachers pair of mutually exclusive time slots broken for teacher %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
				 .arg(r.internalTeachersList[i]->name)
				 .arg(r.daysOfTheWeek[day1])
				 .arg(r.hoursOfTheDay[hour1])
				 .arg(r.daysOfTheWeek[day2])
				 .arg(r.hoursOfTheDay[hour2])
				 )
				 +" "
				 +
				 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
				
				dl.append(s);
				cl.append(weightPercentage/100);
				
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::hasWrongDayOrHour(Rules& r)
{
	if(day1>=r.nDaysPerWeek)
		return true;
	if(hour1>=r.nHoursPerDay)
		return true;
	if(day2>=r.nDaysPerWeek)
		return true;
	if(hour2>=r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveTimeSlots::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots(double wp, const QString& s, int d1, int h1, int d2, int h2)
 : TimeConstraint(wp)
 {
	this->students=s;
	this->day1=d1;
	this->hour1=h1;
	this->day2=d2;
	this->hour2=h2;

	this->type=CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive time slots is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	if(this->day1 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive time slots is wrong because the first time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour1 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive time slots is wrong because the first time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->day2 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive time slots is wrong because the second time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour2 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive time slots is wrong because the second time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	if(this->day1==this->day2 && this->hour1==this->hour2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive time slots is wrong because the two time slots are the same. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);

	return true;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<First_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day1])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour1])+"</Hour>\n";
	s+=IL3+"</First_Time_Slot>\n";

	s+=IL3+"<Second_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day2])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour2])+"</Hour>\n";
	s+=IL3+"</Second_Time_Slot>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots>\n";
	return s;
}

QString ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Students set pair of mutually exclusive time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();

	s+=tr("FTS:%1", "First time slot").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+=translatedCommaSpace();
	s+=tr("STS:%1", "Second time slot").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);

	return begin+s+end;
}

QString ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set has a pair of mutually exclusive time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students set=%1").arg(this->students);s+="\n";

	s+=tr("First time slot=%1").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+="\n";
	s+=tr("Second time slot=%1").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int m=0; m<this->iSubgroupsList.count(); m++){
		int sbg=this->iSubgroupsList.at(m);

		if(subgroupsMatrix[sbg][this->day1][this->hour1]>0 && subgroupsMatrix[sbg][this->day2][this->hour2]>0){
			nbroken++;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint students set pair of mutually exclusive time slots broken for subgroup %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(r.daysOfTheWeek[day1])
				 .arg(r.hoursOfTheDay[hour1])
				 .arg(r.daysOfTheWeek[day2])
				 .arg(r.hoursOfTheDay[hour2])
				 )
				 +" "
				 +
				 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
				
				dl.append(s);
				cl.append(weightPercentage/100);
				
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::hasWrongDayOrHour(Rules& r)
{
	if(day1>=r.nDaysPerWeek)
		return true;
	if(hour1>=r.nHoursPerDay)
		return true;
	if(day2>=r.nDaysPerWeek)
		return true;
	if(hour2>=r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveTimeSlots::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::ConstraintStudentsPairOfMutuallyExclusiveTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::ConstraintStudentsPairOfMutuallyExclusiveTimeSlots(double wp, int d1, int h1, int d2, int h2)
 : TimeConstraint(wp)
 {
	this->day1=d1;
	this->hour1=h1;
	this->day2=d2;
	this->hour2=h2;

	this->type=CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	if(this->day1 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive time slots is wrong because the first time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour1 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive time slots is wrong because the first time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->day2 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive time slots is wrong because the second time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour2 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive time slots is wrong because the second time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	if(this->day1==this->day2 && this->hour1==this->hour2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive time slots is wrong because the two time slots are the same. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	return true;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsPairOfMutuallyExclusiveTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<First_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day1])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour1])+"</Hour>\n";
	s+=IL3+"</First_Time_Slot>\n";

	s+=IL3+"<Second_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day2])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour2])+"</Hour>\n";
	s+=IL3+"</Second_Time_Slot>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsPairOfMutuallyExclusiveTimeSlots>\n";
	return s;
}

QString ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Students pair of mutually exclusive time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("FTS:%1", "First time slot").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+=translatedCommaSpace();
	s+=tr("STS:%1", "Second time slot").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);

	return begin+s+end;
}

QString ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students have a pair of mutually exclusive time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("First time slot=%1").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+="\n";
	s+=tr("Second time slot=%1").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		if(subgroupsMatrix[sbg][this->day1][this->hour1]>0 && subgroupsMatrix[sbg][this->day2][this->hour2]>0){
			nbroken++;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint students set pair of mutually exclusive time slots broken for subgroup %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
				 .arg(r.internalSubgroupsList[sbg]->name)
				 .arg(r.daysOfTheWeek[day1])
				 .arg(r.hoursOfTheDay[hour1])
				 .arg(r.daysOfTheWeek[day2])
				 .arg(r.hoursOfTheDay[hour2])
				 )
				 +" "
				 +
				 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
				
				dl.append(s);
				cl.append(weightPercentage/100);
				
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::hasWrongDayOrHour(Rules& r)
{
	if(day1>=r.nDaysPerWeek)
		return true;
	if(hour1>=r.nHoursPerDay)
		return true;
	if(day2>=r.nDaysPerWeek)
		return true;
	if(hour2>=r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveTimeSlots::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintTwoSetsOfActivitiesSameSections::ConstraintTwoSetsOfActivitiesSameSections()
	: TimeConstraint()
{
	this->type = CONSTRAINT_TWO_SETS_OF_ACTIVITIES_SAME_SECTIONS;
}

ConstraintTwoSetsOfActivitiesSameSections::ConstraintTwoSetsOfActivitiesSameSections(double wp,
	const QList<int>& aA_L, const QList<int>& aB_L, const QList<int>& d_L, const QList<int>& h_L)
	: TimeConstraint(wp)
{
	assert(d_L.count()==h_L.count());

	this->activitiesAIds=aA_L;
	this->activitiesBIds=aB_L;
	this->oDays=d_L;
	this->oHours=h_L;

	this->type=CONSTRAINT_TWO_SETS_OF_ACTIVITIES_SAME_SECTIONS;
}

bool ConstraintTwoSetsOfActivitiesSameSections::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesAIndices.clear();
	for(int id : std::as_const(activitiesAIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesAIndices.append(i);
	}
	_activitiesBIndices.clear();
	for(int id : std::as_const(activitiesBIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesBIndices.append(i);
	}

	std::stable_sort(_activitiesAIndices.begin(), _activitiesAIndices.end(),
	 [&r](int a, int b){return r.internalActivitiesList[a].iSubgroupsList<r.internalActivitiesList[b].iSubgroupsList;});

	std::stable_sort(_activitiesBIndices.begin(), _activitiesBIndices.end(),
	 [&r](int a, int b){return r.internalActivitiesList[a].iSubgroupsList<r.internalActivitiesList[b].iSubgroupsList;});

	/*this->_activitiesIndices.clear();

	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());

	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/

	//////////////////////
	assert(this->oDays.count()==this->oHours.count());

	for(int k=0; k<this->oDays.count(); k++){
		if(this->oDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint two sets of activities have the same sections is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
		if(this->oHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint two sets of activities have the same sections is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
		if(this->oHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint two sets of activities have the same sections is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
		if(this->oDays.at(k)<0 || this->oHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint two sets of activities have the same sections is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

			return false;
		}
	}

	this->_oSlotsSet.clear();
	for(int k=0; k<this->oDays.count(); k++){
		int d=this->oDays.at(k);
		int h=this->oHours.at(k);
		this->_oSlotsSet.insert(d+h*r.nDaysPerWeek);
	}
	///////////////////////

	if(this->_activitiesAIndices.count()>0 && this->_activitiesBIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (the first set and/or the second set contain(s) no active activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintTwoSetsOfActivitiesSameSections::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive

	for(int aid : std::as_const(this->activitiesAIds))
		if(!r.inactiveActivities.contains(aid))
			return false;
	for(int aid : std::as_const(this->activitiesBIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintTwoSetsOfActivitiesSameSections::getXmlDescription(Rules& r)
{
	assert(this->oDays.count()==this->oHours.count());

	QString s=IL2+"<ConstraintTwoSetsOfActivitiesSameSections>\n";

	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<First_Activities_Ids_Set>\n";
	s+=IL4+"<Number_of_Activities>"+QString::number(this->activitiesAIds.count())+"</Number_of_Activities>\n";
	for(int ai : std::as_const(this->activitiesAIds))
		s+=IL4+"<Activity_Id>"+CustomFETString::number(ai)+"</Activity_Id>\n";
	s+=IL3+"</First_Activities_Ids_Set>\n";
	s+=IL3+"<Second_Activities_Ids_Set>\n";
	s+=IL4+"<Number_of_Activities>"+QString::number(this->activitiesBIds.count())+"</Number_of_Activities>\n";
	for(int ai : std::as_const(this->activitiesBIds))
		s+=IL4+"<Activity_Id>"+CustomFETString::number(ai)+"</Activity_Id>\n";
	s+=IL3+"</Second_Activities_Ids_Set>\n";

	s+=IL3+"<Number_of_Exception_Time_Slots>"+QString::number(this->oDays.count())+"</Number_of_Exception_Time_Slots>\n";
	for(int i=0; i<this->oDays.count(); i++){
		s+=IL3+"<Exception_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->oDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->oHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Exception_Time_Slot>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTwoSetsOfActivitiesSameSections>\n";
	return s;
}

QString ConstraintTwoSetsOfActivitiesSameSections::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	assert(this->oDays.count()==this->oHours.count());

	QString actAids=QString("");
	for(int aid : std::as_const(this->activitiesAIds))
		actAids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actAids.chop(translatedCommaSpace().size());

	QString actBids=QString("");
	for(int aid : std::as_const(this->activitiesBIds))
		actBids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actBids.chop(translatedCommaSpace().size());

	QString timeslots=QString("");
	for(int i=0; i<this->oDays.count(); i++)
		timeslots+=r.daysOfTheWeek[oDays.at(i)]+QString(" ")+r.hoursOfTheDay[oHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	QString s=tr("Two sets of activities have the same sections, WP:%1%, N1:%2, SA1: %3, N2:%4, SA2: %5, ETS: %6", "Constraint description. WP means weight percentage, "
	 "N1 means the number of activities in the first set, SA1 means first set of activities, N2 means the number of activities in the second set, "
	 "SA2 means the second set of activities, ETS means exception time slots (time slots which are excepted)")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesAIds.count()))
	 .arg(actAids)
	 .arg(QString::number(this->activitiesBIds.count()))
	 .arg(actBids)
	 .arg(timeslots);

	return begin+s+end;
}

QString ConstraintTwoSetsOfActivitiesSameSections::getDetailedDescription(Rules& r)
{
	assert(this->oDays.count()==this->oHours.count());

	QString actAids=QString("");
	for(int aid : std::as_const(this->activitiesAIds))
		actAids+=CustomFETString::number(aid)+translatedCommaSpace();
	actAids.chop(translatedCommaSpace().size());

	QString actBids=QString("");
	for(int aid : std::as_const(this->activitiesBIds))
		actBids+=CustomFETString::number(aid)+translatedCommaSpace();
	actBids.chop(translatedCommaSpace().size());

	QString timeslots=QString("");
	for(int i=0; i<this->oDays.count(); i++)
		timeslots+=r.daysOfTheWeek[oDays.at(i)]+QString(" ")+r.hoursOfTheDay[oHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Two sets of activities have the same sections"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities in the first set=%1").arg(QString::number(this->activitiesAIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesAIds)){
		s+=tr("First set: activity with id=%1 (%2)", "An activity in the first set of activities of this constraint. "
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Number of activities in the second set=%1").arg(QString::number(this->activitiesBIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesBIds)){
		s+=tr("Second set: activity with id=%1 (%2)", "An activity in the second set of activities of this constraint. "
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Exception time slots: %1", "The selected time slots constitute an exception").arg(timeslots); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTwoSetsOfActivitiesSameSections::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	///////////////////

	assert(_activitiesAIndices.count()==_activitiesBIndices.count());
	for(int i=0; i<_activitiesAIndices.count(); i++){
		int a1=_activitiesAIndices.at(i);
		int b1=_activitiesBIndices.at(i);
		
		if(c.times[a1]==UNALLOCATED_TIME)
			continue;
		if(c.times[b1]==UNALLOCATED_TIME)
			continue;
		
		bool toCheck=true;
		
		for(int t=c.times[a1]; t<c.times[a1]+r.internalActivitiesList[a1].duration*r.nDaysPerWeek; t+=r.nDaysPerWeek){
			if(_oSlotsSet.contains(t)){
				toCheck=false;
				break;
			}
		}
		if(!toCheck)
			continue;

		for(int t=c.times[b1]; t<c.times[b1]+r.internalActivitiesList[b1].duration*r.nDaysPerWeek; t+=r.nDaysPerWeek){
			if(_oSlotsSet.contains(t)){
				toCheck=false;
				break;
			}
		}
		if(!toCheck)
			continue;
		
		for(int j=0; j<_activitiesAIndices.count(); j++){
			if(i==j)
				continue;
			int a2=_activitiesAIndices.at(j);
			int b2=_activitiesBIndices.at(j);

			if(c.times[a2]==UNALLOCATED_TIME)
				continue;
			if(c.times[b2]==UNALLOCATED_TIME)
				continue;
			
			for(int t=c.times[a2]; t<c.times[a2]+r.internalActivitiesList[a2].duration*r.nDaysPerWeek; t+=r.nDaysPerWeek){
				if(_oSlotsSet.contains(t)){
					toCheck=false;
					break;
				}
			}
			if(!toCheck)
				continue;

			for(int t=c.times[b2]; t<c.times[b2]+r.internalActivitiesList[b2].duration*r.nDaysPerWeek; t+=r.nDaysPerWeek){
				if(_oSlotsSet.contains(t)){
					toCheck=false;
					break;
				}
			}
			if(!toCheck)
				continue;

			assert((c.times[a1]==c.times[a2] && c.times[b1]==c.times[b2]) || (c.times[a1]!=c.times[a2] && c.times[b1]!=c.times[b2]));
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintTwoSetsOfActivitiesSameSections::removeUseless(Rules& r)
{
	QList<int> newAActs;

	for(int aid : std::as_const(activitiesAIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newAActs.append(aid);
	}

	activitiesAIds=newAActs;

	QList<int> newBActs;

	for(int aid : std::as_const(activitiesBIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newBActs.append(aid);
	}

	activitiesBIds=newBActs;

	r.internalStructureComputed=false;
}

void ConstraintTwoSetsOfActivitiesSameSections::recomputeActivitiesSets()
{
	activitiesAIdsSet=QSet<int>(activitiesAIds.constBegin(), activitiesAIds.constEnd());
	activitiesBIdsSet=QSet<int>(activitiesBIds.constBegin(), activitiesBIds.constEnd());
}

bool ConstraintTwoSetsOfActivitiesSameSections::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesAIdsSet.contains(a->id) || activitiesBIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintTwoSetsOfActivitiesSameSections::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintTwoSetsOfActivitiesSameSections::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoSetsOfActivitiesSameSections::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoSetsOfActivitiesSameSections::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTwoSetsOfActivitiesSameSections::hasWrongDayOrHour(Rules& r)
{
	assert(oDays.count()==oHours.count());

	for(int i=0; i<oDays.count(); i++)
		if(oDays.at(i)<0 || oDays.at(i)>=r.nDaysPerWeek
		 || oHours.at(i)<0 || oHours.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintTwoSetsOfActivitiesSameSections::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	return true;
}

bool ConstraintTwoSetsOfActivitiesSameSections::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));

	assert(oDays.count()==oHours.count());

	QList<int> newDays;
	QList<int> newHours;

	for(int i=0; i<oDays.count(); i++)
		if(oDays.at(i)>=0 && oDays.at(i)<r.nDaysPerWeek
		 && oHours.at(i)>=0 && oHours.at(i)<r.nHoursPerDay){
			newDays.append(oDays.at(i));
			newHours.append(oHours.at(i));
		}

	oDays=newDays;
	oHours=newHours;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;
}

ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots(double wp, const QString& sn, int maxsg, const QList<int>& d_L, const QList<int>& h_L)
	 : TimeConstraint(wp)
{
	this->students = sn;
	this->type=CONSTRAINT_STUDENTS_SET_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;

	this->maxSingleGaps=maxsg;

	this->selectedDays=d_L;
	this->selectedHours=h_L;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	StudentsSet* ss=r.studentsHash.value(students, nullptr);

	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set max single gaps in selected time slots is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	assert(ss!=nullptr);

	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);

	///
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students set max single gaps in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students set max single gaps in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students set max single gaps in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students set max single gaps in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////

	return true;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<Max_Single_Gaps>"+QString::number(maxSingleGaps)+"</Max_Single_Gaps>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::getDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students set max single gaps in selected time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();
	s+=tr("MSG:%1", "Max single gaps").arg(maxSingleGaps);s+=translatedCommaSpace();

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("STS: %1", "Selected time slots").arg(timeslots);

	return begin+s+end;
}

QString ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set must respect a maximum number of single gaps in the selected time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students=%1").arg(this->students);s+="\n";

	s+=tr("Maximum number of single gaps=%1").arg(maxSingleGaps);s+="\n";

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int sbg : std::as_const(this->iSubgroupsList)){
		int cnt=0;
		assert(this->selectedDays.count()==this->selectedHours.count());
		for(int t=0; t<this->selectedDays.count(); t++){
			int d=this->selectedDays.at(t);
			int h=this->selectedHours.at(t);
			
			if(subgroupsMatrix[sbg][d][h]==0)
				if(h>0 && h<r.nHoursPerDay-1)
					if(subgroupsMatrix[sbg][d][h-1]>0 && subgroupsMatrix[sbg][d][h+1]>0)
						cnt++;
		}
		
		if(cnt>this->maxSingleGaps)
			nbroken++;
	}

	if(nbroken>0 && conflictsString!=nullptr){
		QString s;
		if(c.nPlacedActivities==r.nInternalActivities){
			s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
		}
		else{
			s=tr("Time constraint %1 broken for the partial timetable.").arg(this->getDescription(r));
			s+=" ";
			s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
		}
		
		dl.append(s);
		cl.append(weightPercentage/100.0);
		
		*conflictsString+= s+"\n";
	}

	assert(weightPercentage==100);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;
			
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetMaxSingleGapsInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;
	
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxSingleGaps=r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::ConstraintStudentsMaxSingleGapsInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;
}

ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::ConstraintStudentsMaxSingleGapsInSelectedTimeSlots(double wp, int maxsg, const QList<int>& d_L, const QList<int>& h_L)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_STUDENTS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;

	this->maxSingleGaps=maxsg;

	this->selectedDays=d_L;
	this->selectedHours=h_L;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students max single gaps in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students max single gaps in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students max single gaps in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint students max single gaps in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////

	return true;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintStudentsMaxSingleGapsInSelectedTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Max_Single_Gaps>"+QString::number(maxSingleGaps)+"</Max_Single_Gaps>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsMaxSingleGapsInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::getDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Students max single gaps in selected time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MSG:%1", "Max single gaps").arg(maxSingleGaps);s+=translatedCommaSpace();

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("STS: %1", "Selected time slots").arg(timeslots);

	return begin+s+end;
}

QString ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students must respect a maximum number of single gaps in the selected time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum number of single gaps=%1").arg(maxSingleGaps);s+="\n";

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int sbg=0; sbg<r.nInternalSubgroups; sbg++){
		int cnt=0;
		assert(this->selectedDays.count()==this->selectedHours.count());
		for(int t=0; t<this->selectedDays.count(); t++){
			int d=this->selectedDays.at(t);
			int h=this->selectedHours.at(t);
			
			if(subgroupsMatrix[sbg][d][h]==0)
				if(h>0 && h<r.nHoursPerDay-1)
					if(subgroupsMatrix[sbg][d][h-1]>0 && subgroupsMatrix[sbg][d][h+1]>0)
						cnt++;
		}
		
		if(cnt>this->maxSingleGaps)
			nbroken++;
	}

	if(nbroken>0 && conflictsString!=nullptr){
		QString s;
		if(c.nPlacedActivities==r.nInternalActivities){
			s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
		}
		else{
			s=tr("Time constraint %1 broken for the partial timetable.").arg(this->getDescription(r));
			s+=" ";
			s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
		}
		
		dl.append(s);
		cl.append(weightPercentage/100.0);
		
		*conflictsString+= s+"\n";
	}

	assert(weightPercentage==100);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;
			
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsMaxSingleGapsInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;
	
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxSingleGaps=r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::ConstraintTeachersMaxSingleGapsInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;
}

ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::ConstraintTeachersMaxSingleGapsInSelectedTimeSlots(double wp, int maxsg, const QList<int>& d_L, const QList<int>& h_L)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_TEACHERS_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;

	this->maxSingleGaps=maxsg;

	this->selectedDays=d_L;
	this->selectedHours=h_L;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teachers max single gaps in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teachers max single gaps in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teachers max single gaps in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teachers max single gaps in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////

	return true;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintTeachersMaxSingleGapsInSelectedTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Max_Single_Gaps>"+QString::number(maxSingleGaps)+"</Max_Single_Gaps>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxSingleGapsInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::getDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teachers max single gaps in selected time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MSG:%1", "Max single gaps").arg(maxSingleGaps);s+=translatedCommaSpace();

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("STS: %1", "Selected time slots").arg(timeslots);

	return begin+s+end;
}

QString ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect a maximum number of single gaps in the selected time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Maximum number of single gaps=%1").arg(maxSingleGaps);s+="\n";

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int tch=0; tch<r.nInternalTeachers; tch++){
		int cnt=0;
		assert(this->selectedDays.count()==this->selectedHours.count());
		for(int t=0; t<this->selectedDays.count(); t++){
			int d=this->selectedDays.at(t);
			int h=this->selectedHours.at(t);
			
			if(teachersMatrix[tch][d][h]==0)
				if(h>0 && h<r.nHoursPerDay-1)
					if(teachersMatrix[tch][d][h-1]>0 && teachersMatrix[tch][d][h+1]>0)
						cnt++;
		}
		
		if(cnt>this->maxSingleGaps)
			nbroken++;
	}

	if(nbroken>0 && conflictsString!=nullptr){
		QString s;
		if(c.nPlacedActivities==r.nInternalActivities){
			s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
		}
		else{
			s=tr("Time constraint %1 broken for the partial timetable.").arg(this->getDescription(r));
			s+=" ";
			s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
		}
		
		dl.append(s);
		cl.append(weightPercentage/100.0);
		
		*conflictsString+= s+"\n";
	}

	assert(weightPercentage==100);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;
			
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxSingleGapsInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;
	
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxSingleGaps=r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::ConstraintTeacherMaxSingleGapsInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;
}

ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::ConstraintTeacherMaxSingleGapsInSelectedTimeSlots(double wp, const QString& tn, int maxsg, const QList<int>& d_L, const QList<int>& h_L)
	 : TimeConstraint(wp)
{
	this->type=CONSTRAINT_TEACHER_MAX_SINGLE_GAPS_IN_SELECTED_TIME_SLOTS;

	this->teacher=tn;

	this->maxSingleGaps=maxsg;

	this->selectedDays=d_L;
	this->selectedHours=h_L;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	teacher_ID=r.teachersHash.value(teacher, -1);

	if(this->teacher_ID<0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher max single gaps in selected time slots is wrong because it refers to nonexistent teacher."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(this->teacher_ID>=0);

	assert(this->selectedDays.count()==this->selectedHours.count());

	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teacher max single gaps in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teacher max single gaps in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teacher max single gaps in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint teacher max single gaps in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////

	return true;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintTeacherMaxSingleGapsInSelectedTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Teacher>"+protect(this->teacher)+"</Teacher>\n";

	s+=IL3+"<Max_Single_Gaps>"+QString::number(maxSingleGaps)+"</Max_Single_Gaps>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxSingleGapsInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::getDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString begin=QString("");
	if(!active)
		begin="X - ";

	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString s=tr("Teacher max single gaps in selected time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacher);s+=translatedCommaSpace();
	s+=tr("MSG:%1", "Max single gaps").arg(maxSingleGaps);s+=translatedCommaSpace();

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("STS: %1", "Selected time slots").arg(timeslots);

	return begin+s+end;
}

QString ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::getDetailedDescription(Rules& r){
	Q_UNUSED(r);

	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect a maximum number of single gaps in the selected time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacher);s+="\n";

	s+=tr("Maximum number of single gaps=%1").arg(maxSingleGaps);s+="\n";

	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());

	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	
	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>&dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	int cnt=0;
	assert(this->selectedDays.count()==this->selectedHours.count());
	for(int t=0; t<this->selectedDays.count(); t++){
		int d=this->selectedDays.at(t);
		int h=this->selectedHours.at(t);
		
		if(teachersMatrix[this->teacher_ID][d][h]==0)
			if(h>0 && h<r.nHoursPerDay-1)
				if(teachersMatrix[this->teacher_ID][d][h-1]>0 && teachersMatrix[this->teacher_ID][d][h+1]>0)
					cnt++;
	}
	
	if(cnt>this->maxSingleGaps)
		nbroken++;

	if(nbroken>0 && conflictsString!=nullptr){
		QString s;
		if(c.nPlacedActivities==r.nInternalActivities){
			s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
		}
		else{
			s=tr("Time constraint %1 broken for the partial timetable.").arg(this->getDescription(r));
			s+=" ";
			s+=tr("Conflicts factor increase=%1").arg(CustomFETString::numberPlusTwoDigitsPrecision(nbroken*weightPercentage/100));
		}
		
		dl.append(s);
		cl.append(weightPercentage/100.0);
		
		*conflictsString+= s+"\n";
	}

	assert(weightPercentage==100);

	if(c.nPlacedActivities==r.nInternalActivities)
		if(weightPercentage==100)
			assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	if(this->teacher==t->name)
		return true;

	return false;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;
			
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxSingleGapsInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;
	
	if(maxSingleGaps>r.nDaysPerWeek*r.nHoursPerDay)
		maxSingleGaps=r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherMaxHoursPerTerm::ConstraintTeacherMaxHoursPerTerm()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_MAX_HOURS_PER_TERM;
}

ConstraintTeacherMaxHoursPerTerm::ConstraintTeacherMaxHoursPerTerm(double wp, int maxht, const QString& tn)
	 : TimeConstraint(wp)
{
	this->teacherName = tn;
	this->maxHoursPerTerm=maxht;
	this->type=CONSTRAINT_TEACHER_MAX_HOURS_PER_TERM;
}

bool ConstraintTeacherMaxHoursPerTerm::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);

	//this->teacher_ID=r.searchTeacher(this->teacherName);
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);
	return true;
}

bool ConstraintTeacherMaxHoursPerTerm::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherMaxHoursPerTerm::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherMaxHoursPerTerm>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Max_Hours_Per_Term>"+CustomFETString::number(this->maxHoursPerTerm)+"</Max_Hours_Per_Term>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherMaxHoursPerTerm>\n";
	return s;
}

QString ConstraintTeacherMaxHoursPerTerm::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teacher max hours per term");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();
	s+=tr("MHPT:%1", "Max hours per term").arg(this->maxHoursPerTerm);

	return begin+s+end;
}

QString ConstraintTeacherMaxHoursPerTerm::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher must respect the maximum number of hours per term");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";
	s+=tr("Maximum hours per term=%1").arg(this->maxHoursPerTerm);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherMaxHoursPerTerm::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	int t=this->teacher_ID;
	
	for(int term=0; term<r.nTerms; term++){
		int nh=0;

		for(int d=term*r.nDaysPerTerm; d<(term+1)*r.nDaysPerTerm; d++)
			for(int h=0; h<r.nHoursPerDay; h++)
				nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;

		if(nh>this->maxHoursPerTerm)
			nbroken+=nh-this->maxHoursPerTerm;
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherMaxHoursPerTerm::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherMaxHoursPerTerm::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherMaxHoursPerTerm::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursPerTerm::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursPerTerm::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherMaxHoursPerTerm::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursPerTerm>r.nDaysPerTerm*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeacherMaxHoursPerTerm::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherMaxHoursPerTerm::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursPerTerm>r.nDaysPerTerm*r.nHoursPerDay)
		maxHoursPerTerm=r.nDaysPerTerm*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersMaxHoursPerTerm::ConstraintTeachersMaxHoursPerTerm()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_PER_TERM;
}

ConstraintTeachersMaxHoursPerTerm::ConstraintTeachersMaxHoursPerTerm(double wp, int maxht)
	 : TimeConstraint(wp)
{
	this->maxHoursPerTerm=maxht;
	this->type=CONSTRAINT_TEACHERS_MAX_HOURS_PER_TERM;
}

bool ConstraintTeachersMaxHoursPerTerm::computeInternalStructure(QWidget* parent, Rules& r)
{
	Q_UNUSED(parent);
	Q_UNUSED(r);

	return true;
}

bool ConstraintTeachersMaxHoursPerTerm::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersMaxHoursPerTerm::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersMaxHoursPerTerm>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Max_Hours_Per_Term>"+CustomFETString::number(this->maxHoursPerTerm)+"</Max_Hours_Per_Term>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersMaxHoursPerTerm>\n";
	return s;
}

QString ConstraintTeachersMaxHoursPerTerm::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s=tr("Teachers max hours per term");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("MHPT:%1", "Max hours per term").arg(this->maxHoursPerTerm);

	return begin+s+end;
}

QString ConstraintTeachersMaxHoursPerTerm::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers must respect the maximum number of hours per term");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Maximum hours per term=%1").arg(this->maxHoursPerTerm);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersMaxHoursPerTerm::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	Q_UNUSED(cl);
	Q_UNUSED(dl);
	Q_UNUSED(conflictsString);

	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int t=0; t<r.nInternalTeachers; t++){
		for(int term=0; term<r.nTerms; term++){
			int nh=0;

			for(int d=term*r.nDaysPerTerm; d<(term+1)*r.nDaysPerTerm; d++)
				for(int h=0; h<r.nHoursPerDay; h++)
					nh += teachersMatrix[t][d][h]>=1 ? 1 : 0;

			if(nh>this->maxHoursPerTerm)
				nbroken+=nh-this->maxHoursPerTerm;
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersMaxHoursPerTerm::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersMaxHoursPerTerm::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersMaxHoursPerTerm::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursPerTerm::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursPerTerm::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersMaxHoursPerTerm::hasWrongDayOrHour(Rules& r)
{
	if(maxHoursPerTerm>r.nDaysPerTerm*r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintTeachersMaxHoursPerTerm::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersMaxHoursPerTerm::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	if(maxHoursPerTerm>r.nDaysPerTerm*r.nHoursPerDay)
		maxHoursPerTerm=r.nDaysPerTerm*r.nHoursPerDay;

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots(double wp, const QString& teacher,
 const QList<int>& sd1, const QList<int>& sh1, const QList<int>& sd2, const QList<int>& sh2)
 : TimeConstraint(wp)
 {
	this->teacherName=teacher;
	this->selectedDays1=sd1;
	this->selectedHours1=sh1;
	this->selectedDays2=sd2;
	this->selectedHours2=sh2;

	this->type=CONSTRAINT_TEACHER_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	assert(selectedDays1.count()==selectedHours1.count());
	assert(selectedDays2.count()==selectedHours2.count());

	if(selectedDays1.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive sets of time slots is wrong because the first set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(selectedDays2.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive sets of time slots is wrong because the second set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	set1.clear();
	list1.clear();
	set2.clear();
	list2.clear();
	for(int k=0; k<selectedDays1.count(); k++){
		int d=selectedDays1.at(k);
		int h=selectedHours1.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set1.insert(d+h*r.nDaysPerWeek);
			list1.append(d+h*r.nDaysPerWeek);
		}
	}
	for(int k=0; k<selectedDays2.count(); k++){
		int d=selectedDays2.at(k);
		int h=selectedHours2.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set2.insert(d+h*r.nDaysPerWeek);
			list2.append(d+h*r.nDaysPerWeek);
		}
	}

	if(set1.intersects(set2)){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher pair of mutually exclusive sets of time slots is wrong because the two sets of time slots have at least one common time slot. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	return true;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots_in_First_Set>"+QString::number(this->selectedDays1.count())+"</Number_of_Selected_Time_Slots_in_First_Set>\n";
	for(int i=0; i<this->selectedDays1.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_First_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays1.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours1.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_First_Set>\n";
	}

	s+=IL3+"<Number_of_Selected_Time_Slots_in_Second_Set>"+QString::number(this->selectedDays2.count())+"</Number_of_Selected_Time_Slots_in_Second_Set>\n";
	for(int i=0; i<this->selectedDays2.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_Second_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays2.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours2.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_Second_Set>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	return s;
}

QString ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teacher pair of mutually exclusive sets of time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("FSoSTS:%1", "First set of selected time slots").arg(timeslots1);s+=translatedCommaSpace();
	s+=tr("SSoSTS:%1", "Second set of selected time slots").arg(timeslots2);

	return begin+s+end;
}

QString ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher has a pair of mutually exclusive sets of time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("First set of selected time slots=%1").arg(timeslots1);s+="\n";
	s+=tr("Second set of selected time slots=%1").arg(timeslots2);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	int i=this->teacher_ID;

	for(int k1=0; k1<selectedDays1.count(); k1++){
		int day1=selectedDays1.at(k1);
		int hour1=selectedHours1.at(k1);
		
		if(teachersMatrix[i][day1][hour1]>0){
			for(int k2=0; k2<selectedDays2.count(); k2++){
				int day2=selectedDays2.at(k2);
				int hour2=selectedHours2.at(k2);

				if(teachersMatrix[i][day2][hour2]>0){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr(
						 "Time constraint teacher pair of mutually exclusive sets of time slots broken for teacher %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
						 .arg(r.internalTeachersList[i]->name)
						 .arg(r.daysOfTheWeek[day1])
						 .arg(r.hoursOfTheDay[hour1])
						 .arg(r.daysOfTheWeek[day2])
						 .arg(r.hoursOfTheDay[hour2])
						 )
						 +" "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
						
						dl.append(s);
						cl.append(weightPercentage/100);
						
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::hasWrongDayOrHour(Rules& r)
{
	for(int k1=0; k1<selectedDays1.count(); k1++){
		int day1=selectedDays1.at(k1);
		int hour1=selectedHours1.at(k1);
		
		if(day1>=r.nDaysPerWeek)
			return true;
		if(hour1>=r.nHoursPerDay)
			return true;
	}
	
	for(int k2=0; k2<selectedDays2.count(); k2++){
		int day2=selectedDays2.at(k2);
		int hour2=selectedHours2.at(k2);
		
		if(day2>=r.nDaysPerWeek)
			return true;
		if(hour2>=r.nHoursPerDay)
			return true;
	}
	
	return false;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherPairOfMutuallyExclusiveSetsOfTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays1.count()==selectedHours1.count());
	
	QList<int> newDays1;
	QList<int> newHours1;
	
	for(int i=0; i<selectedDays1.count(); i++)
		if(selectedDays1.at(i)<r.nDaysPerWeek && selectedHours1.at(i)<r.nHoursPerDay){
			newDays1.append(selectedDays1.at(i));
			newHours1.append(selectedHours1.at(i));
		}
	
	selectedDays1=newDays1;
	selectedHours1=newHours1;
	///////
	assert(selectedDays2.count()==selectedHours2.count());
	
	QList<int> newDays2;
	QList<int> newHours2;
	
	for(int i=0; i<selectedDays2.count(); i++)
		if(selectedDays2.at(i)<r.nDaysPerWeek && selectedHours2.at(i)<r.nHoursPerDay){
			newDays2.append(selectedDays2.at(i));
			newHours2.append(selectedHours2.at(i));
		}
	
	selectedDays2=newDays2;
	selectedHours2=newHours2;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots(double wp,
 const QList<int>& sd1, const QList<int>& sh1, const QList<int>& sd2, const QList<int>& sh2)
 : TimeConstraint(wp)
 {
	this->selectedDays1=sd1;
	this->selectedHours1=sh1;
	this->selectedDays2=sd2;
	this->selectedHours2=sh2;

	this->type=CONSTRAINT_TEACHERS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	assert(selectedDays1.count()==selectedHours1.count());
	assert(selectedDays2.count()==selectedHours2.count());

	if(selectedDays1.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive sets of time slots is wrong because the first set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(selectedDays2.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive sets of time slots is wrong because the second set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	set1.clear();
	list1.clear();
	set2.clear();
	list2.clear();
	for(int k=0; k<selectedDays1.count(); k++){
		int d=selectedDays1.at(k);
		int h=selectedHours1.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set1.insert(d+h*r.nDaysPerWeek);
			list1.append(d+h*r.nDaysPerWeek);
		}
	}
	for(int k=0; k<selectedDays2.count(); k++){
		int d=selectedDays2.at(k);
		int h=selectedHours2.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set2.insert(d+h*r.nDaysPerWeek);
			list2.append(d+h*r.nDaysPerWeek);
		}
	}

	if(set1.intersects(set2)){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers pair of mutually exclusive sets of time slots is wrong because the two sets of time slots have at least one common time slot. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	return true;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots_in_First_Set>"+QString::number(this->selectedDays1.count())+"</Number_of_Selected_Time_Slots_in_First_Set>\n";
	for(int i=0; i<this->selectedDays1.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_First_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays1.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours1.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_First_Set>\n";
	}

	s+=IL3+"<Number_of_Selected_Time_Slots_in_Second_Set>"+QString::number(this->selectedDays2.count())+"</Number_of_Selected_Time_Slots_in_Second_Set>\n";
	for(int i=0; i<this->selectedDays2.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_Second_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays2.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours2.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_Second_Set>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	return s;
}

QString ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teachers pair of mutually exclusive sets of time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("FSoSTS:%1", "First set of selected time slots").arg(timeslots1);s+=translatedCommaSpace();
	s+=tr("SSoSTS:%1", "Second set of selected time slots").arg(timeslots2);

	return begin+s+end;
}

QString ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers have a pair of mutually exclusive sets of time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("First set of selected time slots=%1").arg(timeslots1);s+="\n";
	s+=tr("Second set of selected time slots=%1").arg(timeslots2);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i=0; i<r.nInternalTeachers; i++){
		for(int k1=0; k1<selectedDays1.count(); k1++){
			int day1=selectedDays1.at(k1);
			int hour1=selectedHours1.at(k1);
			
			if(teachersMatrix[i][day1][hour1]>0){
				for(int k2=0; k2<selectedDays2.count(); k2++){
					int day2=selectedDays2.at(k2);
					int hour2=selectedHours2.at(k2);

					if(teachersMatrix[i][day2][hour2]>0){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint teachers pair of mutually exclusive sets of time slots broken for teacher %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
							 .arg(r.internalTeachersList[i]->name)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.hoursOfTheDay[hour1])
							 .arg(r.daysOfTheWeek[day2])
							 .arg(r.hoursOfTheDay[hour2])
							 )
							 +" "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return true;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::hasWrongDayOrHour(Rules& r)
{
	for(int k1=0; k1<selectedDays1.count(); k1++){
		int day1=selectedDays1.at(k1);
		int hour1=selectedHours1.at(k1);
		
		if(day1>=r.nDaysPerWeek)
			return true;
		if(hour1>=r.nHoursPerDay)
			return true;
	}
	
	for(int k2=0; k2<selectedDays2.count(); k2++){
		int day2=selectedDays2.at(k2);
		int hour2=selectedHours2.at(k2);
		
		if(day2>=r.nDaysPerWeek)
			return true;
		if(hour2>=r.nHoursPerDay)
			return true;
	}
	
	return false;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersPairOfMutuallyExclusiveSetsOfTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays1.count()==selectedHours1.count());
	
	QList<int> newDays1;
	QList<int> newHours1;
	
	for(int i=0; i<selectedDays1.count(); i++)
		if(selectedDays1.at(i)<r.nDaysPerWeek && selectedHours1.at(i)<r.nHoursPerDay){
			newDays1.append(selectedDays1.at(i));
			newHours1.append(selectedHours1.at(i));
		}
	
	selectedDays1=newDays1;
	selectedHours1=newHours1;
	///////
	assert(selectedDays2.count()==selectedHours2.count());
	
	QList<int> newDays2;
	QList<int> newHours2;
	
	for(int i=0; i<selectedDays2.count(); i++)
		if(selectedDays2.at(i)<r.nDaysPerWeek && selectedHours2.at(i)<r.nHoursPerDay){
			newDays2.append(selectedDays2.at(i));
			newHours2.append(selectedHours2.at(i));
		}
	
	selectedDays2=newDays2;
	selectedHours2=newHours2;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots(double wp, const QString& s,
 const QList<int>& sd1, const QList<int>& sh1, const QList<int>& sd2, const QList<int>& sh2)
 : TimeConstraint(wp)
 {
	this->students=s;

	this->selectedDays1=sd1;
	this->selectedHours1=sh1;
	this->selectedDays2=sd2;
	this->selectedHours2=sh2;

	this->type=CONSTRAINT_STUDENTS_SET_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive sets of time slots is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	assert(selectedDays1.count()==selectedHours1.count());
	assert(selectedDays2.count()==selectedHours2.count());

	if(selectedDays1.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive sets of time slots is wrong because the first set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(selectedDays2.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive sets of time slots is wrong because the second set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	set1.clear();
	list1.clear();
	set2.clear();
	list2.clear();
	for(int k=0; k<selectedDays1.count(); k++){
		int d=selectedDays1.at(k);
		int h=selectedHours1.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set1.insert(d+h*r.nDaysPerWeek);
			list1.append(d+h*r.nDaysPerWeek);
		}
	}
	for(int k=0; k<selectedDays2.count(); k++){
		int d=selectedDays2.at(k);
		int h=selectedHours2.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set2.insert(d+h*r.nDaysPerWeek);
			list2.append(d+h*r.nDaysPerWeek);
		}
	}

	if(set1.intersects(set2)){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set pair of mutually exclusive sets of time slots is wrong because the two sets of time slots have at least one common time slot. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	assert(ss!=nullptr);
	
	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);

	return true;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots_in_First_Set>"+QString::number(this->selectedDays1.count())+"</Number_of_Selected_Time_Slots_in_First_Set>\n";
	for(int i=0; i<this->selectedDays1.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_First_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays1.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours1.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_First_Set>\n";
	}

	s+=IL3+"<Number_of_Selected_Time_Slots_in_Second_Set>"+QString::number(this->selectedDays2.count())+"</Number_of_Selected_Time_Slots_in_Second_Set>\n";
	for(int i=0; i<this->selectedDays2.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_Second_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays2.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours2.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_Second_Set>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	return s;
}

QString ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Students set pair of mutually exclusive sets of time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("FSoSTS:%1", "First set of selected time slots").arg(timeslots1);s+=translatedCommaSpace();
	s+=tr("SSoSTS:%1", "Second set of selected time slots").arg(timeslots2);

	return begin+s+end;
}

QString ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set has a pair of mutually exclusive sets of time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Students=%1").arg(this->students);s+="\n";

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("First set of selected time slots=%1").arg(timeslots1);s+="\n";
	s+=tr("Second set of selected time slots=%1").arg(timeslots2);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i : std::as_const(this->iSubgroupsList)){
		for(int k1=0; k1<selectedDays1.count(); k1++){
			int day1=selectedDays1.at(k1);
			int hour1=selectedHours1.at(k1);
			
			if(subgroupsMatrix[i][day1][hour1]>0){
				for(int k2=0; k2<selectedDays2.count(); k2++){
					int day2=selectedDays2.at(k2);
					int hour2=selectedHours2.at(k2);

					if(subgroupsMatrix[i][day2][hour2]>0){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint students set pair of mutually exclusive sets of time slots broken for subgroup %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.hoursOfTheDay[hour1])
							 .arg(r.daysOfTheWeek[day2])
							 .arg(r.hoursOfTheDay[hour2])
							 )
							 +" "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::hasWrongDayOrHour(Rules& r)
{
	for(int k1=0; k1<selectedDays1.count(); k1++){
		int day1=selectedDays1.at(k1);
		int hour1=selectedHours1.at(k1);
		
		if(day1>=r.nDaysPerWeek)
			return true;
		if(hour1>=r.nHoursPerDay)
			return true;
	}
	
	for(int k2=0; k2<selectedDays2.count(); k2++){
		int day2=selectedDays2.at(k2);
		int hour2=selectedHours2.at(k2);
		
		if(day2>=r.nDaysPerWeek)
			return true;
		if(hour2>=r.nHoursPerDay)
			return true;
	}
	
	return false;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetPairOfMutuallyExclusiveSetsOfTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays1.count()==selectedHours1.count());
	
	QList<int> newDays1;
	QList<int> newHours1;
	
	for(int i=0; i<selectedDays1.count(); i++)
		if(selectedDays1.at(i)<r.nDaysPerWeek && selectedHours1.at(i)<r.nHoursPerDay){
			newDays1.append(selectedDays1.at(i));
			newHours1.append(selectedHours1.at(i));
		}
	
	selectedDays1=newDays1;
	selectedHours1=newHours1;
	///////
	assert(selectedDays2.count()==selectedHours2.count());
	
	QList<int> newDays2;
	QList<int> newHours2;
	
	for(int i=0; i<selectedDays2.count(); i++)
		if(selectedDays2.at(i)<r.nDaysPerWeek && selectedHours2.at(i)<r.nHoursPerDay){
			newDays2.append(selectedDays2.at(i));
			newHours2.append(selectedHours2.at(i));
		}
	
	selectedDays2=newDays2;
	selectedHours2=newHours2;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots(double wp,
 const QList<int>& sd1, const QList<int>& sh1, const QList<int>& sd2, const QList<int>& sh2)
 : TimeConstraint(wp)
 {
	this->selectedDays1=sd1;
	this->selectedHours1=sh1;
	this->selectedDays2=sd2;
	this->selectedHours2=sh2;

	this->type=CONSTRAINT_STUDENTS_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	assert(selectedDays1.count()==selectedHours1.count());
	assert(selectedDays2.count()==selectedHours2.count());

	if(selectedDays1.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive sets of time slots is wrong because the first set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(selectedDays2.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive sets of time slots is wrong because the second set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	set1.clear();
	list1.clear();
	set2.clear();
	list2.clear();
	for(int k=0; k<selectedDays1.count(); k++){
		int d=selectedDays1.at(k);
		int h=selectedHours1.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set1.insert(d+h*r.nDaysPerWeek);
			list1.append(d+h*r.nDaysPerWeek);
		}
	}
	for(int k=0; k<selectedDays2.count(); k++){
		int d=selectedDays2.at(k);
		int h=selectedHours2.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			set2.insert(d+h*r.nDaysPerWeek);
			list2.append(d+h*r.nDaysPerWeek);
		}
	}

	if(set1.intersects(set2)){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students pair of mutually exclusive sets of time slots is wrong because the two sets of time slots have at least one common time slot. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	return true;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Selected_Time_Slots_in_First_Set>"+QString::number(this->selectedDays1.count())+"</Number_of_Selected_Time_Slots_in_First_Set>\n";
	for(int i=0; i<this->selectedDays1.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_First_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays1.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours1.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_First_Set>\n";
	}

	s+=IL3+"<Number_of_Selected_Time_Slots_in_Second_Set>"+QString::number(this->selectedDays2.count())+"</Number_of_Selected_Time_Slots_in_Second_Set>\n";
	for(int i=0; i<this->selectedDays2.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_Second_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays2.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours2.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_Second_Set>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	return s;
}

QString ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Students pair of mutually exclusive sets of time slots");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("FSoSTS:%1", "First set of selected time slots").arg(timeslots1);s+=translatedCommaSpace();
	s+=tr("SSoSTS:%1", "Second set of selected time slots").arg(timeslots2);

	return begin+s+end;
}

QString ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students have a pair of mutually exclusive sets of time slots");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("First set of selected time slots=%1").arg(timeslots1);s+="\n";
	s+=tr("Second set of selected time slots=%1").arg(timeslots2);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i=0; i<r.nInternalSubgroups; i++){
		for(int k1=0; k1<selectedDays1.count(); k1++){
			int day1=selectedDays1.at(k1);
			int hour1=selectedHours1.at(k1);
			
			if(subgroupsMatrix[i][day1][hour1]>0){
				for(int k2=0; k2<selectedDays2.count(); k2++){
					int day2=selectedDays2.at(k2);
					int hour2=selectedHours2.at(k2);

					if(subgroupsMatrix[i][day2][hour2]>0){
						nbroken++;

						if(conflictsString!=nullptr){
							QString s=(tr(
							 "Time constraint students pair of mutually exclusive sets of time slots broken for subgroup %1, first time slot's day %2, first time slot's hour %3, second time slot's day %4, second time slot's hour %5.")
							 .arg(r.internalSubgroupsList[i]->name)
							 .arg(r.daysOfTheWeek[day1])
							 .arg(r.hoursOfTheDay[hour1])
							 .arg(r.daysOfTheWeek[day2])
							 .arg(r.hoursOfTheDay[hour2])
							 )
							 +" "
							 +
							 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
							
							dl.append(s);
							cl.append(weightPercentage/100);
							
							*conflictsString+= s+"\n";
						}
					}
				}
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return true;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::hasWrongDayOrHour(Rules& r)
{
	for(int k1=0; k1<selectedDays1.count(); k1++){
		int day1=selectedDays1.at(k1);
		int hour1=selectedHours1.at(k1);
		
		if(day1>=r.nDaysPerWeek)
			return true;
		if(hour1>=r.nHoursPerDay)
			return true;
	}
	
	for(int k2=0; k2<selectedDays2.count(); k2++){
		int day2=selectedDays2.at(k2);
		int hour2=selectedHours2.at(k2);
		
		if(day2>=r.nDaysPerWeek)
			return true;
		if(hour2>=r.nHoursPerDay)
			return true;
	}
	
	return false;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsPairOfMutuallyExclusiveSetsOfTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays1.count()==selectedHours1.count());
	
	QList<int> newDays1;
	QList<int> newHours1;
	
	for(int i=0; i<selectedDays1.count(); i++)
		if(selectedDays1.at(i)<r.nDaysPerWeek && selectedHours1.at(i)<r.nHoursPerDay){
			newDays1.append(selectedDays1.at(i));
			newHours1.append(selectedHours1.at(i));
		}
	
	selectedDays1=newDays1;
	selectedHours1=newHours1;
	///////
	assert(selectedDays2.count()==selectedHours2.count());
	
	QList<int> newDays2;
	QList<int> newHours2;
	
	for(int i=0; i<selectedDays2.count(); i++)
		if(selectedDays2.at(i)<r.nDaysPerWeek && selectedHours2.at(i)<r.nHoursPerDay){
			newDays2.append(selectedDays2.at(i));
			newHours2.append(selectedHours2.at(i));
		}
	
	selectedDays2=newDays2;
	selectedHours2=newHours2;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots(double wp, const QList<int>& a_L,
 const QList<int>& sd1, const QList<int>& sh1, const QList<int>& sd2, const QList<int>& sh2)
 : TimeConstraint(wp)
 {
	this->activitiesIds=a_L;

	this->selectedDays1=sd1;
	this->selectedHours1=sh1;
	this->selectedDays2=sd2;
	this->selectedHours2=sh2;
	
	this->type=CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_SETS_OF_TIME_SLOTS;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}
	
	if(this->_activitiesIndices.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
	
	assert(selectedDays1.count()==selectedHours1.count());
	assert(selectedDays2.count()==selectedHours2.count());

	if(selectedDays1.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive sets of time slots is wrong because the first set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(selectedDays2.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive sets of time slots is wrong because the second set of selected time slots is empty. Please correct"
		 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	timeSlotsSet1.clear();
	timeSlotsList1.clear();
	timeSlotsSet2.clear();
	timeSlotsList2.clear();
	for(int k=0; k<selectedDays1.count(); k++){
		int d=selectedDays1.at(k);
		int h=selectedHours1.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			timeSlotsSet1.insert(d+h*r.nDaysPerWeek);
			timeSlotsList1.append(d+h*r.nDaysPerWeek);
		}
	}
	for(int k=0; k<selectedDays2.count(); k++){
		int d=selectedDays2.at(k);
		int h=selectedHours2.at(k);
		if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
			timeSlotsSet2.insert(d+h*r.nDaysPerWeek);
			timeSlotsList2.append(d+h*r.nDaysPerWeek);
		}
	}

	if(timeSlotsSet1.intersects(timeSlotsSet2)){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive sets of time slots is wrong because the two sets of time slots have at least one common time slot. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	return true;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::getXmlDescription(Rules& r)
{

	QString s=IL2+"<ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";
	
	s+=IL3+"<Number_of_Selected_Time_Slots_in_First_Set>"+QString::number(this->selectedDays1.count())+"</Number_of_Selected_Time_Slots_in_First_Set>\n";
	for(int i=0; i<this->selectedDays1.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_First_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays1.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours1.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_First_Set>\n";
	}

	s+=IL3+"<Number_of_Selected_Time_Slots_in_Second_Set>"+QString::number(this->selectedDays2.count())+"</Number_of_Selected_Time_Slots_in_Second_Set>\n";
	for(int i=0; i<this->selectedDays2.count(); i++){
		s+=IL3+"<Selected_Time_Slot_in_Second_Set>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays2.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours2.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot_in_Second_Set>\n";
	}
	
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots>\n";
	return s;
}

QString ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
	
	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	QString s=tr("Activities pair of mutually exclusive sets of time slots, WP:%1%, NA:%2, A: %3, FSoSTS: %4, SSoSTS:%5",
	 "Constraint description. WP means weight percentage, NA means the number of activities, A means activities list,"
	 " FSoSTS means first set of selected time slots, SSoSTS means second set of selected time slots")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(timeslots1)
	 .arg(timeslots2);
	
	return begin+s+end;
}

QString ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities have a pair of mutually exclusive sets of time slots"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}

	QString timeslots1=QString("");
	for(int i=0; i<this->selectedDays1.count(); i++)
		timeslots1+=r.daysOfTheWeek[selectedDays1.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours1.at(i)]+translatedCommaSpace();
	timeslots1.chop(translatedCommaSpace().size());

	QString timeslots2=QString("");
	for(int i=0; i<this->selectedDays2.count(); i++)
		timeslots2+=r.daysOfTheWeek[selectedDays2.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours2.at(i)]+translatedCommaSpace();
	timeslots2.chop(translatedCommaSpace().size());

	s+=tr("First set of selected time slots=%1").arg(timeslots1);s+="\n";
	s+=tr("Second set of selected time slots=%1").arg(timeslots2);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	///////////////////
	Matrix2D<int> used;
	used.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			used[d][h]=-1;
	
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<act->duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				if(used[d][h+dur]==-1){
					used[d][h+dur]=ai;
				}
			}
		}
	}
	
	nbroken=0;

	for(int k1=0; k1<selectedDays1.count(); k1++){
		int day1=selectedDays1.at(k1);
		int hour1=selectedHours1.at(k1);
		
		if(used[day1][hour1]>=0){
			for(int k2=0; k2<selectedDays2.count(); k2++){
				int day2=selectedDays2.at(k2);
				int hour2=selectedHours2.at(k2);

				if(used[day2][hour2]>=0){
					nbroken++;

					if(conflictsString!=nullptr){
						QString s=(tr(
						 "Time constraint activities pair of mutually exclusive sets of time slots broken, at least two activities break it: Id %1 and Id %2, first time slot's day %3, first time slot's hour %4, second time slot's day %5, second time slot's hour %6.")
						 .arg(r.internalActivitiesList[used[day1][hour1]].id)
						 .arg(r.internalActivitiesList[used[day2][hour2]].id)
						 .arg(r.daysOfTheWeek[day1])
						 .arg(r.hoursOfTheDay[hour1])
						 .arg(r.daysOfTheWeek[day2])
						 .arg(r.hoursOfTheDay[hour2])
						 )
						 +" "
						 +
						 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
						
						dl.append(s);
						cl.append(weightPercentage/100);
						
						*conflictsString+= s+"\n";
					}
				}
			}
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::hasWrongDayOrHour(Rules& r)
{
	for(int k1=0; k1<selectedDays1.count(); k1++){
		int day1=selectedDays1.at(k1);
		int hour1=selectedHours1.at(k1);
		
		if(day1>=r.nDaysPerWeek)
			return true;
		if(hour1>=r.nHoursPerDay)
			return true;
	}
	
	for(int k2=0; k2<selectedDays2.count(); k2++){
		int day2=selectedDays2.at(k2);
		int hour2=selectedHours2.at(k2);
		
		if(day2>=r.nDaysPerWeek)
			return true;
		if(hour2>=r.nHoursPerDay)
			return true;
	}
	
	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveSetsOfTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays1.count()==selectedHours1.count());
	
	QList<int> newDays1;
	QList<int> newHours1;
	
	for(int i=0; i<selectedDays1.count(); i++)
		if(selectedDays1.at(i)<r.nDaysPerWeek && selectedHours1.at(i)<r.nHoursPerDay){
			newDays1.append(selectedDays1.at(i));
			newHours1.append(selectedHours1.at(i));
		}
	
	selectedDays1=newDays1;
	selectedHours1=newHours1;
	///////
	assert(selectedDays2.count()==selectedHours2.count());
	
	QList<int> newDays2;
	QList<int> newHours2;
	
	for(int i=0; i<selectedDays2.count(); i++)
		if(selectedDays2.at(i)<r.nDaysPerWeek && selectedHours2.at(i)<r.nHoursPerDay){
			newDays2.append(selectedDays2.at(i));
			newHours2.append(selectedHours2.at(i));
		}
	
	selectedDays2=newDays2;
	selectedHours2=newHours2;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots(double wp, const QList<int>& a_L,
 int d1, int h1, int d2, int h2) : TimeConstraint(wp)
{
	this->activitiesIds=a_L;

	this->day1=d1;
	this->hour1=h1;
	this->day2=d2;
	this->hour2=h2;
	
	this->type=CONSTRAINT_ACTIVITIES_PAIR_OF_MUTUALLY_EXCLUSIVE_TIME_SLOTS;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}
	
	if(this->_activitiesIndices.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
	
	if(this->day1 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive time slots is wrong because the first time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour1 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive time slots is wrong because the first time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->day2 >= r.nDaysPerWeek){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive time slots is wrong because the second time slot's day refers to a removed day. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	if(this->hour2 >= r.nHoursPerDay){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive time slots is wrong because the second time slot's hour refers to a removed hour. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	if(this->day1==this->day2 && this->hour1==this->hour2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities pair of mutually exclusive time slots is wrong because the two time slots are the same. Please correct"
		 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}
	
	return true;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::getXmlDescription(Rules& r)
{

	QString s=IL2+"<ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";

	s+=IL3+"<First_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day1])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour1])+"</Hour>\n";
	s+=IL3+"</First_Time_Slot>\n";

	s+=IL3+"<Second_Time_Slot>\n";
	s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->day2])+"</Day>\n";
	s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->hour2])+"</Hour>\n";
	s+=IL3+"</Second_Time_Slot>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots>\n";
	return s;
}

QString ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
	
	QString s=tr("Activities pair of mutually exclusive time slots, WP:%1%, NA:%2, A: %3, FTS: %4, STS:%5",
	 "Constraint description. WP means weight percentage, NA means the number of activities, A means activities list,"
	 " FTS means first time slot, STS means second time slot")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1])
	 .arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);
	
	return begin+s+end;
}

QString ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities have a pair of mutually exclusive time slots"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}

	s+=tr("First time slot=%1").arg(r.daysOfTheWeek[this->day1]+" "+r.hoursOfTheDay[this->hour1]);s+="\n";
	s+=tr("Second time slot=%1").arg(r.daysOfTheWeek[this->day2]+" "+r.hoursOfTheDay[this->hour2]);s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	///////////////////
	int slot1Occupied=-1;
	int slot2Occupied=-1;
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			if(this->day1==d && this->hour1>=h && this->hour1<h+act->duration){
				slot1Occupied=ai;
			}
			if(this->day2==d && this->hour2>=h && this->hour2<h+act->duration){
				slot2Occupied=ai;
			}
		}
	}
	
	nbroken=0;
	
	if(slot1Occupied>=0 && slot2Occupied>=0){
		nbroken++;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint activities pair of mutually exclusive time slots broken, at least two activities break it: Id %1 and Id %2, first time slot's day %3, first time slot's hour %4, second time slot's day %5, second time slot's hour %6.")
			 .arg(r.internalActivitiesList[slot1Occupied].id)
			 .arg(r.internalActivitiesList[slot2Occupied].id)
			 .arg(r.daysOfTheWeek[this->day1])
			 .arg(r.hoursOfTheDay[this->hour1])
			 .arg(r.daysOfTheWeek[this->day2])
			 .arg(r.hoursOfTheDay[this->hour2])
			 )
			 +" "
			 +
			 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
			
			dl.append(s);
			cl.append(weightPercentage/100);
			
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::hasWrongDayOrHour(Rules& r)
{
	if(day1>=r.nDaysPerWeek)
		return true;
	if(hour1>=r.nHoursPerDay)
		return true;
	if(day2>=r.nDaysPerWeek)
		return true;
	if(hour2>=r.nHoursPerDay)
		return true;
	
	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return false;
}

bool ConstraintActivitiesPairOfMutuallyExclusiveTimeSlots::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHER_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection(double wp, const QString& teacher,
 int mos, const QList<QList<int>>& sd, const QList<QList<int>>& sh)
 : TimeConstraint(wp)
 {
	this->teacherName=teacher;
	this->maxOccupiedSets=mos;
	this->selectedDays=sd;
	this->selectedHours=sh;

	this->type=CONSTRAINT_TEACHER_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::computeInternalStructure(QWidget* parent, Rules& r)
{
	teacher_ID=r.teachersHash.value(teacherName, -1);
	assert(this->teacher_ID>=0);

	assert(selectedDays.count()==selectedHours.count());

	if(selectedDays.count()<2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teacher occupies max sets of time slots from selection is wrong because the selection contains less than two sets of time"
		 " slots. Please correct and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	listOfSets.clear();
	listOfLists.clear();
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& cdays=selectedDays.at(q);
		const QList<int>& chours=selectedHours.at(q);
		assert(cdays.count()==chours.count());
		QSet<int> ts;
		QList<int> tl;
		for(int k=0; k<cdays.count(); k++){
			int d=cdays.at(k);
			int h=chours.at(k);
			if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
				ts.insert(d+h*r.nDaysPerWeek);
				tl.append(d+h*r.nDaysPerWeek);
			}
		}
		assert(ts.count()==tl.count());
		if(tl.count()==0){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Constraint teacher occupies max sets of time slots from selection is wrong because the set number %1 of selected time slots is empty. Please correct"
			 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%2")
			 .arg(q+1).arg(this->getDetailedDescription(r)));
			
			return false;
		}
		listOfSets.append(ts);
		listOfLists.append(tl);
	}

	for(int i=0; i<listOfSets.count()-1; i++){
		const QSet<int>& set1=listOfSets.at(i);
		for(int j=i+1; j<listOfSets.count(); j++){
			const QSet<int>& set2=listOfSets.at(j);
			if(set1.intersects(set2)){
				TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
				 tr("Constraint teacher occupies max sets of time slots from selection is wrong because the set number %1 of selected time slots and the set number %2 of selected time slots have at least one common time slot. Please correct"
				 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%3")
				 .arg(i+1)
				 .arg(j+1)
				 .arg(this->getDetailedDescription(r)));
				
				return false;
			}
		}
	}

	return true;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";

	s+=IL3+"<Maximum_Number_of_Occupied_Sets>"+CustomFETString::number(this->maxOccupiedSets)+"</Maximum_Number_of_Occupied_Sets>\n";

	s+=IL3+"<Number_of_Selected_Sets_of_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Sets_of_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);
		s+=IL3+"<Selected_Set_of_Time_Slots>\n";
		s+=IL4+"<Number_of_Selected_Time_Slots>"+QString::number(days.count())+"</Number_of_Selected_Time_Slots>\n";
		for(int j=0; j<days.count(); j++){
			s+=IL4+"<Selected_Time_Slot>\n";
			s+=IL5+"<Day>"+protect(r.daysOfTheWeek[days.at(j)])+"</Day>\n";
			s+=IL5+"<Hour>"+protect(r.hoursOfTheDay[hours.at(j)])+"</Hour>\n";
			s+=IL4+"</Selected_Time_Slot>\n";
		}
		s+=IL3+"</Selected_Set_of_Time_Slots>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection>\n";
	return s;
}

QString ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teacher occupies max sets of time slots from selection");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("T:%1", "Teacher").arg(this->teacherName);s+=translatedCommaSpace();

	s+=tr("MOS:%1", "Max occupied sets").arg(this->maxOccupiedSets);s+=translatedCommaSpace();

	s+=tr("NS:%1", "Number of sets").arg(this->selectedDays.count());s+=translatedCommaSpace();
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("SSTS %1: %2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+translatedCommaSpace();
	}
	s.chop(translatedCommaSpace().size());
	
	return begin+s+end;
}

QString ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A teacher occupies a max number of sets of time slots from a selection");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Teacher=%1").arg(this->teacherName);s+="\n";

	s+=tr("Max number of occupied sets=%1").arg(this->maxOccupiedSets);s+="\n";

	s+=tr("Number of sets=%1").arg(this->selectedDays.count());s+="\n";
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("Set of selected time slots number %1=%2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+"\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	int i=this->teacher_ID;
	
	QSet<int> occupiedSets;

	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		for(int j=0; j<days.count(); j++){
			int day=days.at(j);
			int hour=hours.at(j);
			
			if(teachersMatrix[i][day][hour]>0){
				assert(!occupiedSets.contains(q));
				occupiedSets.insert(q);
				break;
			}
		}
	}

	if(occupiedSets.count()>this->maxOccupiedSets){
		nbroken++;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint teacher occupies max sets of time slots from selection broken for teacher %1, the teacher occupies %2 sets of selected time slots,"
			 " but the maximum allowed is %3.")
			 .arg(r.internalTeachersList[i]->name)
			 .arg(occupiedSets.count())
			 .arg(this->maxOccupiedSets)
			 )
			 +" "
			 +
			 (tr("This increases the conflicts total by %1.").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
			
			dl.append(s);
			cl.append(weightPercentage/100);
			
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToTeacher(Teacher* t)
{
	if(this->teacherName==t->name)
		return true;
	return false;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::hasWrongDayOrHour(Rules& r)
{
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		for(int j=0; j<days.count(); j++){
			int day=days.at(j);
			int hour=hours.at(j);
			
			if(day>=r.nDaysPerWeek)
				return true;
			if(hour>=r.nHoursPerDay)
				return true;
		}
	}
	
	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeacherOccupiesMaxSetsOfTimeSlotsFromSelection::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<QList<int>> newSelectedDays;
	QList<QList<int>> newSelectedHours;
	
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		QList<int> newDays;
		QList<int> newHours;
		
		for(int i=0; i<days.count(); i++){
			int day=days.at(i);
			int hour=hours.at(i);
			
			if(day<r.nDaysPerWeek && hour<r.nHoursPerDay){
				newDays.append(day);
				newHours.append(hour);
			}
		}
		
		newSelectedDays.append(newDays);
		newSelectedHours.append(newHours);
	}
	
	selectedDays=newSelectedDays;
	selectedHours=newSelectedHours;

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		this->maxOccupiedSets = r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection()
	: TimeConstraint()
{
	this->type=CONSTRAINT_TEACHERS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection(double wp,
 int mos, const QList<QList<int>>& sd, const QList<QList<int>>& sh)
 : TimeConstraint(wp)
 {
	this->maxOccupiedSets=mos;
	this->selectedDays=sd;
	this->selectedHours=sh;

	this->type=CONSTRAINT_TEACHERS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::computeInternalStructure(QWidget* parent, Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());

	if(selectedDays.count()<2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint teachers occupy max sets of time slots from selection is wrong because the selection contains less than two sets of time"
		 " slots. Please correct and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	listOfSets.clear();
	listOfLists.clear();
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& cdays=selectedDays.at(q);
		const QList<int>& chours=selectedHours.at(q);
		assert(cdays.count()==chours.count());
		QSet<int> ts;
		QList<int> tl;
		for(int k=0; k<cdays.count(); k++){
			int d=cdays.at(k);
			int h=chours.at(k);
			if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
				ts.insert(d+h*r.nDaysPerWeek);
				tl.append(d+h*r.nDaysPerWeek);
			}
		}
		assert(ts.count()==tl.count());
		if(tl.count()==0){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Constraint teachers occupy max sets of time slots from selection is wrong because the set number %1 of selected time slots is empty. Please correct"
			 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%2")
			 .arg(q+1).arg(this->getDetailedDescription(r)));
			
			return false;
		}
		listOfSets.append(ts);
		listOfLists.append(tl);
	}

	for(int i=0; i<listOfSets.count()-1; i++){
		const QSet<int>& set1=listOfSets.at(i);
		for(int j=i+1; j<listOfSets.count(); j++){
			const QSet<int>& set2=listOfSets.at(j);
			if(set1.intersects(set2)){
				TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
				 tr("Constraint teachers occupy max sets of time slots from selection is wrong because the set number %1 of selected time slots and the set number %2 of selected time slots have at least one common time slot. Please correct"
				 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%3")
				 .arg(i+1)
				 .arg(j+1)
				 .arg(this->getDetailedDescription(r)));
				
				return false;
			}
		}
	}

	return true;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Maximum_Number_of_Occupied_Sets>"+CustomFETString::number(this->maxOccupiedSets)+"</Maximum_Number_of_Occupied_Sets>\n";

	s+=IL3+"<Number_of_Selected_Sets_of_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Sets_of_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);
		s+=IL3+"<Selected_Set_of_Time_Slots>\n";
		s+=IL4+"<Number_of_Selected_Time_Slots>"+QString::number(days.count())+"</Number_of_Selected_Time_Slots>\n";
		for(int j=0; j<days.count(); j++){
			s+=IL4+"<Selected_Time_Slot>\n";
			s+=IL5+"<Day>"+protect(r.daysOfTheWeek[days.at(j)])+"</Day>\n";
			s+=IL5+"<Hour>"+protect(r.hoursOfTheDay[hours.at(j)])+"</Hour>\n";
			s+=IL4+"</Selected_Time_Slot>\n";
		}
		s+=IL3+"</Selected_Set_of_Time_Slots>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection>\n";
	return s;
}

QString ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Teachers occupy max sets of time slots from selection");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("MOS:%1", "Max occupied sets").arg(this->maxOccupiedSets);s+=translatedCommaSpace();

	s+=tr("NS:%1", "Number of sets").arg(this->selectedDays.count());s+=translatedCommaSpace();
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("SSTS %1: %2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+translatedCommaSpace();
	}
	s.chop(translatedCommaSpace().size());
	
	return begin+s+end;
}

QString ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All teachers occupy a max number of sets of time slots from a selection");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Max number of occupied sets=%1").arg(this->maxOccupiedSets);s+="\n";

	s+=tr("Number of sets=%1").arg(this->selectedDays.count());s+="\n";
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("Set of selected time slots number %1=%2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+"\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	//int i=this->teacher_ID;
	for(int i=0; i<r.nInternalTeachers; i++){
		QSet<int> occupiedSets;

		for(int q=0; q<selectedDays.count(); q++){
			const QList<int>& days=selectedDays.at(q);
			const QList<int>& hours=selectedHours.at(q);
			
			for(int j=0; j<days.count(); j++){
				int day=days.at(j);
				int hour=hours.at(j);
				
				if(teachersMatrix[i][day][hour]>0){
					assert(!occupiedSets.contains(q));
					occupiedSets.insert(q);
					break;
				}
			}
		}

		if(occupiedSets.count()>this->maxOccupiedSets){
			nbroken++;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint teachers occupy max sets of time slots from selection broken for teacher %1, the teacher occupies %2 sets of selected time slots,"
				 " but the maximum allowed is %3.")
				 .arg(r.internalTeachersList[i]->name)
				 .arg(occupiedSets.count())
				 .arg(this->maxOccupiedSets)
				 )
				 +" "
				 +
				 (tr("This increases the conflicts total by %1.").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
				
				dl.append(s);
				cl.append(weightPercentage/100);
				
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::hasWrongDayOrHour(Rules& r)
{
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		for(int j=0; j<days.count(); j++){
			int day=days.at(j);
			int hour=hours.at(j);
			
			if(day>=r.nDaysPerWeek)
				return true;
			if(hour>=r.nHoursPerDay)
				return true;
		}
	}

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintTeachersOccupyMaxSetsOfTimeSlotsFromSelection::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<QList<int>> newSelectedDays;
	QList<QList<int>> newSelectedHours;
	
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		QList<int> newDays;
		QList<int> newHours;
		
		for(int i=0; i<days.count(); i++){
			int day=days.at(i);
			int hour=hours.at(i);
			
			if(day<r.nDaysPerWeek && hour<r.nHoursPerDay){
				newDays.append(day);
				newHours.append(hour);
			}
		}
		
		newSelectedDays.append(newDays);
		newSelectedHours.append(newHours);
	}
	
	selectedDays=newSelectedDays;
	selectedHours=newSelectedHours;

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		this->maxOccupiedSets = r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_SET_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection(double wp, const QString& s,
 int mos, const QList<QList<int>>& sd, const QList<QList<int>>& sh)
 : TimeConstraint(wp)
 {
	this->students=s;
	this->maxOccupiedSets=mos;
	this->selectedDays=sd;
	this->selectedHours=sh;

	this->type=CONSTRAINT_STUDENTS_SET_OCCUPIES_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::computeInternalStructure(QWidget* parent, Rules& r)
{
	StudentsSet* ss=r.studentsHash.value(students, nullptr);
	
	if(ss==nullptr){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set occupies max sets of time slots from selection is wrong because it refers to nonexistent students set."
		 " Please correct it (removing it might be a solution). Please report potential bug. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
		return false;
	}

	assert(selectedDays.count()==selectedHours.count());

	if(selectedDays.count()<2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students set occupies max sets of time slots from selection is wrong because the selection contains less than two sets of time"
		 " slots. Please correct and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	listOfSets.clear();
	listOfLists.clear();
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& cdays=selectedDays.at(q);
		const QList<int>& chours=selectedHours.at(q);
		assert(cdays.count()==chours.count());
		QSet<int> ts;
		QList<int> tl;
		for(int k=0; k<cdays.count(); k++){
			int d=cdays.at(k);
			int h=chours.at(k);
			if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
				ts.insert(d+h*r.nDaysPerWeek);
				tl.append(d+h*r.nDaysPerWeek);
			}
		}
		assert(ts.count()==tl.count());
		if(tl.count()==0){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Constraint students set occupies max sets of time slots from selection is wrong because the set number %1 of selected time slots is empty. Please correct"
			 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%2")
			 .arg(q+1).arg(this->getDetailedDescription(r)));
			
			return false;
		}
		listOfSets.append(ts);
		listOfLists.append(tl);
	}

	for(int i=0; i<listOfSets.count()-1; i++){
		const QSet<int>& set1=listOfSets.at(i);
		for(int j=i+1; j<listOfSets.count(); j++){
			const QSet<int>& set2=listOfSets.at(j);
			if(set1.intersects(set2)){
				TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
				 tr("Constraint students set occupies max sets of time slots from selection is wrong because the set number %1 of selected time slots and the set number %2 of selected time slots have at least one common time slot. Please correct"
				 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%3")
				 .arg(i+1)
				 .arg(j+1)
				 .arg(this->getDetailedDescription(r)));
				
				return false;
			}
		}
	}

	assert(ss!=nullptr);
	
	populateInternalSubgroupsList(r, ss, this->iSubgroupsList);

	return true;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Students>"+protect(this->students)+"</Students>\n";

	s+=IL3+"<Maximum_Number_of_Occupied_Sets>"+CustomFETString::number(this->maxOccupiedSets)+"</Maximum_Number_of_Occupied_Sets>\n";

	s+=IL3+"<Number_of_Selected_Sets_of_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Sets_of_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);
		s+=IL3+"<Selected_Set_of_Time_Slots>\n";
		s+=IL4+"<Number_of_Selected_Time_Slots>"+QString::number(days.count())+"</Number_of_Selected_Time_Slots>\n";
		for(int j=0; j<days.count(); j++){
			s+=IL4+"<Selected_Time_Slot>\n";
			s+=IL5+"<Day>"+protect(r.daysOfTheWeek[days.at(j)])+"</Day>\n";
			s+=IL5+"<Hour>"+protect(r.hoursOfTheDay[hours.at(j)])+"</Hour>\n";
			s+=IL4+"</Selected_Time_Slot>\n";
		}
		s+=IL3+"</Selected_Set_of_Time_Slots>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection>\n";
	return s;
}

QString ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Students set occupies max sets of time slots from selection");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();
	s+=tr("St:%1", "Students").arg(this->students);s+=translatedCommaSpace();

	s+=tr("MOS:%1", "Max occupied sets").arg(this->maxOccupiedSets);s+=translatedCommaSpace();

	s+=tr("NS:%1", "Number of sets").arg(this->selectedDays.count());s+=translatedCommaSpace();
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("SSTS %1: %2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+translatedCommaSpace();
	}
	s.chop(translatedCommaSpace().size());
	
	return begin+s+end;
}

QString ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("A students set occupies a max number of sets of time slots from a selection");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Students=%1").arg(this->students);s+="\n";

	s+=tr("Max number of occupied sets=%1").arg(this->maxOccupiedSets);s+="\n";

	s+=tr("Number of sets=%1").arg(this->selectedDays.count());s+="\n";
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("Set of selected time slots number %1=%2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+"\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i : std::as_const(this->iSubgroupsList)){
		QSet<int> occupiedSets;

		for(int q=0; q<selectedDays.count(); q++){
			const QList<int>& days=selectedDays.at(q);
			const QList<int>& hours=selectedHours.at(q);
			
			for(int j=0; j<days.count(); j++){
				int day=days.at(j);
				int hour=hours.at(j);
				
				if(subgroupsMatrix[i][day][hour]>0){
					assert(!occupiedSets.contains(q));
					occupiedSets.insert(q);
					break;
				}
			}
		}

		if(occupiedSets.count()>this->maxOccupiedSets){
			nbroken++;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint students set occupies max sets of time slots from selection broken for subgroup %1, the subgroup occupies %2 sets of selected time slots,"
				 " but the maximum allowed is %3.")
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(occupiedSets.count())
				 .arg(this->maxOccupiedSets)
				 )
				 +" "
				 +
				 (tr("This increases the conflicts total by %1.").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
				
				dl.append(s);
				cl.append(weightPercentage/100);
				
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t)

	return false;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	return r.setsShareStudents(this->students, s->name);
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::hasWrongDayOrHour(Rules& r)
{
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		for(int j=0; j<days.count(); j++){
			int day=days.at(j);
			int hour=hours.at(j);
			
			if(day>=r.nDaysPerWeek)
				return true;
			if(hour>=r.nHoursPerDay)
				return true;
		}
	}

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsSetOccupiesMaxSetsOfTimeSlotsFromSelection::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<QList<int>> newSelectedDays;
	QList<QList<int>> newSelectedHours;
	
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		QList<int> newDays;
		QList<int> newHours;
		
		for(int i=0; i<days.count(); i++){
			int day=days.at(i);
			int hour=hours.at(i);
			
			if(day<r.nDaysPerWeek && hour<r.nHoursPerDay){
				newDays.append(day);
				newHours.append(hour);
			}
		}
		
		newSelectedDays.append(newDays);
		newSelectedHours.append(newHours);
	}
	
	selectedDays=newSelectedDays;
	selectedHours=newSelectedHours;

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		this->maxOccupiedSets = r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection()
	: TimeConstraint()
{
	this->type=CONSTRAINT_STUDENTS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection(double wp,
 int mos, const QList<QList<int>>& sd, const QList<QList<int>>& sh)
 : TimeConstraint(wp)
 {
	this->maxOccupiedSets=mos;
	this->selectedDays=sd;
	this->selectedHours=sh;

	this->type=CONSTRAINT_STUDENTS_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::computeInternalStructure(QWidget* parent, Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());

	if(selectedDays.count()<2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint students occupy max sets of time slots from selection is wrong because the selection contains less than two sets of time"
		 " slots. Please correct and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	listOfSets.clear();
	listOfLists.clear();
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& cdays=selectedDays.at(q);
		const QList<int>& chours=selectedHours.at(q);
		assert(cdays.count()==chours.count());
		QSet<int> ts;
		QList<int> tl;
		for(int k=0; k<cdays.count(); k++){
			int d=cdays.at(k);
			int h=chours.at(k);
			if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
				ts.insert(d+h*r.nDaysPerWeek);
				tl.append(d+h*r.nDaysPerWeek);
			}
		}
		assert(ts.count()==tl.count());
		if(tl.count()==0){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Constraint students occupy max sets of time slots from selection is wrong because the set number %1 of selected time slots is empty. Please correct"
			 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%2")
			 .arg(q+1).arg(this->getDetailedDescription(r)));
			
			return false;
		}
		listOfSets.append(ts);
		listOfLists.append(tl);
	}

	for(int i=0; i<listOfSets.count()-1; i++){
		const QSet<int>& set1=listOfSets.at(i);
		for(int j=i+1; j<listOfSets.count(); j++){
			const QSet<int>& set2=listOfSets.at(j);
			if(set1.intersects(set2)){
				TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
				 tr("Constraint students occupy max sets of time slots from selection is wrong because the set number %1 of selected time slots and the set number %2 of selected time slots have at least one common time slot. Please correct"
				 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%3")
				 .arg(i+1)
				 .arg(j+1)
				 .arg(this->getDetailedDescription(r)));
				
				return false;
			}
		}
	}

	return true;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Maximum_Number_of_Occupied_Sets>"+CustomFETString::number(this->maxOccupiedSets)+"</Maximum_Number_of_Occupied_Sets>\n";

	s+=IL3+"<Number_of_Selected_Sets_of_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Sets_of_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);
		s+=IL3+"<Selected_Set_of_Time_Slots>\n";
		s+=IL4+"<Number_of_Selected_Time_Slots>"+QString::number(days.count())+"</Number_of_Selected_Time_Slots>\n";
		for(int j=0; j<days.count(); j++){
			s+=IL4+"<Selected_Time_Slot>\n";
			s+=IL5+"<Day>"+protect(r.daysOfTheWeek[days.at(j)])+"</Day>\n";
			s+=IL5+"<Hour>"+protect(r.hoursOfTheDay[hours.at(j)])+"</Hour>\n";
			s+=IL4+"</Selected_Time_Slot>\n";
		}
		s+=IL3+"</Selected_Set_of_Time_Slots>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection>\n";
	return s;
}

QString ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString s;
	s+=tr("Students occupy max sets of time slots from selection");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("MOS:%1", "Max occupied sets").arg(this->maxOccupiedSets);s+=translatedCommaSpace();

	s+=tr("NS:%1", "Number of sets").arg(this->selectedDays.count());s+=translatedCommaSpace();
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("SSTS %1: %2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+translatedCommaSpace();
	}
	s.chop(translatedCommaSpace().size());
	
	return begin+s+end;
}

QString ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("All students occupy a max number of sets of time slots from a selection");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	s+=tr("Max number of occupied sets=%1").arg(this->maxOccupiedSets);s+="\n";

	s+=tr("Number of sets=%1").arg(this->selectedDays.count());s+="\n";
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("Set of selected time slots number %1=%2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+"\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	for(int i=0; i<r.nInternalSubgroups; i++){
		QSet<int> occupiedSets;

		for(int q=0; q<selectedDays.count(); q++){
			const QList<int>& days=selectedDays.at(q);
			const QList<int>& hours=selectedHours.at(q);
			
			for(int j=0; j<days.count(); j++){
				int day=days.at(j);
				int hour=hours.at(j);
				
				if(subgroupsMatrix[i][day][hour]>0){
					assert(!occupiedSets.contains(q));
					occupiedSets.insert(q);
					break;
				}
			}
		}

		if(occupiedSets.count()>this->maxOccupiedSets){
			nbroken++;

			if(conflictsString!=nullptr){
				QString s=(tr(
				 "Time constraint students occupy max sets of time slots from selection broken for subgroup %1, the subgroup occupies %2 sets of selected time slots,"
				 " but the maximum allowed is %3.")
				 .arg(r.internalSubgroupsList[i]->name)
				 .arg(occupiedSets.count())
				 .arg(this->maxOccupiedSets)
				 )
				 +" "
				 +
				 (tr("This increases the conflicts total by %1.").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
				
				dl.append(s);
				cl.append(weightPercentage/100);
				
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);
	Q_UNUSED(a);

	return false;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);
	
	return true;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);

	return false;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::hasWrongDayOrHour(Rules& r)
{
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		for(int j=0; j<days.count(); j++){
			int day=days.at(j);
			int hour=hours.at(j);
			
			if(day>=r.nDaysPerWeek)
				return true;
			if(hour>=r.nHoursPerDay)
				return true;
		}
	}

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintStudentsOccupyMaxSetsOfTimeSlotsFromSelection::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<QList<int>> newSelectedDays;
	QList<QList<int>> newSelectedHours;
	
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		QList<int> newDays;
		QList<int> newHours;
		
		for(int i=0; i<days.count(); i++){
			int day=days.at(i);
			int hour=hours.at(i);
			
			if(day<r.nDaysPerWeek && hour<r.nHoursPerDay){
				newDays.append(day);
				newHours.append(hour);
			}
		}
		
		newSelectedDays.append(newDays);
		newSelectedHours.append(newHours);
	}
	
	selectedDays=newSelectedDays;
	selectedHours=newSelectedHours;

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		this->maxOccupiedSets = r.nDaysPerWeek*r.nHoursPerDay;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::ConstraintActivitiesOverlapCompletelyOrDoNotOverlap()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_OVERLAP_COMPLETELY_OR_DO_NOT_OVERLAP;
}

ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::ConstraintActivitiesOverlapCompletelyOrDoNotOverlap(double wp, const QList<int>& a_L) : TimeConstraint(wp)
{
	this->activitiesIds=a_L;

	this->type=CONSTRAINT_ACTIVITIES_OVERLAP_COMPLETELY_OR_DO_NOT_OVERLAP;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	int dur=-1;
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0){
			_activitiesIndices.append(i);
			
			if(dur==-1 || dur==r.internalActivitiesList[i].duration){
				dur=r.internalActivitiesList[i].duration;
			}
			else{
				TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
					tr("Following constraint is wrong, because the activities have different durations. Please correct it:\n%1").arg(this->getDetailedDescription(r)));

				return false;
			}
		}
	}
	if(dur==1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is useless, because the durations of the activities are 1. Please correct it or remove it:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	if(this->_activitiesIndices.count()<=1){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because you need 2 or more activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));

		return false;
	}

	return true;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::hasInactiveActivities(Rules& r)
{
	int count=0;

	for(int aid : std::as_const(this->activitiesIds))
		if(r.inactiveActivities.contains(aid))
			count++;

	if(this->activitiesIds.count()-count<=1)
		return true;
	else
		return false;
}

QString ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesOverlapCompletelyOrDoNotOverlap>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesOverlapCompletelyOrDoNotOverlap>\n";
	return s;
}

QString ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
	
	QString s=tr("Activities overlap completely or do not overlap, WP:%1%, NA:%2, A: %3",
	 "Constraint description. WP means weight percentage, NA means the number of activities, A means activities list")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids);
	
	return begin+s+end;
}

QString ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint"); s+="\n";
	s+=tr("Activities overlap completely or do not overlap"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	///////////////////
	for(int ai1 : std::as_const(this->_activitiesIndices)){
		if(c.times[ai1]!=UNALLOCATED_TIME){
			int d1=c.times[ai1]%r.nDaysPerWeek;
			int dur1=r.internalActivitiesList[ai1].duration;
			for(int ai2 : std::as_const(this->_activitiesIndices)){
				if(ai1!=ai2){
					if(c.times[ai2]!=UNALLOCATED_TIME){
						int d2=c.times[ai2]%r.nDaysPerWeek;
						if(d1==d2){
							int dur2=r.internalActivitiesList[ai2].duration;
							assert(dur1==dur2);
							if(!(c.times[ai1]+dur1<=c.times[ai2] || c.times[ai2]+dur2<=c.times[ai1]) && c.times[ai1]!=c.times[ai2]){
								nbroken++;
								
								if(conflictsString!=nullptr){
									QString s=(tr(
									 "Time constraint activities overlap completely or do not overlap broken, these two activities break it: Id %1 and Id %2.")
									 .arg(r.internalActivitiesList[ai1].id)
									 .arg(r.internalActivitiesList[ai2].id)
									 )
									 +" "
									 +
									 (tr("This increases the conflicts total by %1").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
									
									dl.append(s);
									cl.append(weightPercentage/100);
									
									*conflictsString+= s+"\n";
								}
							}
						}
					}
				}
			}
		}
	}
	
	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesOverlapCompletelyOrDoNotOverlap::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection()
	: TimeConstraint()
{
	this->type=CONSTRAINT_ACTIVITIES_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection(double wp, const QList<int>& a_L,
 int mos, const QList<QList<int>>& sd, const QList<QList<int>>& sh)
 : TimeConstraint(wp)
 {
	this->activitiesIds=a_L;

	this->maxOccupiedSets=mos;
	this->selectedDays=sd;
	this->selectedHours=sh;

	this->type=CONSTRAINT_ACTIVITIES_OCCUPY_MAX_SETS_OF_TIME_SLOTS_FROM_SELECTION;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			_activitiesIndices.append(i);
	}
	
	if(this->_activitiesIndices.count()==0){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	assert(selectedDays.count()==selectedHours.count());

	if(selectedDays.count()<2){
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
		 tr("Constraint activities occupy max sets of time slots from selection is wrong because the selection contains less than two sets of time"
		 " slots. Please correct and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%1")
		 .arg(this->getDetailedDescription(r)));
		
		return false;
	}

	listOfSets.clear();
	listOfLists.clear();
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& cdays=selectedDays.at(q);
		const QList<int>& chours=selectedHours.at(q);
		assert(cdays.count()==chours.count());
		QSet<int> ts;
		QList<int> tl;
		for(int k=0; k<cdays.count(); k++){
			int d=cdays.at(k);
			int h=chours.at(k);
			if(d>=0 && d<r.nDaysPerWeek && h>=0 && h<r.nHoursPerDay){
				ts.insert(d+h*r.nDaysPerWeek);
				tl.append(d+h*r.nDaysPerWeek);
			}
		}
		assert(ts.count()==tl.count());
		if(tl.count()==0){
			TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
			 tr("Constraint activities occupy max sets of time slots from selection is wrong because the set number %1 of selected time slots is empty. Please correct"
			 " and try again. Correcting means editing the constraint and updating information, or removing the constraint. Constraint is:\n%2")
			 .arg(q+1).arg(this->getDetailedDescription(r)));
			
			return false;
		}
		listOfSets.append(ts);
		listOfLists.append(tl);
	}

	for(int i=0; i<listOfSets.count()-1; i++){
		const QSet<int>& set1=listOfSets.at(i);
		for(int j=i+1; j<listOfSets.count(); j++){
			const QSet<int>& set2=listOfSets.at(j);
			if(set1.intersects(set2)){
				TimeConstraintIrreconcilableMessage::warning(parent, tr("FET warning"),
				 tr("Constraint activities occupy max sets of time slots from selection is wrong because the set number %1 of selected time slots and the set number %2 of selected time slots have at least one common time slot. Please correct"
				 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%3")
				 .arg(i+1)
				 .arg(j+1)
				 .arg(this->getDetailedDescription(r)));
				
				return false;
			}
		}
	}

	return true;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";

	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";

	s+=IL3+"<Maximum_Number_of_Occupied_Sets>"+CustomFETString::number(this->maxOccupiedSets)+"</Maximum_Number_of_Occupied_Sets>\n";

	s+=IL3+"<Number_of_Selected_Sets_of_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Sets_of_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);
		s+=IL3+"<Selected_Set_of_Time_Slots>\n";
		s+=IL4+"<Number_of_Selected_Time_Slots>"+QString::number(days.count())+"</Number_of_Selected_Time_Slots>\n";
		for(int j=0; j<days.count(); j++){
			s+=IL4+"<Selected_Time_Slot>\n";
			s+=IL5+"<Day>"+protect(r.daysOfTheWeek[days.at(j)])+"</Day>\n";
			s+=IL5+"<Hour>"+protect(r.hoursOfTheDay[hours.at(j)])+"</Hour>\n";
			s+=IL4+"</Selected_Time_Slot>\n";
		}
		s+=IL3+"</Selected_Set_of_Time_Slots>\n";
	}

	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection>\n";
	return s;
}

QString ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::getDescription(Rules& r)
{
	Q_UNUSED(r);

	QString begin=QString("");
	if(!active)
		begin="X - ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());

	QString s;
	s+=tr("Activities occupy max sets of time slots from selection");s+=translatedCommaSpace();
	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));s+=translatedCommaSpace();

	s+=tr("NA:%1", "Number of activities").arg(QString::number(this->activitiesIds.count()));s+=translatedCommaSpace();
	s+=tr("A: %1", "Activities list").arg(actids);s+=translatedCommaSpace();

	s+=tr("MOS:%1", "Max occupied sets").arg(this->maxOccupiedSets);s+=translatedCommaSpace();

	s+=tr("NS:%1", "Number of sets").arg(this->selectedDays.count());s+=translatedCommaSpace();
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("SSTS %1: %2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+translatedCommaSpace();
	}
	s.chop(translatedCommaSpace().size());
	
	return begin+s+end;
}

QString ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities occupy a max number of sets of time slots from a selection");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}

	s+=tr("Max number of occupied sets=%1").arg(this->maxOccupiedSets);s+="\n";

	s+=tr("Number of sets=%1").arg(this->selectedDays.count());s+="\n";
	
	for(int i=0; i<this->selectedDays.count(); i++){
		const QList<int>& days=selectedDays.at(i);
		const QList<int>& hours=selectedHours.at(i);

		QString timeslots=QString("");
		for(int j=0; j<days.count(); j++)
			timeslots+=r.daysOfTheWeek[days.at(j)]+QString(" ")+r.hoursOfTheDay[hours.at(j)]+translatedCommaSpace();
		timeslots.chop(translatedCommaSpace().size());

		s+=tr("Set of selected time slots number %1=%2", "The set of selected time slots number %1 is composed of the list of selected time slots %2.").arg(i+1).arg(timeslots)+"\n";
	}

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	assert(r.internalStructureComputed);

	///////////////////
	Matrix2D<int> used;
	used.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			used[d][h]=-1;
	
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<act->duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				if(used[d][h+dur]==-1){
					used[d][h+dur]=ai;
				}
			}
		}
	}

	int nbroken=0;

	QSet<int> occupiedSets;

	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		for(int j=0; j<days.count(); j++){
			int day=days.at(j);
			int hour=hours.at(j);
			
			if(used[day][hour]>0){
				assert(!occupiedSets.contains(q));
				occupiedSets.insert(q);
				break;
			}
		}
	}

	if(occupiedSets.count()>this->maxOccupiedSets){
		nbroken++;

		if(conflictsString!=nullptr){
			QString s=(tr(
			 "Time constraint activities occupy max sets of time slots from selection broken, the activities occupy %1 sets of selected time slots,"
			 " but the maximum allowed is %2. The constraint is:\n%3")
			 .arg(occupiedSets.count())
			 .arg(this->maxOccupiedSets)
			 .arg(this->getDetailedDescription(r))
			 )
			 +" "
			 +
			 (tr("This increases the conflicts total by %1.").arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100)));
			
			dl.append(s);
			cl.append(weightPercentage/100);
			
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return weightPercentage/100 * nbroken;
}

void ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::hasWrongDayOrHour(Rules& r)
{
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		for(int j=0; j<days.count(); j++){
			int day=days.at(j);
			int hour=hours.at(j);
			
			if(day>=r.nDaysPerWeek)
				return true;
			if(hour>=r.nHoursPerDay)
				return true;
		}
	}

	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		return true;

	return false;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesOccupyMaxSetsOfTimeSlotsFromSelection::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<QList<int>> newSelectedDays;
	QList<QList<int>> newSelectedHours;
	
	for(int q=0; q<selectedDays.count(); q++){
		const QList<int>& days=selectedDays.at(q);
		const QList<int>& hours=selectedHours.at(q);
		
		QList<int> newDays;
		QList<int> newHours;
		
		for(int i=0; i<days.count(); i++){
			int day=days.at(i);
			int hour=hours.at(i);
			
			if(day<r.nDaysPerWeek && hour<r.nHoursPerDay){
				newDays.append(day);
				newHours.append(hour);
			}
		}
		
		newSelectedDays.append(newDays);
		newSelectedHours.append(newHours);
	}
	
	selectedDays=newSelectedDays;
	selectedHours=newSelectedHours;
	
	if(this->maxOccupiedSets > r.nDaysPerWeek*r.nHoursPerDay)
		this->maxOccupiedSets = r.nDaysPerWeek*r.nHoursPerDay;

	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityBeginsOrEndsStudentsDay::ConstraintActivityBeginsOrEndsStudentsDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_STUDENTS_DAY;
}

ConstraintActivityBeginsOrEndsStudentsDay::ConstraintActivityBeginsOrEndsStudentsDay(double wp, int actId)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->type = CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_STUDENTS_DAY;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityBeginsOrEndsStudentsDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityBeginsOrEndsStudentsDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityBeginsOrEndsStudentsDay>\n";
	return s;
}

QString ConstraintActivityBeginsOrEndsStudentsDay::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) must begin or end students' day",
		"%1 is the id, %2 is the detailed description of the activity.")
		.arg(getActivityDescription(r, this->activityId))
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityBeginsOrEndsStudentsDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity must begin or end students' day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityBeginsOrEndsStudentsDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		
		int i=this->activityIndex;
		for(int j=0; j<r.internalActivitiesList[i].iSubgroupsList.count(); j++){
			int sb=r.internalActivitiesList[i].iSubgroupsList.at(j);
			bool ab=true;
			bool ae=true;
			for(int hh=h-1; hh>=0; hh--)
				if(subgroupsMatrix[sb][d][hh]>0){
					ab=false;
					break;
				}
			for(int hh=r.nHoursPerDay-1; hh>=h+r.internalActivitiesList[this->activityIndex].duration; hh--)
				if(subgroupsMatrix[sb][d][hh]>0){
					ae=false;
					break;
				}
			if(!ab && !ae)
				nbroken++;
			if(nbroken>0)
				break;
		}
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity begins or ends students' day broken for activity with id=%1 (%2), increases conflicts total by %3",
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(this->activityId)
		 .arg(getActivityDetailedDescription(r, this->activityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivityBeginsOrEndsStudentsDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesBeginOrEndStudentsDay::ConstraintActivitiesBeginOrEndStudentsDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_BEGIN_OR_END_STUDENTS_DAY;
}

ConstraintActivitiesBeginOrEndStudentsDay::ConstraintActivitiesBeginOrEndStudentsDay(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut)
	: TimeConstraint(wp)
{
	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->type=CONSTRAINT_ACTIVITIES_BEGIN_OR_END_STUDENTS_DAY;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		assert(this->nActivities < r.nInternalActivities);
		this->nActivities++;
		this->activitiesIndices.append(i);
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesBeginOrEndStudentsDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintActivitiesBeginOrEndStudentsDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesBeginOrEndStudentsDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesBeginOrEndStudentsDay>\n";
	return s;
}

QString ConstraintActivitiesBeginOrEndStudentsDay::getDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString tc, st, su, at;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");
	
	QString s;
	s+=tr("Activities with %1, %2, %3, %4, must begin or end students' day", "%1...%4 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Abbreviation for Weight Percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesBeginOrEndStudentsDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
		
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	s+=tr("must begin or end students' day");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesBeginOrEndStudentsDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	for(int kk=0; kk<this->nActivities; kk++){
		int tmp=0;
		int ai=this->activitiesIndices[kk];
	
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
		
			for(int j=0; j<r.internalActivitiesList[ai].iSubgroupsList.count(); j++){
				int sb=r.internalActivitiesList[ai].iSubgroupsList.at(j);

				bool ab=true;
				bool ae=true;
				for(int hh=h-1; hh>=0; hh--)
					if(subgroupsMatrix[sb][d][hh]>0){
						ab=false;
						break;
					}
				for(int hh=r.nHoursPerDay-1; hh>=h+r.internalActivitiesList[ai].duration; hh--)
					if(subgroupsMatrix[sb][d][hh]>0){
						ae=false;
						break;
					}
				if(!ab && !ae){
					tmp=1;
					nbroken++;
				}
				if(tmp>0)
					break;
			}

			if(conflictsString!=nullptr && tmp>0){
				QString s=tr("Time constraint activities begin or end students' day broken for activity with id=%1 (%2), increases conflicts total by %3",
				 "%1 is the id, %2 is the detailed description of the activity")
				 .arg(r.internalActivitiesList[ai].id)
				 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

				dl.append(s);
				cl.append(weightPercentage/100*tmp);
	
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	return true;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesBeginOrEndStudentsDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivityBeginsOrEndsTeachersDay::ConstraintActivityBeginsOrEndsTeachersDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_TEACHERS_DAY;
}

ConstraintActivityBeginsOrEndsTeachersDay::ConstraintActivityBeginsOrEndsTeachersDay(double wp, int actId)
	: TimeConstraint(wp)
{
	this->activityId = actId;
	this->type = CONSTRAINT_ACTIVITY_BEGINS_OR_ENDS_TEACHERS_DAY;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	/*Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];
		if(act->id==this->activityId)
			break;
	}*/
	
	int i=r.activitiesHash.value(activityId, r.nInternalActivities);
	
	if(i==r.nInternalActivities){
		//assert(0);
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"), 
			tr("Following constraint is wrong (because it refers to invalid activity id). Please correct it (maybe removing it is a solution):\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}

	this->activityIndex=i;
	return true;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::hasInactiveActivities(Rules& r)
{
	if(r.inactiveActivities.contains(this->activityId))
		return true;
	return false;
}

QString ConstraintActivityBeginsOrEndsTeachersDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivityBeginsOrEndsTeachersDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Activity_Id>"+CustomFETString::number(this->activityId)+"</Activity_Id>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivityBeginsOrEndsTeachersDay>\n";
	return s;
}

QString ConstraintActivityBeginsOrEndsTeachersDay::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString s;
	s+=tr("Act. id: %1 (%2) must begin or end teachers' day",
		"%1 is the id, %2 is the detailed description of the activity.")
		.arg(getActivityDescription(r, this->activityId))
		.arg(getActivityDetailedDescription(r, this->activityId));
	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Weight percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivityBeginsOrEndsTeachersDay::getDetailedDescription(Rules& r)
{
	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activity must begin or end teachers' day");s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";
	s+=tr("Activity id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity.")
		.arg(this->activityId)
		.arg(getActivityDetailedDescription(r, this->activityId));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivityBeginsOrEndsTeachersDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString> &dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	nbroken=0;
	if(c.times[this->activityIndex]!=UNALLOCATED_TIME){
		int d=c.times[this->activityIndex]%r.nDaysPerWeek; //the day when this activity was scheduled
		int h=c.times[this->activityIndex]/r.nDaysPerWeek; //the hour
		
		int i=this->activityIndex;
		for(int j=0; j<r.internalActivitiesList[i].iTeachersList.count(); j++){
			int tch=r.internalActivitiesList[i].iTeachersList.at(j);
			bool ab=true;
			bool ae=true;
			for(int hh=h-1; hh>=0; hh--)
				if(teachersMatrix[tch][d][hh]>0){
					ab=false;
					break;
				}
			for(int hh=r.nHoursPerDay-1; hh>=h+r.internalActivitiesList[this->activityIndex].duration; hh--)
				if(teachersMatrix[tch][d][hh]>0){
					ae=false;
					break;
				}
			if(!ab && !ae){
				nbroken=1;
				break;
			}
			if(nbroken>0)
				break;
		}
	}

	if(conflictsString!=nullptr && nbroken>0){
		QString s=tr("Time constraint activity begins or ends teachers' day broken for activity with id=%1 (%2), increases conflicts total by %3",
		 "%1 is the id, %2 is the detailed description of the activity")
		 .arg(this->activityId)
		 .arg(getActivityDetailedDescription(r, this->activityId))
		 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*nbroken));

		dl.append(s);
		cl.append(weightPercentage/100*nbroken);
	
		*conflictsString+= s+"\n";
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	if(this->activityId==a->id)
		return true;
	return false;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivityBeginsOrEndsTeachersDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesBeginOrEndTeachersDay::ConstraintActivitiesBeginOrEndTeachersDay()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_BEGIN_OR_END_TEACHERS_DAY;
}

ConstraintActivitiesBeginOrEndTeachersDay::ConstraintActivitiesBeginOrEndTeachersDay(double wp, const QString& te,
	const QString& st, const QString& su, const QString& sut)
	: TimeConstraint(wp)
{
	this->teacherName=te;
	this->subjectName=su;
	this->activityTagName=sut;
	this->studentsName=st;
	this->type=CONSTRAINT_ACTIVITIES_BEGIN_OR_END_TEACHERS_DAY;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::computeInternalStructure(QWidget* parent, Rules& r)
{
	this->nActivities=0;
	this->activitiesIndices.clear();

	int it;
	Activity* act;
	int i;
	for(i=0; i<r.nInternalActivities; i++){
		act=&r.internalActivitiesList[i];

		//check if this activity has the corresponding teacher
		if(this->teacherName!=""){
			it = act->teachersNames.indexOf(this->teacherName);
			if(it==-1)
				continue;
		}
		//check if this activity has the corresponding students
		if(this->studentsName!=""){
			bool commonStudents=false;
			for(const QString& st : std::as_const(act->studentsNames))
				if(r.augmentedSetsShareStudentsFaster(st, studentsName)){
					commonStudents=true;
					break;
				}
		
			if(!commonStudents)
				continue;
		}
		//check if this activity has the corresponding subject
		if(this->subjectName!="" && act->subjectName!=this->subjectName){
				continue;
		}
		//check if this activity has the corresponding activity tag
		if(this->activityTagName!="" && !act->activityTagsNames.contains(this->activityTagName)){
				continue;
		}
	
		assert(this->nActivities < MAX_ACTIVITIES);
		this->nActivities++;
		this->activitiesIndices.append(i);
	}
	
	assert(this->activitiesIndices.count()==this->nActivities);

	if(this->nActivities>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities). Please modify, deactivate, or remove it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesBeginOrEndTeachersDay::hasInactiveActivities(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

QString ConstraintActivitiesBeginOrEndTeachersDay::getXmlDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=IL2+"<ConstraintActivitiesBeginOrEndTeachersDay>\n";
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	s+=IL3+"<Teacher>"+protect(this->teacherName)+"</Teacher>\n";
	s+=IL3+"<Students>"+protect(this->studentsName)+"</Students>\n";
	s+=IL3+"<Subject>"+protect(this->subjectName)+"</Subject>\n";
	s+=IL3+"<Activity_Tag>"+protect(this->activityTagName)+"</Activity_Tag>\n";
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesBeginOrEndTeachersDay>\n";
	return s;
}

QString ConstraintActivitiesBeginOrEndTeachersDay::getDescription(Rules& r)
{
	Q_UNUSED(r);
	
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
		
	QString tc, st, su, at;
	
	if(this->teacherName!="")
		tc=tr("teacher=%1").arg(this->teacherName);
	else
		tc=tr("all teachers");
		
	if(this->studentsName!="")
		st=tr("students=%1").arg(this->studentsName);
	else
		st=tr("all students");
		
	if(this->subjectName!="")
		su=tr("subject=%1").arg(this->subjectName);
	else
		su=tr("all subjects");
		
	if(this->activityTagName!="")
		at=tr("activity tag=%1").arg(this->activityTagName);
	else
		at=tr("all activity tags");
	
	QString s;
	s+=tr("Activities with %1, %2, %3, %4, must begin or end teachers' day", "%1...%4 are conditions for the activities").arg(tc).arg(st).arg(su).arg(at);

	s+=translatedCommaSpace();

	s+=tr("WP:%1%", "Abbreviation for Weight Percentage").arg(CustomFETString::number(this->weightPercentage));

	return begin+s+end;
}

QString ConstraintActivitiesBeginOrEndTeachersDay::getDetailedDescription(Rules& r)
{
	Q_UNUSED(r);

	QString s=tr("Time constraint");s+="\n";
	s+=tr("Activities with:");s+="\n";

	if(this->teacherName!="")
		s+=tr("Teacher=%1").arg(this->teacherName);
	else
		s+=tr("All teachers");
	s+="\n";
		
	if(this->studentsName!="")
		s+=tr("Students=%1").arg(this->studentsName);
	else
		s+=tr("All students");
	s+="\n";
		
	if(this->subjectName!="")
		s+=tr("Subject=%1").arg(this->subjectName);
	else
		s+=tr("All subjects");
	s+="\n";
		
	if(this->activityTagName!="")
		s+=tr("Activity tag=%1").arg(this->activityTagName);
	else
		s+=tr("All activity tags");
	s+="\n";

	s+=tr("must begin or end teachers' day");
	s+="\n";

	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage));s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}

	return s;
}

double ConstraintActivitiesBeginOrEndTeachersDay::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString> &dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken=0;

	assert(r.internalStructureComputed);

	for(int kk=0; kk<this->nActivities; kk++){
		int tmp=0;
		int ai=this->activitiesIndices[kk];
	
		if(c.times[ai]!=UNALLOCATED_TIME){
			int d=c.times[ai]%r.nDaysPerWeek; //the day when this activity was scheduled
			int h=c.times[ai]/r.nDaysPerWeek; //the hour
		
			for(int j=0; j<r.internalActivitiesList[ai].iTeachersList.count(); j++){
				int tch=r.internalActivitiesList[ai].iTeachersList.at(j);
				bool ab=true;
				bool ae=true;
				for(int hh=h-1; hh>=0; hh--)
					if(teachersMatrix[tch][d][hh]>0){
						ab=false;
						break;
					}
				for(int hh=r.nHoursPerDay-1; hh>=h+r.internalActivitiesList[ai].duration; hh--)
					if(teachersMatrix[tch][d][hh]>0){
						ae=false;
						break;
					}
				if(!ab && !ae){
					tmp=1;
					nbroken++;
				}
				if(tmp>0)
					break;
			}

			if(conflictsString!=nullptr && tmp>0){
				QString s=tr("Time constraint activities begin or end teachers' day broken for activity with id=%1 (%2), increases conflicts total by %3",
				 "%1 is the id, %2 is the detailed description of the activity")
				 .arg(r.internalActivitiesList[ai].id)
				 .arg(getActivityDetailedDescription(r, r.internalActivitiesList[ai].id))
				 .arg(CustomFETString::numberPlusTwoDigitsPrecision(weightPercentage/100*tmp));

				dl.append(s);
				cl.append(weightPercentage/100*tmp);
	
				*conflictsString+= s+"\n";
			}
		}
	}

	if(weightPercentage==100)
		assert(nbroken==0);
	return nbroken * weightPercentage/100;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::isRelatedToActivity(Rules& r, Activity* a)
{
	int it;

	//check if this activity has the corresponding teacher
	if(this->teacherName!=""){
		it = a->teachersNames.indexOf(this->teacherName);
		if(it==-1)
			return false;
	}
	//check if this activity has the corresponding students
	if(this->studentsName!=""){
		bool commonStudents=false;
		for(const QString& st : std::as_const(a->studentsNames)){
			if(r.setsShareStudents(st, this->studentsName)){
				commonStudents=true;
				break;
			}
		}
		if(!commonStudents)
			return false;
	}
	//check if this activity has the corresponding subject
	if(this->subjectName!="" && a->subjectName!=this->subjectName)
		return false;
	//check if this activity has the corresponding activity tag
	if(this->activityTagName!="" && !a->activityTagsNames.contains(this->activityTagName))
		return false;

	return true;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
		
	return false;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::hasWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	return false;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::canRepairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0);
	
	return true;
}

bool ConstraintActivitiesBeginOrEndTeachersDay::repairWrongDayOrHour(Rules& r)
{
	Q_UNUSED(r);
	assert(0); //should check hasWrongDayOrHour, firstly

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots()
	: TimeConstraint()
{
	this->type = CONSTRAINT_ACTIVITIES_MAX_TOTAL_NUMBER_OF_STUDENTS_IN_SELECTED_TIME_SLOTS;
}

ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots(double wp,
	const QList<int>& a_L, const QList<int>& d_L, const QList<int>& h_L, int max_n_st)
	: TimeConstraint(wp)
{
	assert(d_L.count()==h_L.count());

	this->activitiesIds=a_L;
	this->selectedDays=d_L;
	this->selectedHours=h_L;
	this->maxNumberOfStudents=max_n_st;
	
	this->type=CONSTRAINT_ACTIVITIES_MAX_TOTAL_NUMBER_OF_STUDENTS_IN_SELECTED_TIME_SLOTS;
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::computeInternalStructure(QWidget* parent, Rules& r)
{
	//this cares about inactive activities and activities with 0 students, also, so do not assert this->_actIndices.count()==this->actIds.count()
	_activitiesIndices.clear();
	for(int id : std::as_const(activitiesIds)){
		int i=r.activitiesHash.value(id, -1);
		if(i>=0)
			if(r.internalActivitiesList[i].nTotalStudents>=1)
				_activitiesIndices.append(i);
	}

	/*this->_activitiesIndices.clear();
	
	QSet<int> req=this->activitiesIds.toSet();
	assert(req.count()==this->activitiesIds.count());
	
	//this cares about inactive activities, also, so do not assert this->_actIndices.count()==this->actIds.count()
	int i;
	for(i=0; i<r.nInternalActivities; i++)
		if(req.contains(r.internalActivitiesList[i].id))
			this->_activitiesIndices.append(i);*/
			
	//////////////////////
	assert(this->selectedDays.count()==this->selectedHours.count());
	
	for(int k=0; k<this->selectedDays.count(); k++){
		if(this->selectedDays.at(k) >= r.nDaysPerWeek){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max total number of students in selected time slots is wrong because it refers to removed day. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) == r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max total number of students in selected time slots is wrong because an hour is too late (after the last acceptable slot). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedHours.at(k) > r.nHoursPerDay){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max total number of students in selected time slots is wrong because it refers to removed hour. Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
		if(this->selectedDays.at(k)<0 || this->selectedHours.at(k)<0){
			TimeConstraintIrreconcilableMessage::information(parent, tr("FET information"),
			 tr("Constraint activities max total number of students in selected time slots is wrong because hour or day is not specified for a slot (-1). Please correct"
			 " and try again. Correcting means editing the constraint and updating information. Constraint is:\n%1").arg(this->getDetailedDescription(r)));
		
			return false;
		}
	}
	///////////////////////
	
	if(this->_activitiesIndices.count()>0)
		return true;
	else{
		TimeConstraintIrreconcilableMessage::warning(parent, tr("FET error in data"),
			tr("Following constraint is wrong (refers to no activities with the number of students > 0). Please correct it:\n%1").arg(this->getDetailedDescription(r)));
		return false;
	}
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::hasInactiveActivities(Rules& r)
{
	//returns true if all activities are inactive
	
	for(int aid : std::as_const(this->activitiesIds))
		if(!r.inactiveActivities.contains(aid))
			return false;

	return true;
}

QString ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::getXmlDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString s=IL2+"<ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots>\n";
	
	s+=IL3+"<Weight_Percentage>"+CustomFETString::number(this->weightPercentage)+"</Weight_Percentage>\n";
	
	s+=IL3+"<Number_of_Activities>"+QString::number(this->activitiesIds.count())+"</Number_of_Activities>\n";
	for(int aid : std::as_const(this->activitiesIds))
		s+=IL3+"<Activity_Id>"+CustomFETString::number(aid)+"</Activity_Id>\n";
	
	s+=IL3+"<Number_of_Selected_Time_Slots>"+QString::number(this->selectedDays.count())+"</Number_of_Selected_Time_Slots>\n";
	for(int i=0; i<this->selectedDays.count(); i++){
		s+=IL3+"<Selected_Time_Slot>\n";
		s+=IL4+"<Day>"+protect(r.daysOfTheWeek[this->selectedDays.at(i)])+"</Day>\n";
		s+=IL4+"<Hour>"+protect(r.hoursOfTheDay[this->selectedHours.at(i)])+"</Hour>\n";
		s+=IL3+"</Selected_Time_Slot>\n";
	}
	s+=IL3+"<Max_Total_Number_of_Students>"+CustomFETString::number(this->maxNumberOfStudents)+"</Max_Total_Number_of_Students>\n";
	
	s+=IL3+"<Active>"+trueFalse(active)+"</Active>\n";
	s+=IL3+"<Comments>"+protect(comments)+"</Comments>\n";
	s+=IL2+"</ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots>\n";
	return s;
}

QString ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::getDescription(Rules& r)
{
	QString begin=QString("");
	if(!active)
		begin="X - ";
		
	begin+="! ";
	
	QString end=QString("");
	if(!comments.isEmpty())
		end=translatedCommaSpace()+tr("C: %1", "Comments").arg(comments);
	
	assert(this->selectedDays.count()==this->selectedHours.count());

	QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=getActivityDescription(r, aid)+translatedCommaSpace();
	actids.chop(translatedCommaSpace().size());
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s=tr("Activities max total number of students in selected time slots, WP:%1%, NA:%2, A: %3, STS: %4, MTNS:%5", "Constraint description. WP means weight percentage, "
	 "NA means the number of activities, A means activities list, STS means selected time slots, MTNS means max total number of students")
	 .arg(CustomFETString::number(this->weightPercentage))
	 .arg(QString::number(this->activitiesIds.count()))
	 .arg(actids)
	 .arg(timeslots)
	 .arg(CustomFETString::number(this->maxNumberOfStudents));
	
	return begin+s+end;
}

QString ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::getDetailedDescription(Rules& r)
{
	assert(this->selectedDays.count()==this->selectedHours.count());

	/*QString actids=QString("");
	for(int aid : std::as_const(this->activitiesIds))
		actids+=CustomFETString::number(aid)+QString(", ");
	actids.chop(2);*/
	
	QString timeslots=QString("");
	for(int i=0; i<this->selectedDays.count(); i++)
		timeslots+=r.daysOfTheWeek[selectedDays.at(i)]+QString(" ")+r.hoursOfTheDay[selectedHours.at(i)]+translatedCommaSpace();
	timeslots.chop(translatedCommaSpace().size());
	
	QString s;
	s+=tr("Warning: this constraint might slow down very much the generation! Please use only if strictly necessary, and with care!"); s+="\n";
	s+=tr("Time constraint"); s+="\n";
	s+=tr("Activities max total number of students in selected time slots"); s+="\n";
	s+=tr("Weight (percentage)=%1%").arg(CustomFETString::number(this->weightPercentage)); s+="\n";
	s+=tr("Number of activities=%1").arg(QString::number(this->activitiesIds.count())); s+="\n";
	for(int id : std::as_const(this->activitiesIds)){
		s+=tr("Activity with id=%1 (%2)", "%1 is the id, %2 is the detailed description of the activity")
		 .arg(id)
		 .arg(getActivityDetailedDescription(r, id));
		s+="\n";
	}
	s+=tr("Selected time slots: %1").arg(timeslots); s+="\n";
	s+=tr("Maximum total number of students=%1").arg(CustomFETString::number(this->maxNumberOfStudents)); s+="\n";

	if(!active){
		s+=tr("Active time constraint=%1", "Represents a yes/no value, if a time constraint is active or not, %1 is yes or no").arg(yesNoTranslated(active));
		s+="\n";
	}
	if(!comments.isEmpty()){
		s+=tr("Comments=%1").arg(comments);
		s+="\n";
	}
	
	return s;
}

double ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::fitness(Solution& c, Rules& r, QList<double>& cl, QList<QString>& dl, FakeString* conflictsString)
{
	//if the matrices subgroupsMatrix and teachersMatrix are already calculated, do not calculate them again!
	if(!c.teachersMatrixReady || !c.subgroupsMatrixReady){
		c.teachersMatrixReady=true;
		c.subgroupsMatrixReady=true;
		subgroups_conflicts = c.getSubgroupsMatrix(r, subgroupsMatrix);
		teachers_conflicts = c.getTeachersMatrix(r, teachersMatrix);

		c.changedForMatrixCalculation=false;
	}

	int nbroken;

	assert(r.internalStructureComputed);

	///////////////////
	Matrix2D<int> nstudents;
	nstudents.resize(r.nDaysPerWeek, r.nHoursPerDay);
	for(int d=0; d<r.nDaysPerWeek; d++)
		for(int h=0; h<r.nHoursPerDay; h++)
			nstudents[d][h]=0;
	
	for(int ai : std::as_const(this->_activitiesIndices)){
		if(c.times[ai]!=UNALLOCATED_TIME){
			Activity* act=&r.internalActivitiesList[ai];
			int d=c.times[ai]%r.nDaysPerWeek;
			int h=c.times[ai]/r.nDaysPerWeek;
			for(int dur=0; dur<act->duration; dur++){
				assert(h+dur<r.nHoursPerDay);
				nstudents[d][h+dur]+=r.internalActivitiesList[ai].nTotalStudents;
			}
		}
	}

	nbroken=0;

	assert(this->selectedDays.count()==this->selectedHours.count());
	for(int t=0; t<this->selectedDays.count(); t++){
		int d=this->selectedDays.at(t);
		int h=this->selectedHours.at(t);
		
		if(nstudents[d][h] > this->maxNumberOfStudents)
			nbroken++;
	}

	if(nbroken>0){
		if(conflictsString!=nullptr){
			QString s=tr("Time constraint %1 broken - this should not happen, as this kind of constraint should "
			 "have only 100.0% weight. Please report error!").arg(this->getDescription(r));
			
			dl.append(s);
			cl.append(weightPercentage/100.0);
		
			*conflictsString+= s+"\n";
		}
	}

	if(weightPercentage==100.0)
		assert(nbroken==0);
	return nbroken * weightPercentage / 100.0;
}

void ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::removeUseless(Rules& r)
{
	QList<int> newActs;
	
	for(int aid : std::as_const(activitiesIds)){
		Activity* act=r.activitiesPointerHash.value(aid, nullptr);
		if(act!=nullptr)
			newActs.append(aid);
	}
	
	activitiesIds=newActs;

	r.internalStructureComputed=false;
}

void ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::recomputeActivitiesSet()
{
#if QT_VERSION >= QT_VERSION_CHECK(5,14,0)
	activitiesIdsSet=QSet<int>(activitiesIds.constBegin(), activitiesIds.constEnd());
#else
	activitiesIdsSet=activitiesIds.toSet();
#endif
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::isRelatedToActivity(Rules& r, Activity* a)
{
	Q_UNUSED(r);

	return activitiesIdsSet.contains(a->id);

	//return this->activitiesIds.contains(a->id);
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::isRelatedToTeacher(Teacher* t)
{
	Q_UNUSED(t);

	return false;
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::isRelatedToSubject(Subject* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::isRelatedToActivityTag(ActivityTag* s)
{
	Q_UNUSED(s);

	return false;
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::isRelatedToStudentsSet(Rules& r, StudentsSet* s)
{
	Q_UNUSED(r);
	Q_UNUSED(s);
	
	return false;
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::hasWrongDayOrHour(Rules& r)
{
	assert(selectedDays.count()==selectedHours.count());
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)<0 || selectedDays.at(i)>=r.nDaysPerWeek
		 || selectedHours.at(i)<0 || selectedHours.at(i)>=r.nHoursPerDay)
			return true;

	return false;
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::canRepairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	return true;
}

bool ConstraintActivitiesMaxTotalNumberOfStudentsInSelectedTimeSlots::repairWrongDayOrHour(Rules& r)
{
	assert(hasWrongDayOrHour(r));
	
	assert(selectedDays.count()==selectedHours.count());
	
	QList<int> newDays;
	QList<int> newHours;
	
	for(int i=0; i<selectedDays.count(); i++)
		if(selectedDays.at(i)>=0 && selectedDays.at(i)<r.nDaysPerWeek
		 && selectedHours.at(i)>=0 && selectedHours.at(i)<r.nHoursPerDay){
			newDays.append(selectedDays.at(i));
			newHours.append(selectedHours.at(i));
		}
	
	selectedDays=newDays;
	selectedHours=newHours;
	
	r.internalStructureComputed=false;
	setRulesModifiedAndOtherThings(&r);

	return true;
}
